"use strict";(self.webpackChunkmodel_registry_ui=self.webpackChunkmodel_registry_ui||[]).push([[118,737],{52600:(e,t,o)=>{o.d(t,{p:()=>s,x:()=>l});var r=o(44743),a=o(3322),n=o(48348),i=o(86506);function s(e){return n.createElement(a.pg,{flushSync:i.flushSync,...e})}var u=null,c=null;function d({unstable_getContext:e}){if(function(){if(!u&&window.__reactRouterContext&&window.__reactRouterManifest&&window.__reactRouterRouteModules){if(!0===window.__reactRouterManifest.sri){const e=document.querySelector("script[rr-importmap]");if(e?.textContent)try{window.__reactRouterManifest.sri=JSON.parse(e.textContent).integrity}catch(e){console.error("Failed to parse import map",e)}}u={context:window.__reactRouterContext,manifest:window.__reactRouterManifest,routeModules:window.__reactRouterRouteModules,stateDecodingPromise:void 0,router:void 0,routerInitialized:!1}}}(),!u)throw new Error("You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`");let t=u;if(!u.stateDecodingPromise){let e=u.context.stream;(0,a.V1)(e,"No stream found for single fetch decoding"),u.context.stream=void 0,u.stateDecodingPromise=(0,a.ht)(e,window).then(e=>{u.context.state=e.value,t.stateDecodingPromise.value=!0}).catch(e=>{t.stateDecodingPromise.error=e})}if(u.stateDecodingPromise.error)throw u.stateDecodingPromise.error;if(!u.stateDecodingPromise.value)throw u.stateDecodingPromise;let o,n=(0,a.qI)(u.manifest.routes,u.routeModules,u.context.state,u.context.ssr,u.context.isSpaMode);if(u.context.isSpaMode){let{loaderData:e}=u.context.state;u.manifest.routes.root?.hasLoader&&e&&"root"in e&&(o={loaderData:{root:e.root}})}else o=(0,r.Zd)(u.context.state,n,e=>({clientLoader:u.routeModules[e]?.clientLoader,hasLoader:!0===u.manifest.routes[e]?.hasLoader,hasHydrateFallback:null!=u.routeModules[e]?.HydrateFallback}),window.location,window.__reactRouterContext?.basename,u.context.isSpaMode),o&&o.errors&&(o.errors=(0,r.lR)(o.errors));let i=(0,a.aE)({routes:n,history:(0,a.zR)(),basename:u.context.basename,unstable_getContext:e,hydrationData:o,hydrationRouteProperties:a.jC,mapRouteProperties:a.nW,future:{unstable_middleware:u.context.future.unstable_middleware},dataStrategy:(0,a.aD)(()=>i,u.manifest,u.routeModules,u.context.ssr,u.context.basename),patchRoutesOnNavigation:(0,a.Wj)(u.manifest,u.routeModules,u.context.ssr,u.context.routeDiscovery,u.context.isSpaMode,u.context.basename)});return u.router=i,i.state.initialized&&(u.routerInitialized=!0,i.initialize()),i.createRoutesForHMR=a.ou,window.__reactRouterDataRouter=i,i}function l(e){c||(c=d({unstable_getContext:e.unstable_getContext}));let[t,o]=n.useState(void 0);n.useEffect(()=>{0},[]),n.useEffect(()=>{0},[t]);let[r,i]=n.useState(c.state.location);return n.useLayoutEffect(()=>{u&&u.router&&!u.routerInitialized&&(u.routerInitialized=!0,u.router.initialize())},[]),n.useLayoutEffect(()=>{if(u&&u.router)return u.router.subscribe(e=>{e.location!==r&&i(e.location)})},[r]),(0,a.V1)(u,"ssrInfo unavailable for HydratedRouter"),(0,a.p4)(c,u.manifest,u.routeModules,u.context.ssr,u.context.routeDiscovery,u.context.isSpaMode),n.createElement(n.Fragment,null,n.createElement(a.yL.Provider,{value:{manifest:u.manifest,routeModules:u.routeModules,future:u.context.future,criticalCss:t,ssr:u.context.ssr,isSpaMode:u.context.isSpaMode,routeDiscovery:u.context.routeDiscovery}},n.createElement(a.aJ,{location:r},n.createElement(s,{router:c,unstable_onError:e.unstable_onError}))),n.createElement(n.Fragment,null))}},70118:(e,t,o)=>{o.r(t),o.d(t,{HydratedRouter:()=>r.x,RouterProvider:()=>r.p});var r=o(52600),a=o(62127),n={};for(const e in a)["default","HydratedRouter","RouterProvider"].indexOf(e)<0&&(n[e]=()=>a[e]);o.d(t,n)}}]);
//# sourceMappingURL=118.bundle.js.map