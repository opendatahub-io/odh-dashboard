name: Modular Architecture - Quality Gates

on:
  pull_request:
    paths:
      - 'frontend/packages/**'
  workflow_dispatch:

permissions:
  contents: read
  actions: read
  pull-requests: write

env:
  NODE_VERSION: '20'
  GO_VERSION: '1.24.3'

jobs:
  detect-changes:
    name: Detect Module Changes
    runs-on: ubuntu-latest
    outputs:
      has-changes: ${{ steps.check-changes.outputs.has-changes }}
      changed-modules: ${{ steps.check-changes.outputs.changed-modules }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed modules
        id: check-changes
        run: |
          # Use GitHub API to get the actual files changed in this PR
          # This avoids issues with merge base and branch history
          PR_NUMBER="${{ github.event.pull_request.number }}"
          
          echo "Fetching files changed in PR #$PR_NUMBER"
          
          # Get changed files from GitHub API
          CHANGED_FILES=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER/files" | \
            jq -r '.[].filename' | grep "^frontend/packages/" | cut -d'/' -f3 | sort -u | tr '\n' ' ' | sed 's/ $//')
          
          echo "Changed modules from API: '$CHANGED_FILES'"
          
          # Include only structurally valid modules (no hardcoded names)
          FILTERED_MODULES=""
          for mod in $CHANGED_FILES; do
            base="frontend/packages/$mod"
            if [ -d "$base/upstream/frontend" ] || [ -d "$base/upstream/bff" ] || [ -d "$base/src" ] || [ -d "$base/bff" ]; then
              if [ -z "$FILTERED_MODULES" ]; then
                FILTERED_MODULES="$mod"
              else
                FILTERED_MODULES="$FILTERED_MODULES $mod"
              fi
              echo "Including module (structurally valid): $mod"
            else
              echo "Skipping non-module structure: $mod"
            fi
          done

          if [ -n "$FILTERED_MODULES" ]; then
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "changed-modules=$FILTERED_MODULES" >> $GITHUB_OUTPUT
          else
            echo "has-changes=false" >> $GITHUB_OUTPUT
          fi

  generate-matrix:
    name: Generate Test Matrix
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate test matrix
        id: generate-matrix
        run: |
          # Use the detected modules from previous job output
          CHANGED_MODULES="${{ needs.detect-changes.outputs.changed-modules }}"
          
          echo "Generating matrix for modules: '$CHANGED_MODULES'"
          
          # Build JSON array from space-separated string
          JSON_ARRAY="["
          FIRST=true
          for module in $CHANGED_MODULES; do
            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              JSON_ARRAY="$JSON_ARRAY,"
            fi
            JSON_ARRAY="$JSON_ARRAY\"$module\""
          done
          JSON_ARRAY="$JSON_ARRAY]"
          
          echo "Generated matrix: $JSON_ARRAY"
          echo "matrix=$JSON_ARRAY" >> $GITHUB_OUTPUT

  # Code Quality Gate removed for now

  # Quality Gate 2: Application Quality Gate
  application-quality-gate:
    name: Application Quality Gate
    runs-on: ubuntu-latest
    needs: [detect-changes, generate-matrix]
    if: needs.detect-changes.outputs.has-changes == 'true'
    strategy:
      matrix:
        module: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Check for silent mode configuration
        id: check-config
        run: |
          CONFIG_FILE="frontend/packages/${{ matrix.module }}/.quality-gates-config.yml"
          if [ -f "$CONFIG_FILE" ] && grep -q "silent_notifications: true" "$CONFIG_FILE"; then
            echo "üîï Silent mode enabled for ${{ matrix.module }}"
            echo "silent_mode=true" >> $GITHUB_OUTPUT
          else
            echo "üîî Silent mode disabled for ${{ matrix.module }}"
            echo "silent_mode=false" >> $GITHUB_OUTPUT
          fi

      - name: Assess Testing Maturity
        run: |
          MODULE_PATH="frontend/packages/${{ matrix.module }}"
          FRONTEND_PATH="$MODULE_PATH/upstream/frontend"
          
          echo "üéØ Assessing testing maturity for ${{ matrix.module }}"
          
          IMPLEMENTED_CHECKS=0
          MISSING_CHECKS=()
          TOTAL_CHECKS=6
          
          # Check 1: Unit Tests - Look in both module-specific and global test directories
          UNIT_TESTS_FOUND=false
          UNIT_FOUND_PATH=""
          
          # Check for unit tests in module's own structure
          if [ -n "$(find "$MODULE_PATH" -path "*/__tests__/unit/*" -name "*.test.*" -o -path "*/__tests__/unit/*" -name "*.spec.*" 2>/dev/null | head -1)" ]; then
            UNIT_TESTS_FOUND=true
            UNIT_FOUND_PATH="$MODULE_PATH"
          fi
          
          # Check module's upstream frontend for tests (excluding e2e/mocked)
          if [ "$UNIT_TESTS_FOUND" = false ] && [ -d "$FRONTEND_PATH" ]; then
            # Find __tests__ directories that are NOT e2e or mocked
            TEST_DIRS=$(find "$FRONTEND_PATH" -name "*__tests__*" -type d 2>/dev/null | grep -v "/e2e" | grep -v "/mocked")
            for test_dir in $TEST_DIRS; do
              UNIT_TEST_FILES=$(find "$test_dir" -name "*.test.*" -o -name "*.spec.*" 2>/dev/null)
              if [ -n "$UNIT_TEST_FILES" ]; then
              UNIT_TESTS_FOUND=true
              UNIT_FOUND_PATH="$test_dir"
                break
              fi
            done
          fi
          
          # Check for unit tests in global frontend test directory  
          if [ "$UNIT_TESTS_FOUND" = false ] && [ -d "frontend/src/__tests__/unit/" ]; then
            # Check for files with module name patterns
            MODULE_PATTERNS=(
              "${{ matrix.module }}"                        # exact: model-registry
              "$(echo ${{ matrix.module }} | sed 's/-//g')" # no hyphens: modelregistry
            )
            for pattern in "${MODULE_PATTERNS[@]}"; do
              UNIT_FILES=$(find "frontend/src/__tests__/unit/" -name "*${pattern}*" 2>/dev/null)
              if [ -n "$UNIT_FILES" ]; then
              UNIT_TESTS_FOUND=true
              UNIT_FOUND_PATH="frontend/src/__tests__/unit/"
                break
              fi
            done
          fi
          
          if [ "$UNIT_TESTS_FOUND" = true ]; then
            echo "‚úÖ Unit Tests - PRESENT"
            if [ -n "$UNIT_FOUND_PATH" ]; then
              echo "   üìÅ Found unit tests in: $UNIT_FOUND_PATH"
            fi
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå Unit Tests - MISSING"
            MISSING_CHECKS+=("Unit tests")
          fi
          
          # Check 2: E2E Tests - Look for module-specific e2e directories  
          E2E_TESTS_FOUND=false
          E2E_BASE_DIR="frontend/src/__tests__/cypress/cypress/tests/e2e"
          
          # Build module name patterns dynamically
          RAW_MODULE="${{ matrix.module }}"
          MODULE_NO_HYPHENS=$(echo "$RAW_MODULE" | sed 's/-//g')
          # module to camelCase (best-effort: split on '-')
          MODULE_CAMEL=$(echo "$RAW_MODULE" | awk -F'-' '{for(i=1;i<=NF;i++){if(i==1){printf $i}else{printf toupper(substr($i,1,1)) substr($i,2)}}}')
          MODULE_PATTERNS=("$RAW_MODULE" "$MODULE_NO_HYPHENS" "$MODULE_CAMEL")
          
          E2E_FOUND_PATH=""
          for pattern in "${MODULE_PATTERNS[@]}"; do
            if [ -d "$E2E_BASE_DIR/$pattern" ] && [ -n "$(find "$E2E_BASE_DIR/$pattern" -name "*.cy.ts" 2>/dev/null | head -1)" ]; then
              E2E_TESTS_FOUND=true
              E2E_FOUND_PATH="$E2E_BASE_DIR/$pattern"
              break
            fi
          done
          
          # Also check module's own cypress structure
          if [ "$E2E_TESTS_FOUND" = false ] && [ -n "$(find "$MODULE_PATH" -path "*/cypress/tests/e2e/*" -name "*.cy.ts" 2>/dev/null | head -1)" ]; then
            E2E_TESTS_FOUND=true
            E2E_FOUND_PATH="$MODULE_PATH/cypress/tests/e2e/"
          fi
          
          if [ "$E2E_TESTS_FOUND" = true ]; then
            echo "‚úÖ E2E Tests - PRESENT"
            if [ -n "$E2E_FOUND_PATH" ]; then
              echo "   üìÅ Found E2E tests in: $E2E_FOUND_PATH"
            fi
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå E2E Tests - MISSING"
            MISSING_CHECKS+=("End-to-end tests")
          fi
          
          # Check 3: Mock Tests
          MOCK_TESTS_FOUND=false
          # Check module's own cypress structure for mock tests
          if [ -n "$(find "$MODULE_PATH" -path "*/cypress/tests/mocked/*" -name "*.cy.ts" 2>/dev/null | head -1)" ]; then
            MOCK_TESTS_FOUND=true
          fi
          # Check global mocked tests directory
          if [ -d "frontend/src/__tests__/cypress/cypress/tests/mocked/" ]; then
            MODULE_PATTERNS=(
              "${{ matrix.module }}"                        # exact: model-registry
              "$(echo ${{ matrix.module }} | sed 's/-//g')" # no hyphens: modelregistry
            )
            for pattern in "${MODULE_PATTERNS[@]}"; do
              if [ -n "$(find "frontend/src/__tests__/cypress/cypress/tests/mocked/" -name "*${pattern}*" 2>/dev/null | head -1)" ]; then
                MOCK_TESTS_FOUND=true
                break
              fi
            done
          fi
          
          if [ "$MOCK_TESTS_FOUND" = true ]; then
            echo "‚úÖ Mock Tests - PRESENT"
            # Show where mock tests were found
            if [ -n "$(find "$MODULE_PATH" -path "*/cypress/tests/mocked/*" -name "*.cy.ts" 2>/dev/null | head -1)" ]; then
              echo "   üìÅ Found mock tests in: $MODULE_PATH/cypress/tests/mocked/"
            else
              echo "   üìÅ Found mock tests in: frontend/src/__tests__/cypress/cypress/tests/mocked/"
            fi
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå Mock Tests - MISSING"
            MISSING_CHECKS+=("Mock tests")
          fi
          
          # Check 4: Pact Testing
          PACT_FILE=$(find "$MODULE_PATH" -name "*pact*" -o -name "*contract*" 2>/dev/null | head -1)
          if [ -n "$PACT_FILE" ]; then
            echo "‚úÖ Pact Testing - PRESENT"
            echo "   üìÅ Found Pact tests in: $(dirname "$PACT_FILE")"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå Pact Testing - MISSING"
            MISSING_CHECKS+=("API contract testing (Pact)")
          fi
          
          # Check 5: API Functional Testing
          API_FUNC_FOUND=false
          API_FUNC_PATH=""
          # Cypress-based API tests in global structure (scoped by module patterns)
          API_BASE_DIR="frontend/src/__tests__/cypress/cypress/tests/api"
          if [ -d "$API_BASE_DIR" ]; then
            for pattern in "${MODULE_PATTERNS[@]}"; do
              if [ -d "$API_BASE_DIR/$pattern" ] && [ -n "$(find "$API_BASE_DIR/$pattern" -name "*.cy.*" 2>/dev/null | head -1)" ]; then
                API_FUNC_FOUND=true
                API_FUNC_PATH="$API_BASE_DIR/$pattern"
                break
              fi
              # accept -api or Api suffixed
              if [ -d "$API_BASE_DIR/${pattern}-api" ] && [ -n "$(find "$API_BASE_DIR/${pattern}-api" -name "*.cy.*" 2>/dev/null | head -1)" ]; then
                API_FUNC_FOUND=true
                API_FUNC_PATH="$API_BASE_DIR/${pattern}-api"
                break
              fi
              if [ -d "$API_BASE_DIR/${pattern}Api" ] && [ -n "$(find "$API_BASE_DIR/${pattern}Api" -name "*.cy.*" 2>/dev/null | head -1)" ]; then
                API_FUNC_FOUND=true
                API_FUNC_PATH="$API_BASE_DIR/${pattern}Api"
                break
              fi
            done
          fi
          # Module cypress api tests (scoped)
          if [ "$API_FUNC_FOUND" = false ]; then
            if [ -n "$(find "$MODULE_PATH" -path "*/cypress/tests/api*/*" -name "*.cy.*" 2>/dev/null | head -1)" ]; then
              # Prefer subdir matching module patterns if present
              FOUND=""
              for pattern in "${MODULE_PATTERNS[@]}"; do
                CANDIDATE="$MODULE_PATH/cypress/tests/api/$pattern"
                if [ -d "$CANDIDATE" ] && [ -n "$(find "$CANDIDATE" -name "*.cy.*" 2>/dev/null | head -1)" ]; then
                  FOUND="$CANDIDATE"
                  break
                fi
              done
              if [ -n "$FOUND" ]; then
                API_FUNC_FOUND=true
                API_FUNC_PATH="$FOUND"
              else
                API_FUNC_FOUND=true
                API_FUNC_PATH="$MODULE_PATH/cypress/tests/"
              fi
            fi
          fi
          # Jest-style API tests in frontend (scoped by module patterns in path or filename)
          if [ "$API_FUNC_FOUND" = false ] && [ -d "$FRONTEND_PATH/src/__tests__" ]; then
            API_JEST_FILE=$(find "$FRONTEND_PATH/src/__tests__" -type f \( -path "*/api/*" -o -name "*.api.test.*" -o -name "*.api.spec.*" \) 2>/dev/null | grep -E "$(printf '%s|' "${MODULE_PATTERNS[@]}" | sed 's/|$//')" | head -1)
            if [ -n "$API_JEST_FILE" ]; then
              API_FUNC_FOUND=true
              API_FUNC_PATH=$(dirname "$API_JEST_FILE")
            fi
          fi

          # Shared tests under frontend/packages (scoped by module patterns, excluding non-modules by structure)
          if [ "$API_FUNC_FOUND" = false ] && [ -d "frontend/packages" ]; then
            SHARED_API_PATH=$(find frontend/packages -type d \( -path "*/src/__tests__/api/*" -o -path "*/cypress/tests/api*/*" \) 2>/dev/null \
              | awk -F'/frontend/packages/' '{print $2}' | awk -F'/' 'NF{print $1"/"$0}' \
              | while read rel; do mod=$(echo "$rel" | cut -d'/' -f1); base="frontend/packages/$mod"; \
                  if [ -d "$base/upstream/frontend" ] || [ -d "$base/upstream/bff" ] || [ -d "$base/src" ] || [ -d "$base/bff" ]; then echo "$rel"; fi; done \
              | sed 's#^#frontend/packages/#' \
              | grep -E "$(printf '%s|' "${MODULE_PATTERNS[@]}" | sed 's/|$//')" \
              | head -1)
            if [ -n "$SHARED_API_PATH" ]; then
              API_FUNC_FOUND=true
              API_FUNC_PATH="$SHARED_API_PATH"
            fi
          fi
          if [ "$API_FUNC_FOUND" = true ]; then
            echo "‚úÖ API Functional Testing - PRESENT"
            echo "   üìÅ Found API functional tests in: $API_FUNC_PATH"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå API Functional Testing - MISSING"
            MISSING_CHECKS+=("API functional tests")
          fi
          
          # Check 6: API Performance Testing
          PERF_FILE=$(find "$MODULE_PATH" -name "*k6*" -o -name "*jmeter*" -o -name "*performance*" 2>/dev/null | head -1)
          if [ -n "$PERF_FILE" ]; then
            echo "‚úÖ API Performance Testing - PRESENT"
            echo "   üìÅ Found API performance tests in: $(dirname "$PERF_FILE")"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå API Performance Testing - MISSING"
            MISSING_CHECKS+=("API performance testing")
          fi
          
          # Check 7: Bundle Size Monitoring
          if [ -f "$FRONTEND_PATH/package.json" ] && grep -qE '"size-limit|bundlewatch"' "$FRONTEND_PATH/package.json"; then
            echo "‚úÖ Bundle Size Monitoring - PRESENT"
            echo "   üìÅ Found bundle size config in: $FRONTEND_PATH/package.json"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå Bundle Size Monitoring - MISSING"
            MISSING_CHECKS+=("Bundle size monitoring")
          fi

          # Accessibility testing check removed entirely
          
          # Calculate percentage
          # Update total checks to reflect categories (Unit, E2E, Mock, Pact, API Functional, API Performance, Bundle Size)
          TOTAL_CHECKS=7
          PERCENTAGE=$((IMPLEMENTED_CHECKS * 100 / TOTAL_CHECKS))
          
          echo ""
          echo "üìä Testing Maturity Assessment:"
          echo "   Implemented: $IMPLEMENTED_CHECKS/$TOTAL_CHECKS ($PERCENTAGE%)"
          
          # RHOAI Quality Thresholds
          if [ $PERCENTAGE -ge 75 ]; then
            echo "   üéØ RHOAI Quality Threshold: ‚úÖ PASSED ($PERCENTAGE% >= 75%)"
          else
            echo "   üéØ RHOAI Quality Threshold: ‚ùå NEEDS IMPROVEMENT ($PERCENTAGE% < 75%)"
            echo ""
            echo "üìã Recommendations for RHOAI readiness:"
            for check in "${MISSING_CHECKS[@]}"; do
              echo "   ‚Ä¢ Implement $check"
            done
          fi
          
          if [ $IMPLEMENTED_CHECKS -ge 2 ]; then
            echo "   üìà Good foundation: Multiple test categories implemented"
          fi

  # Deployment Quality Gate removed for now

  # Coverage combine step removed for now

  quality-gates-summary:
    name: Quality Gates Summary
    runs-on: ubuntu-latest
    needs: [detect-changes, application-quality-gate]
    if: always() && needs.detect-changes.outputs.has-changes == 'true'
    steps:
      - name: Generate Quality Gates Summary
        run: |
          echo "üìä Generating Quality Gates Summary..."
          
          # Build comprehensive quality gates summary
          SUMMARY_FILE="quality-gates-summary.md"
          
          # Compute stats (Application gate only)
          APP_PASS=$([ "${{ needs.application-quality-gate.result }}" == "success" ] && echo 1 || echo 0)
          TOTAL=$((1))
          PASSED=$((APP_PASS))
          FAILED=$((TOTAL - PASSED))

          echo "## üö¶ Modular Architecture Quality Gates Results" > $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "**Summary:** ${PASSED}/${TOTAL} gates passed (${FAILED} failed)" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          echo "### üìã Gate Results (Application only)" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          # Application Quality Gate
          if [ "${{ needs.application-quality-gate.result }}" == "success" ]; then
            echo "‚úÖ **Application Quality Gate** - PASSED" >> $SUMMARY_FILE
          else
            echo "‚ö†Ô∏è **Application Quality Gate** - ASSESSMENT" >> $SUMMARY_FILE
          fi
          echo "   - Testing maturity assessment" >> $SUMMARY_FILE
          echo "   - RHOAI quality thresholds evaluation" >> $SUMMARY_FILE
          echo "   - Recommendations provided" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          # Other gates are intentionally omitted in this branch
          
          echo "### üéØ Changed Modules" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "- ${{ needs.detect-changes.outputs.changed-modules }}" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          echo "### üìö Resources" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "- [Modular Architecture Guide](https://github.com/opendatahub-io/odh-dashboard/blob/main/docs/modular-architecture.md)" >> $SUMMARY_FILE
          echo "- [Quality Gates Documentation](https://github.com/opendatahub-io/odh-dashboard/blob/main/docs/modular-architecture-quality-gates.md)" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "---" >> $SUMMARY_FILE
          echo "*Generated by ODH Dashboard Modular Architecture Quality Gates*" >> $SUMMARY_FILE
          
          # Log to step summary
          cat $SUMMARY_FILE >> $GITHUB_STEP_SUMMARY
          
          echo "‚úÖ Summary generated and logged to step summary"

      - name: Upload summary as artifact
        uses: actions/upload-artifact@v4
        with:
          name: quality-gates-summary
          path: quality-gates-summary.md

      # PR comments handled by helper workflow (workflow_run)

