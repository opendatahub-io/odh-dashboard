name: Modular Architecture - Quality Gates

on:
  pull_request:
    paths:
      - 'frontend/packages/**'
  workflow_dispatch:

env:
  NODE_VERSION: '20'
  GO_VERSION: '1.24.3'

jobs:
  detect-changes:
    name: Detect Module Changes
    runs-on: ubuntu-latest
    outputs:
      has-changes: ${{ steps.check-changes.outputs.has-changes }}
      changed-modules: ${{ steps.check-changes.outputs.changed-modules }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed modules
        id: check-changes
        run: |
          # Use GitHub API to get the actual files changed in this PR
          # This avoids issues with merge base and branch history
          PR_NUMBER="${{ github.event.pull_request.number }}"
          
          echo "Fetching files changed in PR #$PR_NUMBER"
          
          # Get changed files from GitHub API
          CHANGED_FILES=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER/files" | \
            jq -r '.[].filename' | grep "^frontend/packages/" | cut -d'/' -f3 | sort -u | tr '\n' ' ' | sed 's/ $//')
          
          echo "Changed modules from API: '$CHANGED_FILES'"
          
          if [ -n "$CHANGED_FILES" ]; then
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "changed-modules=$CHANGED_FILES" >> $GITHUB_OUTPUT
          else
            echo "has-changes=false" >> $GITHUB_OUTPUT
          fi

  generate-matrix:
    name: Generate Test Matrix
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate test matrix
        id: generate-matrix
        run: |
          # Use the detected modules from previous job output
          CHANGED_MODULES="${{ needs.detect-changes.outputs.changed-modules }}"
          
          echo "Generating matrix for modules: '$CHANGED_MODULES'"
          
          # Build JSON array from space-separated string
          JSON_ARRAY="["
          FIRST=true
          for module in $CHANGED_MODULES; do
            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              JSON_ARRAY="$JSON_ARRAY,"
            fi
            JSON_ARRAY="$JSON_ARRAY\"$module\""
          done
          JSON_ARRAY="$JSON_ARRAY]"
          
          echo "Generated matrix: $JSON_ARRAY"
          echo "matrix=$JSON_ARRAY" >> $GITHUB_OUTPUT

  # Quality Gate 1: Code Quality Gate
  code-quality-gate:
    name: Code Quality Gate
    runs-on: ubuntu-latest
    needs: [detect-changes, generate-matrix]
    if: needs.detect-changes.outputs.has-changes == 'true'
    strategy:
      matrix:
        module: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
    outputs:
      has-coverage: ${{ steps.run-tests.outputs.has-coverage }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'frontend/package-lock.json'

      - name: Setup Go
        if: hashFiles(format('frontend/packages/{0}/bff/go.mod', matrix.module)) != ''
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Check for silent mode configuration
        id: check-config
        run: |
          CONFIG_FILE="frontend/packages/${{ matrix.module }}/.quality-gates-config.yml"
          if [ -f "$CONFIG_FILE" ]; then
            if grep -q "silent_notifications: true" "$CONFIG_FILE"; then
              echo "üîï Silent mode enabled for ${{ matrix.module }}"
              echo "silent_mode=true" >> $GITHUB_OUTPUT
            else
              echo "üîî Silent mode disabled for ${{ matrix.module }}"
              echo "silent_mode=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "üîî No config file found, silent mode disabled"
            echo "silent_mode=false" >> $GITHUB_OUTPUT
          fi

      - name: Install frontend dependencies
        working-directory: frontend
        run: npm ci

      - name: Install module dependencies
        working-directory: frontend/packages/${{ matrix.module }}
        run: |
          if [ -f "package.json" ]; then
            npm ci || echo "No package.json or npm ci failed"
          fi

      - name: Install BFF dependencies
        if: hashFiles(format('frontend/packages/{0}/bff/go.mod', matrix.module)) != '' && steps.check-config.outputs.silent_mode != 'true'
        working-directory: frontend/packages/${{ matrix.module }}/bff
        run: go mod download

      - name: Run Code Quality Checks
        if: steps.check-config.outputs.silent_mode != 'true'
        run: |
          MODULE_PATH="frontend/packages/${{ matrix.module }}"
          FRONTEND_PATH="$MODULE_PATH/upstream/frontend"
          BFF_PATH="$MODULE_PATH/upstream/bff"
          
          echo "üîç Checking modular architecture compliance for ${{ matrix.module }}"
          
          COMPLIANCE_CHECKS=0
          MISSING_CHECKS=()
          
          # Check 1: Package structure compliance
          if [ -f "$MODULE_PATH/package.json" ] && [ -f "$MODULE_PATH/extensions.ts" ]; then
            echo "‚úÖ Package Structure - COMPLIANT"
            COMPLIANCE_CHECKS=$((COMPLIANCE_CHECKS + 1))
          else
            echo "‚ùå Package Structure - NON-COMPLIANT"
            echo "   Missing package.json or extensions.ts"
            MISSING_CHECKS+=("Package structure (package.json, extensions.ts)")
          fi
          
          # Check 2: TypeScript configuration
          if [ -f "$MODULE_PATH/tsconfig.json" ]; then
            echo "‚úÖ TypeScript Config - PRESENT"
            COMPLIANCE_CHECKS=$((COMPLIANCE_CHECKS + 1))
          else
            echo "‚ùå TypeScript Config - MISSING"
            MISSING_CHECKS+=("TypeScript configuration")
          fi
          
          # Check 3: Shared Dependencies (ODH internal or mod-arch-shared)
          if [ -f "$MODULE_PATH/package.json" ] && grep -qE '"@odh-dashboard/|"mod-arch-shared"' "$MODULE_PATH/package.json"; then
            echo "‚úÖ Shared Dependencies - PRESENT"
            COMPLIANCE_CHECKS=$((COMPLIANCE_CHECKS + 1))
          else
            echo "‚ùå Shared Dependencies - MISSING"
            MISSING_CHECKS+=("ODH shared dependencies (e.g., @odh-dashboard/internal)")
          fi
          
          # Check 4: PatternFly usage  
          if [ -f "$FRONTEND_PATH/package.json" ]; then
            if grep -q "@patternfly" "$FRONTEND_PATH/package.json"; then
              echo "‚úÖ PatternFly Dependencies - PRESENT"
              COMPLIANCE_CHECKS=$((COMPLIANCE_CHECKS + 1))
            else
              echo "‚ùå PatternFly Dependencies - MISSING"
              MISSING_CHECKS+=("PatternFly UI framework dependencies")
              echo "   üìù Searched in: $FRONTEND_PATH/package.json"
            fi
          else
            echo "‚ùå Frontend package.json not found at: $FRONTEND_PATH/package.json"
            MISSING_CHECKS+=("Frontend package.json")
          fi
          
          # Frontend quality checks
          if [ -d "$FRONTEND_PATH" ]; then
            echo "üé® Running frontend checks..."
            
            # ESLint check
            if [ -f "$FRONTEND_PATH/.eslintrc.js" ] || [ -f "$FRONTEND_PATH/.eslintrc.cjs" ]; then
                          echo "‚úÖ ESLint Config - PRESENT"
            cd "$FRONTEND_PATH" 
            if npm run --silent 2>&1 | grep -q "lint"; then
              npm run lint || echo "‚ö†Ô∏è Linting issues found"
            else
              echo "   üìù No lint script found, skipping lint execution"
            fi
            else
              echo "‚ö†Ô∏è ESLint Config - MISSING"
            fi
          fi
          
          # BFF structure and quality checks
          if [ -d "$BFF_PATH" ] && [ -f "$BFF_PATH/go.mod" ]; then
            echo "üîß Running BFF checks..."
            
            # Check 5: BFF structure (go.mod + cmd/)
            if [ -d "$BFF_PATH/cmd" ]; then
              echo "‚úÖ BFF Structure - COMPLIANT (go.mod + cmd/)"
              COMPLIANCE_CHECKS=$((COMPLIANCE_CHECKS + 1))
            else
              echo "‚ùå BFF Structure - INCOMPLETE (missing cmd/ directory)"
              MISSING_CHECKS+=("BFF cmd/ directory structure")
            fi
            
            cd "$BFF_PATH"
            
            # Go formatting
            if ! gofmt -l . | grep -q .; then
              echo "‚úÖ Go Format - COMPLIANT"
            else
              echo "‚ùå Go Format - NON-COMPLIANT"
              gofmt -l .
            fi
            
            # Go lint (if available)
            if command -v golangci-lint &> /dev/null; then
              golangci-lint run || echo "‚ö†Ô∏è Linting issues found"
            fi
          else
            echo "‚ö†Ô∏è No BFF structure detected (go.mod not found)"
          fi
          
          echo "üìä Code Quality Summary:"
          echo "   Compliance Checks Passed: $COMPLIANCE_CHECKS"
          echo "   Missing Requirements: ${#MISSING_CHECKS[@]}"
          
          if [ ${#MISSING_CHECKS[@]} -gt 0 ]; then
            echo "‚ùå MISSING REQUIREMENTS:"
            for check in "${MISSING_CHECKS[@]}"; do
              echo "   - $check"
            done
          fi

      - name: Run Available Tests with Coverage
        id: run-tests
        run: |
          MODULE_PATH="frontend/packages/${{ matrix.module }}"
          FRONTEND_PATH="$MODULE_PATH/upstream/frontend"
          BFF_PATH="$MODULE_PATH/upstream/bff"
          HAS_COVERAGE=false
          
          echo "üß™ Running available tests for ${{ matrix.module }}"
          
          # Frontend tests
          if [ -d "$FRONTEND_PATH" ]; then
            cd "$FRONTEND_PATH"
            
            # Check for Jest tests
            if [ -f "package.json" ] && grep -qE '"test.*jest|jest.*test"' package.json; then
              echo "üéØ Running Jest tests..."
              npm test -- --coverage --watchAll=false || echo "‚ö†Ô∏è Some tests failed"
              
              if [ -f "coverage/lcov.info" ]; then
                HAS_COVERAGE=true
                mkdir -p "$GITHUB_WORKSPACE/coverage-artifacts"
                cp coverage/lcov.info "$GITHUB_WORKSPACE/coverage-artifacts/${{ matrix.module }}-frontend-coverage.json"
              fi
            fi
          fi
          
          # BFF tests
          if [ -d "$BFF_PATH" ] && [ -f "$BFF_PATH/go.mod" ] && [ "${{ steps.check-config.outputs.silent_mode }}" != "true" ]; then
            cd "$BFF_PATH"
            
            echo "üîß Running Go tests..."
            go test -v -coverprofile=coverage.out ./... || echo "‚ö†Ô∏è Some tests failed"
            
            if [ -f "coverage.out" ]; then
              HAS_COVERAGE=true
              mkdir -p "$GITHUB_WORKSPACE/coverage-artifacts"
              cp coverage.out "$GITHUB_WORKSPACE/coverage-artifacts/${{ matrix.module }}-bff-coverage.out"
            fi
          elif [ "${{ steps.check-config.outputs.silent_mode }}" = "true" ]; then
            echo "üîï Skipping BFF tests due to silent mode"
          fi
          
          echo "has-coverage=$HAS_COVERAGE" >> $GITHUB_OUTPUT

      - name: Upload coverage artifacts
        if: steps.run-tests.outputs.has-coverage == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.module }}-coverage
          path: coverage-artifacts/

  # Quality Gate 2: Application Quality Gate
  application-quality-gate:
    name: Application Quality Gate
    runs-on: ubuntu-latest
    needs: [detect-changes, generate-matrix]
    if: needs.detect-changes.outputs.has-changes == 'true'
    strategy:
      matrix:
        module: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Check for silent mode configuration
        id: check-config
        run: |
          CONFIG_FILE="frontend/packages/${{ matrix.module }}/.quality-gates-config.yml"
          if [ -f "$CONFIG_FILE" ] && grep -q "silent_notifications: true" "$CONFIG_FILE"; then
            echo "üîï Silent mode enabled for ${{ matrix.module }}"
            echo "silent_mode=true" >> $GITHUB_OUTPUT
          else
            echo "üîî Silent mode disabled for ${{ matrix.module }}"
            echo "silent_mode=false" >> $GITHUB_OUTPUT
          fi

      - name: Assess Testing Maturity
        run: |
          MODULE_PATH="frontend/packages/${{ matrix.module }}"
          FRONTEND_PATH="$MODULE_PATH/upstream/frontend"
          
          echo "üéØ Assessing testing maturity for ${{ matrix.module }}"
          
          IMPLEMENTED_CHECKS=0
          MISSING_CHECKS=()
          TOTAL_CHECKS=7
          
          # Check 1: Unit Tests - Look in both module-specific and global test directories
          UNIT_TESTS_FOUND=false
          
          # Check for unit tests in module's own structure
          if [ -n "$(find "$MODULE_PATH" -path "*/__tests__/unit/*" -name "*.test.*" -o -path "*/__tests__/unit/*" -name "*.spec.*" 2>/dev/null | head -1)" ]; then
            UNIT_TESTS_FOUND=true
          fi
          
          # Check module's upstream frontend for tests (excluding e2e/mocked)
          if [ "$UNIT_TESTS_FOUND" = false ] && [ -d "$FRONTEND_PATH" ]; then
            # Find __tests__ directories that are NOT e2e or mocked
            TEST_DIRS=$(find "$FRONTEND_PATH" -name "*__tests__*" -type d 2>/dev/null | grep -v "/e2e" | grep -v "/mocked")
            for test_dir in $TEST_DIRS; do
              UNIT_TEST_FILES=$(find "$test_dir" -name "*.test.*" -o -name "*.spec.*" 2>/dev/null)
              if [ -n "$UNIT_TEST_FILES" ]; then
                UNIT_TESTS_FOUND=true
                echo "   üìÅ Found unit tests in: $test_dir"
                break
              fi
            done
          fi
          
          # Check for unit tests in global frontend test directory  
          if [ "$UNIT_TESTS_FOUND" = false ] && [ -d "frontend/src/__tests__/unit/" ]; then
            # Check for files with module name patterns
            MODULE_PATTERNS=(
              "${{ matrix.module }}"                        # exact: model-registry
              "$(echo ${{ matrix.module }} | sed 's/-//g')" # no hyphens: modelregistry
            )
            for pattern in "${MODULE_PATTERNS[@]}"; do
              UNIT_FILES=$(find "frontend/src/__tests__/unit/" -name "*${pattern}*" 2>/dev/null)
              if [ -n "$UNIT_FILES" ]; then
                UNIT_TESTS_FOUND=true
                echo "   üìÅ Found unit tests in: frontend/src/__tests__/unit/ (pattern: ${pattern})"
                break
              fi
            done
          fi
          
          if [ "$UNIT_TESTS_FOUND" = true ]; then
            echo "‚úÖ Unit Tests - PRESENT"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå Unit Tests - MISSING"
            MISSING_CHECKS+=("Unit tests")
          fi
          
          # Check 2: E2E Tests - Look for module-specific e2e directories  
          E2E_TESTS_FOUND=false
          E2E_BASE_DIR="frontend/src/__tests__/cypress/cypress/tests/e2e"
          
          # Check multiple naming patterns for the module in the global e2e directory
          MODULE_PATTERNS=(
            "${{ matrix.module }}"                    # exact name: model-registry
            "$(echo ${{ matrix.module }} | sed 's/-//g')"  # no hyphens: modelregistry  
            "modelRegistry"                          # common camelCase for model-registry
            "llamaStack"                             # common camelCase for llama-stack
            "nim"                                    # single word modules
          )
          
          for pattern in "${MODULE_PATTERNS[@]}"; do
            if [ -d "$E2E_BASE_DIR/$pattern" ] && [ -n "$(find "$E2E_BASE_DIR/$pattern" -name "*.cy.ts" 2>/dev/null | head -1)" ]; then
              E2E_TESTS_FOUND=true
              echo "   üìÅ Found E2E tests in: $E2E_BASE_DIR/$pattern"
              break
            fi
          done
          
          # Also check module's own cypress structure
          if [ -n "$(find "$MODULE_PATH" -path "*/cypress/tests/e2e/*" -name "*.cy.ts" 2>/dev/null | head -1)" ]; then
            E2E_TESTS_FOUND=true
            echo "   üìÅ Found E2E tests in module path: $MODULE_PATH"
          fi
          
          if [ "$E2E_TESTS_FOUND" = true ]; then
            echo "‚úÖ E2E Tests - PRESENT"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå E2E Tests - MISSING"
            MISSING_CHECKS+=("End-to-end tests")
          fi
          
          # Check 3: Mock Tests
          MOCK_TESTS_FOUND=false
          # Check module's own cypress structure for mock tests
          if [ -n "$(find "$MODULE_PATH" -path "*/cypress/tests/mocked/*" -name "*.cy.ts" 2>/dev/null | head -1)" ]; then
            MOCK_TESTS_FOUND=true
          fi
          # Check global mocked tests directory
          if [ -d "frontend/src/__tests__/cypress/cypress/tests/mocked/" ]; then
            MODULE_PATTERNS=(
              "${{ matrix.module }}"                        # exact: model-registry
              "$(echo ${{ matrix.module }} | sed 's/-//g')" # no hyphens: modelregistry
            )
            for pattern in "${MODULE_PATTERNS[@]}"; do
              if [ -n "$(find "frontend/src/__tests__/cypress/cypress/tests/mocked/" -name "*${pattern}*" 2>/dev/null | head -1)" ]; then
                MOCK_TESTS_FOUND=true
                break
              fi
            done
          fi
          
          if [ "$MOCK_TESTS_FOUND" = true ]; then
            echo "‚úÖ Mock Tests - PRESENT"
            # Show where mock tests were found
            if [ -n "$(find "$MODULE_PATH" -path "*/cypress/tests/mocked/*" -name "*.cy.ts" 2>/dev/null | head -1)" ]; then
              echo "   üìÅ Found mock tests in: $MODULE_PATH/cypress/tests/mocked/"
            else
              echo "   üìÅ Found mock tests in: frontend/src/__tests__/cypress/cypress/tests/mocked/"
            fi
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå Mock Tests - MISSING"
            MISSING_CHECKS+=("Mock tests")
          fi
          
          # Check 4: Pact Testing
          if [ -n "$(find "$MODULE_PATH" -name "*pact*" -o -name "*contract*" 2>/dev/null | head -1)" ]; then
            echo "‚úÖ Pact Testing - PRESENT"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå Pact Testing - MISSING"
            MISSING_CHECKS+=("API contract testing (Pact)")
          fi
          
          # Check 5: API Performance Testing
          if [ -n "$(find "$MODULE_PATH" -name "*k6*" -o -name "*jmeter*" -o -name "*performance*" 2>/dev/null | head -1)" ]; then
            echo "‚úÖ API Performance Testing - PRESENT"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå API Performance Testing - MISSING"
            MISSING_CHECKS+=("API performance testing")
          fi
          
          # Check 6: Bundle Size Monitoring
          if [ -f "$FRONTEND_PATH/package.json" ] && grep -qE '"size-limit|bundlewatch"' "$FRONTEND_PATH/package.json"; then
            echo "‚úÖ Bundle Size Monitoring - PRESENT"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå Bundle Size Monitoring - MISSING"
            MISSING_CHECKS+=("Bundle size monitoring")
          fi
          
          # Check 7: Accessibility Testing
          if [ -n "$(find "$MODULE_PATH" -name "*a11y*" -o -name "*accessibility*" -o -name "*axe*" 2>/dev/null | head -1)" ]; then
            echo "‚úÖ Accessibility Testing - PRESENT"
            A11Y_FILE=$(find "$MODULE_PATH" -name "*a11y*" -o -name "*accessibility*" -o -name "*axe*" 2>/dev/null | head -1)
            echo "   üìÅ Found accessibility tests in: $(dirname "$A11Y_FILE")"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå Accessibility Testing - MISSING"
            MISSING_CHECKS+=("Accessibility testing")
          fi
          
          # Calculate percentage
          PERCENTAGE=$((IMPLEMENTED_CHECKS * 100 / TOTAL_CHECKS))
          
          echo ""
          echo "üìä Testing Maturity Assessment:"
          echo "   Implemented: $IMPLEMENTED_CHECKS/$TOTAL_CHECKS ($PERCENTAGE%)"
          
          # RHOAI Quality Thresholds
          if [ $PERCENTAGE -ge 75 ]; then
            echo "   üéØ RHOAI Quality Threshold: ‚úÖ PASSED ($PERCENTAGE% >= 75%)"
          else
            echo "   üéØ RHOAI Quality Threshold: ‚ùå NEEDS IMPROVEMENT ($PERCENTAGE% < 75%)"
            echo ""
            echo "üìã Recommendations for RHOAI readiness:"
            for check in "${MISSING_CHECKS[@]}"; do
              echo "   ‚Ä¢ Implement $check"
            done
          fi
          
          if [ $IMPLEMENTED_CHECKS -ge 2 ]; then
            echo "   üìà Good foundation: Multiple test categories implemented"
          fi

  # Quality Gate 3: Deployment Quality Gate
  deployment-quality-gate:
    name: Deployment Quality Gate
    runs-on: ubuntu-latest
    needs: [detect-changes, generate-matrix]
    if: needs.detect-changes.outputs.has-changes == 'true'
    strategy:
      matrix:
        module: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for silent mode configuration
        id: check-config
        run: |
          CONFIG_FILE="frontend/packages/${{ matrix.module }}/.quality-gates-config.yml"
          if [ -f "$CONFIG_FILE" ] && grep -q "silent_notifications: true" "$CONFIG_FILE"; then
            echo "üîï Silent mode enabled for ${{ matrix.module }}"
            echo "silent_mode=true" >> $GITHUB_OUTPUT
          else
            echo "üîî Silent mode disabled for ${{ matrix.module }}"
            echo "silent_mode=false" >> $GITHUB_OUTPUT
          fi

      - name: Validate Deployment Readiness
        run: |
          MODULE_PATH="frontend/packages/${{ matrix.module }}"
          FRONTEND_PATH="$MODULE_PATH/upstream/frontend"
          
          echo "üöÄ Validating deployment readiness for ${{ matrix.module }}"
          
          IMPLEMENTED_CHECKS=0
          MISSING_CHECKS=()
          TOTAL_CHECKS=4
          
          # Check 1: Dockerfile presence
          if [ -f "$MODULE_PATH/Dockerfile" ] || [ -f "$MODULE_PATH/Dockerfile.workspace" ]; then
            echo "‚úÖ Dockerfile - PRESENT"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå Dockerfile - MISSING"
            echo "   Required for containerized deployment"
            MISSING_CHECKS+=("Dockerfile for containerization")
          fi
          
          # Check 2: Module Federation configuration
          MODULE_FEDERATION_FOUND=false
          # Check module root package.json first
          if [ -f "$MODULE_PATH/package.json" ] && grep -q '"module-federation"' "$MODULE_PATH/package.json"; then
            echo "‚úÖ Module Federation Config - PRESENT (module root)"
            MODULE_FEDERATION_FOUND=true
          # Then check upstream frontend package.json
          elif [ -f "$FRONTEND_PATH/package.json" ] && grep -qE '"@module-federation|module-federation"' "$FRONTEND_PATH/package.json"; then
            echo "‚úÖ Module Federation Config - PRESENT (upstream frontend)"
            MODULE_FEDERATION_FOUND=true
          fi
          
          if [ "$MODULE_FEDERATION_FOUND" = true ]; then
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
            
            # Validate federation config (check module root first)
            if [ -f "$MODULE_PATH/package.json" ] && grep -A 20 '"module-federation"' "$MODULE_PATH/package.json" | grep -q '"remoteEntry"'; then
              echo "   ‚úÖ Remote entry configured"
            fi
            
            if [ -f "$MODULE_PATH/package.json" ] && grep -A 20 '"module-federation"' "$MODULE_PATH/package.json" | grep -q '"proxy"'; then
              echo "   ‚úÖ API proxy configuration found"
            fi
            
            if [ -f "$MODULE_PATH/package.json" ] && grep -A 20 '"module-federation"' "$MODULE_PATH/package.json" | grep -q '"authorize"'; then
              echo "   ‚úÖ Authorization setting configured"
            fi
          else
            echo "‚ùå Module Federation Config - MISSING"
            echo "   Required for federated deployment in ODH Dashboard"
            MISSING_CHECKS+=("Module Federation configuration")
          fi
          
          # Check 3: ODH Extensions compatibility
          if [ -f "$MODULE_PATH/extensions.ts" ]; then
            echo "‚úÖ ODH Extensions - PRESENT"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
            
            # Check for proper extension exports
            if grep -q "export.*Extension" "$MODULE_PATH/extensions.ts"; then
              echo "   ‚úÖ Extension exports found"
            fi
          else
            echo "‚ùå ODH Extensions - MISSING"
            MISSING_CHECKS+=("ODH extension configuration")
          fi
          
          # Check 4: Health checks
          BFF_PATH="$MODULE_PATH/upstream/bff"
          if [ -d "$BFF_PATH" ]; then
            if grep -r "health" "$BFF_PATH" > /dev/null 2>&1; then
              echo "‚úÖ Health Checks - PRESENT"
              IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
            else
              echo "‚ùå Health Checks - MISSING"
              MISSING_CHECKS+=("Health check endpoints")
            fi
          else
            echo "‚ö†Ô∏è No BFF detected, health checks not applicable"
            TOTAL_CHECKS=$((TOTAL_CHECKS - 1))
          fi
          
          # Check 5: Security configurations
          SECURITY_FOUND=false
          
          # Check Dockerfile for security best practices
          DOCKERFILE=""
          # Look for Dockerfile in multiple locations
          echo "   üîç Searching for Dockerfile in multiple locations:"
          for dockerfile_path in "$MODULE_PATH/Dockerfile" "$MODULE_PATH/Dockerfile.workspace" "$MODULE_PATH/upstream/Dockerfile" "$BFF_PATH/Dockerfile"; do
            echo "      Checking: $dockerfile_path"
            if [ -f "$dockerfile_path" ]; then
              DOCKERFILE="$dockerfile_path"
              echo "      ‚úÖ Found: $dockerfile_path"
              break
            else
              echo "      ‚ùå Not found: $dockerfile_path"
            fi
          done
          
          if [ -n "$DOCKERFILE" ]; then
            echo "   üìÑ Using Dockerfile: $DOCKERFILE"
            
            # Check for non-root user
            if grep -q "USER.*[0-9]" "$DOCKERFILE"; then
              echo "   ‚úÖ Non-root user configured"
              SECURITY_FOUND=true
            fi
            
            # Check for security-focused base images
            if grep -qE "distroless|scratch|alpine|DISTROLESS_BASE_IMAGE" "$DOCKERFILE"; then
              echo "   ‚úÖ Security-focused base image"
              SECURITY_FOUND=true
            fi
            
            # Check for exposed ports
            if grep -q "EXPOSE" "$DOCKERFILE"; then
              echo "   ‚úÖ Port exposure configured"
              SECURITY_FOUND=true
            fi
          fi
          
          # Check for authorization in Module Federation
          if [ -f "$MODULE_PATH/package.json" ] && grep -A 10 '"module-federation"' "$MODULE_PATH/package.json" | grep -q '"authorize".*true'; then
            echo "   ‚úÖ Authorization enabled in Module Federation"
            SECURITY_FOUND=true
          fi
          
          if [ "$SECURITY_FOUND" = true ]; then
            echo "‚úÖ Security Configurations - PRESENT"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå Security Configurations - MISSING"
            MISSING_CHECKS+=("Security configurations (non-root user, secure base images, authorization)")
          fi
          
          # Update total checks to include security
          TOTAL_CHECKS=5
          
          # Calculate percentage
          PERCENTAGE=$((IMPLEMENTED_CHECKS * 100 / TOTAL_CHECKS))
          
          echo ""
          echo "üìä Deployment Readiness Assessment:"
          echo "   Implemented: $IMPLEMENTED_CHECKS/$TOTAL_CHECKS ($PERCENTAGE%)"
          
          if [ $PERCENTAGE -ge 75 ]; then
            echo "   üöÄ Deployment Ready: ‚úÖ PASSED ($PERCENTAGE% >= 75%)"
          else
            echo "   üöÄ Deployment Ready: ‚ö†Ô∏è NEEDS ATTENTION ($PERCENTAGE% < 75%)"
            echo ""
            echo "üìã Required for deployment:"
            for check in "${MISSING_CHECKS[@]}"; do
              echo "   ‚Ä¢ $check"
            done
          fi

  combine-coverage:
    name: Combine Coverage & Upload
    runs-on: ubuntu-latest
    needs: [code-quality-gate]
    if: always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all coverage artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: "*-coverage"
          path: all-coverage
          merge-multiple: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Combine coverage reports
        run: |
          echo "üìä Combining coverage reports..."
          mkdir -p ./combined-coverage
          
          # Find and combine coverage files from per-module artifacts
          # Support both "<module>-coverage.json" and "<module>-unit-coverage.json"
          find all-coverage -type f \( -name "*-coverage.json" -o -name "*-unit-coverage.json" \) | while read file; do
            module=$(basename "$file" | sed -E 's/-(unit-)?coverage\.json$//')
            cp "$file" "./combined-coverage/${module}-coverage.json"
          done
          
          if [ "$(ls -A ./combined-coverage)" ]; then
            npx nyc merge ./combined-coverage ./combined-coverage/merged-coverage.json
            echo "üìä Coverage files merged successfully"
          else
            echo "‚ö†Ô∏è No coverage files found to combine"
          fi

      - name: Upload to Codecov
        if: hashFiles('./combined-coverage/merged-coverage.json') != ''
        uses: codecov/codecov-action@v4
        with:
          files: ./combined-coverage/merged-coverage.json
          flags: modular-arch
          token: ${{ secrets.CODECOV_TOKEN }}

  quality-gates-summary:
    name: Quality Gates Summary
    runs-on: ubuntu-latest
    needs: [detect-changes, code-quality-gate, application-quality-gate, deployment-quality-gate]
    if: always() && needs.detect-changes.outputs.has-changes == 'true'
    steps:
      - name: Generate Quality Gates Summary
        run: |
          echo "üìä Generating Quality Gates Summary..."
          
          # Build comprehensive quality gates summary
          SUMMARY_FILE="quality-gates-summary.md"
          
          # Compute stats
          CODE_PASS=$([ "${{ needs.code-quality-gate.result }}" == "success" ] && echo 1 || echo 0)
          APP_PASS=$([ "${{ needs.application-quality-gate.result }}" == "success" ] && echo 1 || echo 0)
          DEP_PASS=$([ "${{ needs.deployment-quality-gate.result }}" == "success" ] && echo 1 || echo 0)
          TOTAL=$((3))
          PASSED=$((CODE_PASS + APP_PASS + DEP_PASS))
          FAILED=$((TOTAL - PASSED))

          echo "## üö¶ Modular Architecture Quality Gates Results" > $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "**Summary:** ${PASSED}/${TOTAL} gates passed (${FAILED} failed)" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          echo "### üìã Gate Results" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          # Code Quality Gate
          if [ "${{ needs.code-quality-gate.result }}" == "success" ]; then
            echo "‚úÖ **Code Quality Gate** - PASSED" >> $SUMMARY_FILE
          else
            echo "‚ùå **Code Quality Gate** - FAILED" >> $SUMMARY_FILE
          fi
          echo "   - Modular architecture compliance" >> $SUMMARY_FILE
          echo "   - Code quality checks" >> $SUMMARY_FILE
          echo "   - Available test execution" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          # Application Quality Gate
          if [ "${{ needs.application-quality-gate.result }}" == "success" ]; then
            echo "‚úÖ **Application Quality Gate** - PASSED" >> $SUMMARY_FILE
          else
            echo "‚ö†Ô∏è **Application Quality Gate** - ASSESSMENT" >> $SUMMARY_FILE
          fi
          echo "   - Testing maturity assessment" >> $SUMMARY_FILE
          echo "   - RHOAI quality thresholds evaluation" >> $SUMMARY_FILE
          echo "   - Recommendations provided" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          # Deployment Quality Gate
          if [ "${{ needs.deployment-quality-gate.result }}" == "success" ]; then
            echo "‚úÖ **Deployment Quality Gate** - PASSED" >> $SUMMARY_FILE
          else
            echo "‚ö†Ô∏è **Deployment Quality Gate** - ASSESSMENT" >> $SUMMARY_FILE
          fi
          echo "   - Deployment readiness validation" >> $SUMMARY_FILE
          echo "   - ODH/RHOAI integration checks" >> $SUMMARY_FILE
          echo "   - Configuration compliance" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          echo "### üéØ Changed Modules" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "- ${{ needs.detect-changes.outputs.changed-modules }}" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          echo "### üìö Resources" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "- [Modular Architecture Guide](https://github.com/opendatahub-io/odh-dashboard/blob/main/docs/modular-architecture.md)" >> $SUMMARY_FILE
          echo "- [Quality Gates Documentation](https://github.com/opendatahub-io/odh-dashboard/blob/main/docs/modular-architecture-quality-gates.md)" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "---" >> $SUMMARY_FILE
          echo "*Generated by ODH Dashboard Modular Architecture Quality Gates*" >> $SUMMARY_FILE
          
          # Log to step summary
          cat $SUMMARY_FILE >> $GITHUB_STEP_SUMMARY
          
          echo "‚úÖ Summary generated and logged to step summary"

      - name: Upload summary as artifact
        uses: actions/upload-artifact@v4
        with:
          name: quality-gates-summary
          path: quality-gates-summary.md

      - name: Post Quality Gates Summary as PR Comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const fs = require('fs');
            
            try {
              // Read the summary file
              const summaryContent = fs.readFileSync('quality-gates-summary.md', 'utf8');
              console.log('‚úÖ Successfully read quality gates summary');
              console.log(`üìä Summary length: ${summaryContent.length} characters`);
              
              const prNumber = context.issue.number;
              console.log(`üìã Posting to PR #${prNumber}`);
              
              // Check for existing quality gates comments
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
              });
              
              const botComment = comments.data.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes('üö¶ Modular Architecture Quality Gates Results')
              );
              
              if (botComment) {
                // Update existing comment
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: summaryContent
                });
                console.log('‚úÖ Updated existing quality gates comment');
              } else {
                // Create new comment
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: summaryContent
                });
                console.log('‚úÖ Created new quality gates comment on PR');
              }
              
            } catch (error) {
              console.log('‚ùå Failed to post PR comment:', error.message);
              console.log('üìä This may be due to permissions on forked PRs');
              console.log('üìÑ Summary will be available in artifacts and job summary');
            }

