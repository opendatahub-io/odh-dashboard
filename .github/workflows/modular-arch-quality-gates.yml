name: Modular Architecture - Quality Gates

on:
  pull_request:
    paths:
      - 'frontend/packages/**'
  workflow_dispatch:

env:
  NODE_VERSION: '20'
  GO_VERSION: '1.24.3'

jobs:
  detect-changes:
    name: Detect Module Changes
    runs-on: ubuntu-latest
    outputs:
      has-changes: ${{ steps.check-changes.outputs.has-changes }}
      changed-modules: ${{ steps.check-changes.outputs.changed-modules }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed modules
        id: check-changes
        run: |
          # Use GitHub API to get the actual files changed in this PR
          # This avoids issues with merge base and branch history
          PR_NUMBER="${{ github.event.pull_request.number }}"
          
          echo "Fetching files changed in PR #$PR_NUMBER"
          
          # Get changed files from GitHub API
          CHANGED_FILES=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER/files" | \
            jq -r '.[].filename' | grep "^frontend/packages/" | cut -d'/' -f3 | sort -u | tr '\n' ' ' | sed 's/ $//')
          
          echo "Changed modules from API: '$CHANGED_FILES'"
          
          if [ -n "$CHANGED_FILES" ]; then
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "changed-modules=$CHANGED_FILES" >> $GITHUB_OUTPUT
          else
            echo "has-changes=false" >> $GITHUB_OUTPUT
          fi

  generate-matrix:
    name: Generate Test Matrix
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate test matrix
        id: generate-matrix
        run: |
          # Use the detected modules from previous job output
          CHANGED_MODULES="${{ needs.detect-changes.outputs.changed-modules }}"
          
          echo "Generating matrix for modules: '$CHANGED_MODULES'"
          
          # Build JSON array from space-separated string
          JSON_ARRAY="["
          FIRST=true
          for module in $CHANGED_MODULES; do
            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              JSON_ARRAY="$JSON_ARRAY,"
            fi
            JSON_ARRAY="$JSON_ARRAY\"$module\""
          done
          JSON_ARRAY="$JSON_ARRAY]"
          
          echo "Generated matrix: $JSON_ARRAY"
          echo "matrix=$JSON_ARRAY" >> $GITHUB_OUTPUT

  # Code Quality Gate removed for now

  # Quality Gate 2: Application Quality Gate
  application-quality-gate:
    name: Application Quality Gate
    runs-on: ubuntu-latest
    needs: [detect-changes, generate-matrix]
    if: needs.detect-changes.outputs.has-changes == 'true'
    strategy:
      matrix:
        module: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Check for silent mode configuration
        id: check-config
        run: |
          CONFIG_FILE="frontend/packages/${{ matrix.module }}/.quality-gates-config.yml"
          if [ -f "$CONFIG_FILE" ] && grep -q "silent_notifications: true" "$CONFIG_FILE"; then
            echo "üîï Silent mode enabled for ${{ matrix.module }}"
            echo "silent_mode=true" >> $GITHUB_OUTPUT
          else
            echo "üîî Silent mode disabled for ${{ matrix.module }}"
            echo "silent_mode=false" >> $GITHUB_OUTPUT
          fi

      - name: Assess Testing Maturity
        run: |
          MODULE_PATH="frontend/packages/${{ matrix.module }}"
          FRONTEND_PATH="$MODULE_PATH/upstream/frontend"
          
          echo "üéØ Assessing testing maturity for ${{ matrix.module }}"
          
          IMPLEMENTED_CHECKS=0
          MISSING_CHECKS=()
          TOTAL_CHECKS=6
          
          # Check 1: Unit Tests - Look in both module-specific and global test directories
          UNIT_TESTS_FOUND=false
          
          # Check for unit tests in module's own structure
          if [ -n "$(find "$MODULE_PATH" -path "*/__tests__/unit/*" -name "*.test.*" -o -path "*/__tests__/unit/*" -name "*.spec.*" 2>/dev/null | head -1)" ]; then
            UNIT_TESTS_FOUND=true
          fi
          
          # Check module's upstream frontend for tests (excluding e2e/mocked)
          if [ "$UNIT_TESTS_FOUND" = false ] && [ -d "$FRONTEND_PATH" ]; then
            # Find __tests__ directories that are NOT e2e or mocked
            TEST_DIRS=$(find "$FRONTEND_PATH" -name "*__tests__*" -type d 2>/dev/null | grep -v "/e2e" | grep -v "/mocked")
            for test_dir in $TEST_DIRS; do
              UNIT_TEST_FILES=$(find "$test_dir" -name "*.test.*" -o -name "*.spec.*" 2>/dev/null)
              if [ -n "$UNIT_TEST_FILES" ]; then
                UNIT_TESTS_FOUND=true
                echo "   üìÅ Found unit tests in: $test_dir"
                break
              fi
            done
          fi
          
          # Check for unit tests in global frontend test directory  
          if [ "$UNIT_TESTS_FOUND" = false ] && [ -d "frontend/src/__tests__/unit/" ]; then
            # Check for files with module name patterns
            MODULE_PATTERNS=(
              "${{ matrix.module }}"                        # exact: model-registry
              "$(echo ${{ matrix.module }} | sed 's/-//g')" # no hyphens: modelregistry
            )
            for pattern in "${MODULE_PATTERNS[@]}"; do
              UNIT_FILES=$(find "frontend/src/__tests__/unit/" -name "*${pattern}*" 2>/dev/null)
              if [ -n "$UNIT_FILES" ]; then
                UNIT_TESTS_FOUND=true
                echo "   üìÅ Found unit tests in: frontend/src/__tests__/unit/ (pattern: ${pattern})"
                break
              fi
            done
          fi
          
          if [ "$UNIT_TESTS_FOUND" = true ]; then
            echo "‚úÖ Unit Tests - PRESENT"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå Unit Tests - MISSING"
            MISSING_CHECKS+=("Unit tests")
          fi
          
          # Check 2: E2E Tests - Look for module-specific e2e directories  
          E2E_TESTS_FOUND=false
          E2E_BASE_DIR="frontend/src/__tests__/cypress/cypress/tests/e2e"
          
          # Check multiple naming patterns for the module in the global e2e directory
          MODULE_PATTERNS=(
            "${{ matrix.module }}"                    # exact name: model-registry
            "$(echo ${{ matrix.module }} | sed 's/-//g')"  # no hyphens: modelregistry  
            "modelRegistry"                          # common camelCase for model-registry
            "llamaStack"                             # common camelCase for llama-stack
            "nim"                                    # single word modules
          )
          
          E2E_FOUND_PATH=""
          for pattern in "${MODULE_PATTERNS[@]}"; do
            if [ -d "$E2E_BASE_DIR/$pattern" ] && [ -n "$(find "$E2E_BASE_DIR/$pattern" -name "*.cy.ts" 2>/dev/null | head -1)" ]; then
              E2E_TESTS_FOUND=true
              E2E_FOUND_PATH="$E2E_BASE_DIR/$pattern"
              break
            fi
          done
          
          # Also check module's own cypress structure
          if [ "$E2E_TESTS_FOUND" = false ] && [ -n "$(find "$MODULE_PATH" -path "*/cypress/tests/e2e/*" -name "*.cy.ts" 2>/dev/null | head -1)" ]; then
            E2E_TESTS_FOUND=true
            E2E_FOUND_PATH="$MODULE_PATH/cypress/tests/e2e/"
          fi
          
          if [ "$E2E_TESTS_FOUND" = true ]; then
            echo "‚úÖ E2E Tests - PRESENT"
            if [ -n "$E2E_FOUND_PATH" ]; then
              echo "   üìÅ Found E2E tests in: $E2E_FOUND_PATH"
            fi
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå E2E Tests - MISSING"
            MISSING_CHECKS+=("End-to-end tests")
          fi
          
          # Check 3: Mock Tests
          MOCK_TESTS_FOUND=false
          # Check module's own cypress structure for mock tests
          if [ -n "$(find "$MODULE_PATH" -path "*/cypress/tests/mocked/*" -name "*.cy.ts" 2>/dev/null | head -1)" ]; then
            MOCK_TESTS_FOUND=true
          fi
          # Check global mocked tests directory
          if [ -d "frontend/src/__tests__/cypress/cypress/tests/mocked/" ]; then
            MODULE_PATTERNS=(
              "${{ matrix.module }}"                        # exact: model-registry
              "$(echo ${{ matrix.module }} | sed 's/-//g')" # no hyphens: modelregistry
            )
            for pattern in "${MODULE_PATTERNS[@]}"; do
              if [ -n "$(find "frontend/src/__tests__/cypress/cypress/tests/mocked/" -name "*${pattern}*" 2>/dev/null | head -1)" ]; then
                MOCK_TESTS_FOUND=true
                break
              fi
            done
          fi
          
          if [ "$MOCK_TESTS_FOUND" = true ]; then
            echo "‚úÖ Mock Tests - PRESENT"
            # Show where mock tests were found
            if [ -n "$(find "$MODULE_PATH" -path "*/cypress/tests/mocked/*" -name "*.cy.ts" 2>/dev/null | head -1)" ]; then
              echo "   üìÅ Found mock tests in: $MODULE_PATH/cypress/tests/mocked/"
            else
              echo "   üìÅ Found mock tests in: frontend/src/__tests__/cypress/cypress/tests/mocked/"
            fi
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå Mock Tests - MISSING"
            MISSING_CHECKS+=("Mock tests")
          fi
          
          # Check 4: Pact Testing
          if [ -n "$(find "$MODULE_PATH" -name "*pact*" -o -name "*contract*" 2>/dev/null | head -1)" ]; then
            echo "‚úÖ Pact Testing - PRESENT"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå Pact Testing - MISSING"
            MISSING_CHECKS+=("API contract testing (Pact)")
          fi
          
          # Check 5: API Performance Testing
          if [ -n "$(find "$MODULE_PATH" -name "*k6*" -o -name "*jmeter*" -o -name "*performance*" 2>/dev/null | head -1)" ]; then
            echo "‚úÖ API Performance Testing - PRESENT"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå API Performance Testing - MISSING"
            MISSING_CHECKS+=("API performance testing")
          fi
          
          # Check 6: Bundle Size Monitoring
          if [ -f "$FRONTEND_PATH/package.json" ] && grep -qE '"size-limit|bundlewatch"' "$FRONTEND_PATH/package.json"; then
            echo "‚úÖ Bundle Size Monitoring - PRESENT"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
          else
            echo "‚ùå Bundle Size Monitoring - MISSING"
            MISSING_CHECKS+=("Bundle size monitoring")
          fi
          
          # Check 7: Accessibility Testing - REMOVED (inaccurate detection)
          # Accessibility testing detection was producing false positives
          echo "‚ö†Ô∏è Accessibility Testing - REMOVED (inaccurate detection)"
          
          # Calculate percentage
          PERCENTAGE=$((IMPLEMENTED_CHECKS * 100 / TOTAL_CHECKS))
          
          echo ""
          echo "üìä Testing Maturity Assessment:"
          echo "   Implemented: $IMPLEMENTED_CHECKS/$TOTAL_CHECKS ($PERCENTAGE%)"
          
          # RHOAI Quality Thresholds
          if [ $PERCENTAGE -ge 75 ]; then
            echo "   üéØ RHOAI Quality Threshold: ‚úÖ PASSED ($PERCENTAGE% >= 75%)"
          else
            echo "   üéØ RHOAI Quality Threshold: ‚ùå NEEDS IMPROVEMENT ($PERCENTAGE% < 75%)"
            echo ""
            echo "üìã Recommendations for RHOAI readiness:"
            for check in "${MISSING_CHECKS[@]}"; do
              echo "   ‚Ä¢ Implement $check"
            done
          fi
          
          if [ $IMPLEMENTED_CHECKS -ge 2 ]; then
            echo "   üìà Good foundation: Multiple test categories implemented"
          fi

  # Deployment Quality Gate removed for now

  # Coverage combine step removed for now

  quality-gates-summary:
    name: Quality Gates Summary
    runs-on: ubuntu-latest
    needs: [detect-changes, application-quality-gate]
    if: always() && needs.detect-changes.outputs.has-changes == 'true'
    steps:
      - name: Generate Quality Gates Summary
        run: |
          echo "üìä Generating Quality Gates Summary..."
          
          # Build comprehensive quality gates summary
          SUMMARY_FILE="quality-gates-summary.md"
          
          # Compute stats (Application gate only)
          APP_PASS=$([ "${{ needs.application-quality-gate.result }}" == "success" ] && echo 1 || echo 0)
          TOTAL=$((1))
          PASSED=$((APP_PASS))
          FAILED=$((TOTAL - PASSED))

          echo "## üö¶ Modular Architecture Quality Gates Results" > $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "**Summary:** ${PASSED}/${TOTAL} gates passed (${FAILED} failed)" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          echo "### üìã Gate Results (Application only)" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          # Application Quality Gate
          if [ "${{ needs.application-quality-gate.result }}" == "success" ]; then
            echo "‚úÖ **Application Quality Gate** - PASSED" >> $SUMMARY_FILE
          else
            echo "‚ö†Ô∏è **Application Quality Gate** - ASSESSMENT" >> $SUMMARY_FILE
          fi
          echo "   - Testing maturity assessment" >> $SUMMARY_FILE
          echo "   - RHOAI quality thresholds evaluation" >> $SUMMARY_FILE
          echo "   - Recommendations provided" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          # Other gates are intentionally omitted in this branch
          
          echo "### üéØ Changed Modules" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "- ${{ needs.detect-changes.outputs.changed-modules }}" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          echo "### üìö Resources" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "- [Modular Architecture Guide](https://github.com/opendatahub-io/odh-dashboard/blob/main/docs/modular-architecture.md)" >> $SUMMARY_FILE
          echo "- [Quality Gates Documentation](https://github.com/opendatahub-io/odh-dashboard/blob/main/docs/modular-architecture-quality-gates.md)" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "---" >> $SUMMARY_FILE
          echo "*Generated by ODH Dashboard Modular Architecture Quality Gates*" >> $SUMMARY_FILE
          
          # Log to step summary
          cat $SUMMARY_FILE >> $GITHUB_STEP_SUMMARY
          
          echo "‚úÖ Summary generated and logged to step summary"

      - name: Upload summary as artifact
        uses: actions/upload-artifact@v4
        with:
          name: quality-gates-summary
          path: quality-gates-summary.md

      - name: Post Quality Gates Summary as PR Comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const fs = require('fs');
            
            try {
              // Read the summary file
              const summaryContent = fs.readFileSync('quality-gates-summary.md', 'utf8');
              console.log('‚úÖ Successfully read quality gates summary');
              console.log(`üìä Summary length: ${summaryContent.length} characters`);
              
              const prNumber = context.issue.number;
              console.log(`üìã Posting to PR #${prNumber}`);
              
              // Check for existing quality gates comments
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
              });
              
              const botComment = comments.data.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes('üö¶ Modular Architecture Quality Gates Results')
              );
              
              if (botComment) {
                // Update existing comment
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: summaryContent
                });
                console.log('‚úÖ Updated existing quality gates comment');
              } else {
                // Create new comment
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: summaryContent
                });
                console.log('‚úÖ Created new quality gates comment on PR');
              }
              
            } catch (error) {
              console.log('‚ùå Failed to post PR comment:', error.message);
              console.log('üìä This may be due to permissions on forked PRs');
              console.log('üìÑ Summary will be available in artifacts and job summary');
            }

