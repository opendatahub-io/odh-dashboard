name: 'Modular Architecture - Quality Gates'

on:
  pull_request:
    paths:
      - 'frontend/packages/**'
      - '.github/workflows/modular-arch-quality-gates.yml'
  push:
    paths:
      - 'frontend/packages/**'
    branches:
      - main
      - stable

env:
  NODE_VERSION: 20.x
  GO_VERSION: '1.24.3'

jobs:
  detect-changes:
    name: Detect Module Changes
    runs-on: ubuntu-latest
    outputs:
      modules-matrix: ${{ steps.generate-matrix.outputs.modules-matrix }}
      has-changes: ${{ steps.check-changes.outputs.has-changes }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed modules
        id: check-changes
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PRs, use the base SHA directly (GitHub Actions provides it)
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.sha }}"
            DIFF_RANGE="$BASE_SHA...$HEAD_SHA"
          else
            DIFF_RANGE="${{ github.event.before || 'HEAD~1' }}..HEAD"
          fi

          CHANGED_MODULES=$(git diff --name-only $DIFF_RANGE | grep '^frontend/packages/' | cut -d'/' -f3 | sort -u)
          echo "üîç DEBUG: DIFF_RANGE=$DIFF_RANGE"
          echo "üîç DEBUG: All changed files:"
          git diff --name-only $DIFF_RANGE
          echo "üîç DEBUG: Frontend package files:"
          git diff --name-only $DIFF_RANGE | grep '^frontend/packages/' || echo "No frontend/packages files found"
          echo "üîç DEBUG: Changed modules: '$CHANGED_MODULES'"

          if [ -n "$CHANGED_MODULES" ]; then
            echo "‚úÖ has-changes=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå has-changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate test matrix
        id: generate-matrix
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PRs, use the base SHA directly (GitHub Actions provides it)
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.sha }}"
            DIFF_RANGE="$BASE_SHA...$HEAD_SHA"
          else
            DIFF_RANGE="${{ github.event.before || 'HEAD~1' }}..HEAD"
          fi

          CHANGED_MODULES=$(git diff --name-only $DIFF_RANGE | grep '^frontend/packages/' | cut -d'/' -f3 | sort -u)
          echo "üîç DEBUG: DIFF_RANGE=$DIFF_RANGE"
          echo "üîç DEBUG: All changed files in matrix generation:"
          git diff --name-only $DIFF_RANGE
          echo "üîç DEBUG: Changed modules for matrix: '$CHANGED_MODULES'"
          
          if [ -n "$CHANGED_MODULES" ]; then
            # Create JSON array properly with error handling
            MATRIX_JSON="["
            FIRST=true
            for module in $CHANGED_MODULES; do
              echo "üîç DEBUG: Adding module to matrix: $module"
              if [ "$FIRST" = true ]; then
                MATRIX_JSON="${MATRIX_JSON}\"${module}\""
                FIRST=false
              else
                MATRIX_JSON="${MATRIX_JSON},\"${module}\""
              fi
            done
            MATRIX_JSON="${MATRIX_JSON}]"
            echo "üîç DEBUG: Final matrix JSON: $MATRIX_JSON"
            echo "modules-matrix=${MATRIX_JSON}" >> $GITHUB_OUTPUT
          else
            echo "üîç DEBUG: No changed modules - setting empty matrix"
            echo "modules-matrix=[]" >> $GITHUB_OUTPUT
          fi

  # Quality Gate 1: Code Quality Gate
  code-quality-gate:
    name: Code Quality Gate
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    strategy:
      fail-fast: false
      matrix:
        module: ${{ fromJson(needs.detect-changes.outputs.modules-matrix) }}
    steps:
      - uses: actions/checkout@v4

      - name: üîç Check Quality Gates Configuration
        id: check-config
        run: |
          MODULE_PATH="frontend/packages/${{ matrix.module }}"

          # Check if quality gate notifications should be silenced for this module
          SILENT_MODE="false"
          SILENT_REASON=""

          # Check for .quality-gates-config.yml
          if [ -f ".quality-gates-config.yml" ]; then
            if grep -q "^  ${{ matrix.module }}:" .quality-gates-config.yml; then
              STATUS=$(grep -A1 "^  ${{ matrix.module }}:" .quality-gates-config.yml | grep "status:" | awk '{print $2}' | tr -d '"')
              if [ "$STATUS" = "silent" ]; then
                SILENT_MODE="true"
                REASON=$(grep -A2 "^  ${{ matrix.module }}:" .quality-gates-config.yml | grep "reason:" | cut -d'"' -f2)
                SILENT_REASON="${REASON:-Quality gate notifications silenced}"
              fi
            fi
          fi

          echo "silent_mode=$SILENT_MODE" >> $GITHUB_OUTPUT
          echo "silent_reason=$SILENT_REASON" >> $GITHUB_OUTPUT

          if [ "$SILENT_MODE" = "true" ]; then
            echo "üîï Quality Gate Notifications SILENCED for ${{ matrix.module }}"
            echo "üìã Reason: $SILENT_REASON"
            echo ""
            echo "‚ÑπÔ∏è  Quality checks may still run in background for metrics"
            echo "‚ÑπÔ∏è  To restore notifications, update .quality-gates-config.yml"
          else
            echo "üîç Running quality gates with full notifications for ${{ matrix.module }}"
          fi

      - name: Setup Node.js
        if: steps.check-config.outputs.silent_mode != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Go
        if: steps.check-config.outputs.silent_mode != 'true' && hashFiles(format('frontend/packages/{0}/bff/go.mod', matrix.module)) != ''
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: üîç Validate Modular Architecture Compliance
        if: steps.check-config.outputs.silent_mode != 'true'
        run: |
          MODULE_PATH="frontend/packages/${{ matrix.module }}"
          echo "üîç Checking modular architecture compliance for: ${{ matrix.module }}"

          ERRORS=0

          # 1. Check for mod-arch-shared dependency (if frontend exists)
          if [ -d "$MODULE_PATH/frontend" ]; then
            if [ ! -f "$MODULE_PATH/frontend/package.json" ]; then
              echo "‚ùå Missing frontend/package.json"
              ERRORS=$((ERRORS + 1))
            elif ! grep -q '"mod-arch-shared"' "$MODULE_PATH/frontend/package.json"; then
              echo "‚ùå Missing mod-arch-shared dependency - required for modular architecture"
              echo "   Add: npm install mod-arch-shared"
              ERRORS=$((ERRORS + 1))
            else
              echo "‚úÖ mod-arch-shared dependency found"
            fi

            # 2. Check for ModularArchContextProvider usage
            if [ -f "$MODULE_PATH/frontend/src/bootstrap.tsx" ]; then
              if ! grep -q "ModularArchContextProvider" "$MODULE_PATH/frontend/src/bootstrap.tsx"; then
                echo "‚ùå ModularArchContextProvider not found in bootstrap.tsx"
                echo "   Required for modular architecture integration"
                ERRORS=$((ERRORS + 1))
              else
                echo "‚úÖ ModularArchContextProvider usage found"
              fi
            elif [ -f "$MODULE_PATH/frontend/src/index.tsx" ]; then
              if ! grep -q "ModularArchContextProvider" "$MODULE_PATH/frontend/src/index.tsx"; then
                echo "‚ùå ModularArchContextProvider not found in index.tsx"
                echo "   Required for modular architecture integration"
                ERRORS=$((ERRORS + 1))
              else
                echo "‚úÖ ModularArchContextProvider usage found"
              fi
            else
              echo "‚ùå Missing entry point (bootstrap.tsx or index.tsx)"
              ERRORS=$((ERRORS + 1))
            fi

            # 3. Check for required PatternFly dependencies
            REQUIRED_DEPS=("@patternfly/react-core" "@patternfly/react-icons" "react" "react-dom")
            for dep in "${REQUIRED_DEPS[@]}"; do
              if ! grep -q "\"$dep\"" "$MODULE_PATH/frontend/package.json"; then
                echo "‚ùå Missing required dependency: $dep"
                ERRORS=$((ERRORS + 1))
              fi
            done

            if [ $ERRORS -eq 0 ]; then
              echo "‚úÖ All PatternFly dependencies found"
            fi
          fi

          # 4. Check BFF compliance (if BFF exists)
          if [ -d "$MODULE_PATH/bff" ]; then
            if [ ! -f "$MODULE_PATH/bff/go.mod" ]; then
              echo "‚ùå Missing bff/go.mod - required for Go BFF"
              ERRORS=$((ERRORS + 1))
            fi

            if [ ! -f "$MODULE_PATH/bff/Makefile" ]; then
              echo "‚ùå Missing bff/Makefile - required for standardized build"
              ERRORS=$((ERRORS + 1))
            fi

            if [ ! -d "$MODULE_PATH/bff/cmd" ]; then
              echo "‚ùå Missing bff/cmd directory - required for Go application"
              ERRORS=$((ERRORS + 1))
            fi

            if [ $ERRORS -eq 0 ]; then
              echo "‚úÖ BFF structure compliant"
            fi
          fi

          if [ $ERRORS -gt 0 ]; then
            echo ""
            echo "‚ùå Code Quality Gate FAILED with $ERRORS error(s)"
            echo "üìñ See modular architecture documentation for compliance requirements"
            exit 1
          else
            echo ""
            echo "‚úÖ Code Quality Gate PASSED - Modular architecture compliant!"
          fi

      - name: üß™ Run Code Quality Checks
        if: steps.check-config.outputs.silent_mode != 'true'
        run: |
          MODULE_PATH="frontend/packages/${{ matrix.module }}"

          # Frontend checks
          if [ -d "$MODULE_PATH/frontend" ]; then
            echo "üß™ Running frontend code quality checks..."
            cd "$MODULE_PATH/frontend"

            if [ -f "package.json" ]; then
              npm ci

              # TypeScript check
              if grep -q '"test:type-check"' package.json; then
                echo "üîç TypeScript compilation check..."
                npm run test:type-check
              fi

              # Linting check
              if grep -q '"test:lint"' package.json; then
                echo "üîç ESLint check..."
                npm run test:lint
              fi

              # Build check
              if grep -q '"build"' package.json; then
                echo "üîç Build verification..."
                npm run build
              fi
            fi

            cd - > /dev/null
          fi

          # BFF checks
          if [ -d "$MODULE_PATH/bff" ]; then
            echo "üß™ Running BFF code quality checks..."
            cd "$MODULE_PATH/bff"

            if [ -f "Makefile" ]; then
              # Go formatting check
              if grep -q "^fmt:" Makefile; then
                echo "üîç Go formatting check..."
                make fmt
                if [ -n "$(git status --porcelain)" ]; then
                  echo "‚ùå Go code not properly formatted"
                  git diff
                  exit 1
                fi
              fi

              # Go build check
              if grep -q "^build:" Makefile; then
                echo "üîç Go build check..."
                make build
              fi
            fi

            cd - > /dev/null
          fi

  # Quality Gate 3: Application Quality Gate
  application-quality-gate:
    name: Application Quality Gate
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    strategy:
      fail-fast: false
      matrix:
        module: ${{ fromJson(needs.detect-changes.outputs.modules-matrix) }}
    outputs:
      has-coverage: ${{ steps.coverage-check.outputs.has-coverage }}
    steps:
      - uses: actions/checkout@v4

      - name: üîç Check Quality Gates Configuration
        id: check-config
        run: |
          MODULE_PATH="frontend/packages/${{ matrix.module }}"

          # Check if quality gate notifications should be silenced for this module
          SILENT_MODE="false"
          SILENT_REASON=""

          # Check for .quality-gates-config.yml
          if [ -f ".quality-gates-config.yml" ]; then
            if grep -q "^  ${{ matrix.module }}:" .quality-gates-config.yml; then
              STATUS=$(grep -A1 "^  ${{ matrix.module }}:" .quality-gates-config.yml | grep "status:" | awk '{print $2}' | tr -d '"')
              if [ "$STATUS" = "silent" ]; then
                SILENT_MODE="true"
                REASON=$(grep -A2 "^  ${{ matrix.module }}:" .quality-gates-config.yml | grep "reason:" | cut -d'"' -f2)
                SILENT_REASON="${REASON:-Quality gate notifications silenced}"
              fi
            fi
          fi

          echo "silent_mode=$SILENT_MODE" >> $GITHUB_OUTPUT
          echo "silent_reason=$SILENT_REASON" >> $GITHUB_OUTPUT

          if [ "$SILENT_MODE" = "true" ]; then
            echo "üîï Quality Gate Notifications SILENCED for ${{ matrix.module }}"
            echo "üìã Reason: $SILENT_REASON"
            echo ""
            echo "‚ÑπÔ∏è  Quality checks may still run in background for metrics"
            echo "‚ÑπÔ∏è  To restore notifications, update .quality-gates-config.yml"
          else
            echo "üîç Running quality gates with full notifications for ${{ matrix.module }}"
          fi

      - name: Setup Node.js
        if: steps.check-config.outputs.silent_mode != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Go
        if: steps.check-config.outputs.silent_mode != 'true' && hashFiles(format('frontend/packages/{0}/bff/go.mod', matrix.module)) != ''
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: üß™ Comprehensive Testing Maturity Assessment
        id: testing-assessment
        run: |
          MODULE_PATH="frontend/packages/${{ matrix.module }}"
          echo "üß™ Assessing testing maturity for: ${{ matrix.module }}"
          echo "Based on Modular Architecture QE Requirements (7 test categories)"
          echo "üéØ Model Registry Example: Comprehensive Cypress e2e tests with workflows"
          echo ""

          TOTAL_TESTS=7
          IMPLEMENTED_TESTS=0
          MISSING_TESTS=()

          # Test 1: Unit Tests (Jest/Go)
          echo "1Ô∏è‚É£ Unit Testing (Components/Utilities)"
          if [ -d "$MODULE_PATH/frontend" ] || [ -d "$MODULE_PATH/upstream/frontend" ]; then
            FRONTEND_PATH="$MODULE_PATH/frontend"
            [ -d "$MODULE_PATH/upstream/frontend" ] && FRONTEND_PATH="$MODULE_PATH/upstream/frontend"

            if [ -f "$FRONTEND_PATH/package.json" ] && (grep -qE '"test.*jest|jest.*test"' "$FRONTEND_PATH/package.json" || grep -q '"test:unit"' "$FRONTEND_PATH/package.json"); then
              echo "   ‚úÖ Frontend Unit Tests - IMPLEMENTED (Jest)"
              IMPLEMENTED_TESTS=$((IMPLEMENTED_TESTS + 1))
            else
              echo "   ‚ùå Frontend Unit Tests - MISSING"
              MISSING_TESTS+=("Unit Tests (Jest for components/utilities)")
            fi
          fi

          # Test 2: Mock Testing (Clusterless)
          echo "2Ô∏è‚É£ Mock Testing (Clusterless/BFF Mocking)"
          MOCK_FOUND=false

          if [ -d "$MODULE_PATH/frontend" ] || [ -d "$MODULE_PATH/upstream/frontend" ]; then
            FRONTEND_PATH="$MODULE_PATH/frontend"
            [ -d "$MODULE_PATH/upstream/frontend" ] && FRONTEND_PATH="$MODULE_PATH/upstream/frontend"

            # Check module-specific mock tests
            if [ -f "$FRONTEND_PATH/package.json" ] && grep -qE 'cypress.*mock|mock.*cypress' "$FRONTEND_PATH/package.json"; then
              MOCK_FOUND=true
            elif [ -n "$(find "$MODULE_PATH" -path "*/cypress/*" -name "*.cy.*" -exec grep -lE "mock|stub|intercept" {} \; 2>/dev/null | head -1)" ]; then
              MOCK_FOUND=true
            fi
          fi

          # Check main dashboard mocked tests for this module
          MODULE_NAME=$(basename "$MODULE_PATH")
          if [ -d "frontend/src/__tests__/cypress/cypress/tests/mocked/$MODULE_NAME" ] || [ -d "frontend/src/__tests__/cypress/cypress/tests/mocked/$(echo $MODULE_NAME | sed 's/-//g')" ]; then
            MOCK_FOUND=true
          fi

          if [ "$MOCK_FOUND" = true ]; then
            echo "   ‚úÖ Mock Tests - IMPLEMENTED (Cypress with mocked BFF)"
            # Show where tests were found for transparency
            if [ -n "$(find "$MODULE_PATH" -path "*/cypress/*" -name "*.cy.*" -exec grep -lE "mock|stub|intercept" {} \; 2>/dev/null | head -1)" ]; then
              echo "   üìÅ Found in: Module-specific cypress tests"
            fi
            if [ -d "frontend/src/__tests__/cypress/cypress/tests/mocked/$MODULE_NAME" ]; then
              echo "   üìÅ Found in: frontend/src/__tests__/cypress/cypress/tests/mocked/$MODULE_NAME/"
            elif [ -d "frontend/src/__tests__/cypress/cypress/tests/mocked/$(echo $MODULE_NAME | sed 's/-//g')" ]; then
              echo "   üìÅ Found in: frontend/src/__tests__/cypress/cypress/tests/mocked/$(echo $MODULE_NAME | sed 's/-//g')/"
            fi
            IMPLEMENTED_TESTS=$((IMPLEMENTED_TESTS + 1))
          else
            echo "   ‚ùå Mock Tests - MISSING"
            MISSING_TESTS+=("Mock Tests (Cypress with mocked BFF)")
          fi

          # Test 3: Integration Testing (E2E workflows like Model Registry)
          echo "3Ô∏è‚É£ Integration Testing (E2E User Workflows)"
          E2E_FOUND=false

          # Check module-specific cypress tests
          if [ -n "$(find "$MODULE_PATH" -path "*/cypress/*" -name "*.cy.*" 2>/dev/null | head -1)" ]; then
            if [ -n "$(find "$MODULE_PATH" -path "*/cypress/*" -name "*.cy.*" -exec grep -lE "step|visit.*\(|click\(\)|type\(|should\(" {} \; 2>/dev/null | head -1)" ]; then
              E2E_FOUND=true
            fi
          fi

          # Check main dashboard e2e tests for this module
          MODULE_NAME=$(basename "$MODULE_PATH")
          if [ -d "frontend/src/__tests__/cypress/cypress/tests/e2e/$MODULE_NAME" ] || [ -d "frontend/src/__tests__/cypress/cypress/tests/e2e/$(echo $MODULE_NAME | sed 's/-//g')" ]; then
            E2E_FOUND=true
          fi

          if [ "$E2E_FOUND" = true ]; then
            echo "   ‚úÖ E2E Integration Tests - IMPLEMENTED (Comprehensive workflows)"
            # Show where tests were found for transparency
            if [ -n "$(find "$MODULE_PATH" -path "*/cypress/*" -name "*.cy.*" 2>/dev/null | head -1)" ]; then
              echo "   üìÅ Found in: Module-specific cypress tests"
            fi
            if [ -d "frontend/src/__tests__/cypress/cypress/tests/e2e/$MODULE_NAME" ]; then
              echo "   üìÅ Found in: frontend/src/__tests__/cypress/cypress/tests/e2e/$MODULE_NAME/"
            elif [ -d "frontend/src/__tests__/cypress/cypress/tests/e2e/$(echo $MODULE_NAME | sed 's/-//g')" ]; then
              echo "   üìÅ Found in: frontend/src/__tests__/cypress/cypress/tests/e2e/$(echo $MODULE_NAME | sed 's/-//g')/"
            fi
            IMPLEMENTED_TESTS=$((IMPLEMENTED_TESTS + 1))
          else
            echo "   ‚ùå E2E Integration Tests - MISSING"
            MISSING_TESTS+=("E2E Integration Tests (Cypress user workflows)")
          fi

          # Test 4: API Functional Testing (BFF)
          echo "4Ô∏è‚É£ API Functional Testing (BFF Endpoints)"
          if [ -d "$MODULE_PATH/bff" ] || [ -d "$MODULE_PATH/upstream/bff" ]; then
            BFF_PATH="$MODULE_PATH/bff"
            [ -d "$MODULE_PATH/upstream/bff" ] && BFF_PATH="$MODULE_PATH/upstream/bff"

            if [ -n "$(find "$BFF_PATH" -name "*_test.go" 2>/dev/null | head -1)" ]; then
              echo "   ‚úÖ API Functional Tests - IMPLEMENTED (Go tests)"
              IMPLEMENTED_TESTS=$((IMPLEMENTED_TESTS + 1))
            elif [ -f "$BFF_PATH/Makefile" ] && grep -q "^test:" "$BFF_PATH/Makefile"; then
              echo "   ‚úÖ API Functional Tests - IMPLEMENTED (Makefile test target)"
              IMPLEMENTED_TESTS=$((IMPLEMENTED_TESTS + 1))
            else
              echo "   ‚ùå API Functional Tests - MISSING"
              MISSING_TESTS+=("API Functional Tests (Go BFF endpoint tests)")
            fi
          else
            echo "   ‚ö†Ô∏è  API Functional Tests - NO BFF DETECTED"
            TOTAL_TESTS=6  # Adjust total if no BFF
          fi

          # Test 5: API Contract Testing (Pact)
          echo "5Ô∏è‚É£ API Contract Testing (Consumer-Driven)"
          if [ -n "$(find "$MODULE_PATH" -name "*.pact.js" -o -name "*.pact.ts" -o -name "pact.json" 2>/dev/null | head -1)" ]; then
            echo "   ‚úÖ API Contract Tests - IMPLEMENTED (Pact)"
            IMPLEMENTED_TESTS=$((IMPLEMENTED_TESTS + 1))
          elif [ -n "${BFF_PATH:-}" ] && [ -n "$(find "${BFF_PATH:-$MODULE_PATH}" -name "*_contract_test.go" -o -name "contract_test.go" 2>/dev/null | head -1)" ]; then
            echo "   ‚úÖ API Contract Tests - IMPLEMENTED (Go contract tests)"
            IMPLEMENTED_TESTS=$((IMPLEMENTED_TESTS + 1))
          else
            echo "   ‚ùå API Contract Tests - MISSING"
            MISSING_TESTS+=("API Contract Tests (Pact consumer-driven)")
          fi

          # Test 6: API Performance Testing (K6/JMeter/Taurus)
          echo "6Ô∏è‚É£ API Performance Testing (Load/Stress)"
          if [ -n "$(find "$MODULE_PATH" -name "*.k6.js" -o -name "*.k6.ts" -o -name "load-test.*" -o -name "*.jmx" 2>/dev/null | head -1)" ]; then
            echo "   ‚úÖ API Performance Tests - IMPLEMENTED"
            IMPLEMENTED_TESTS=$((IMPLEMENTED_TESTS + 1))
          elif [ -n "${BFF_PATH:-}" ] && [ -n "$(find "${BFF_PATH:-$MODULE_PATH}" -name "*_benchmark_test.go" -o -name "benchmark_test.go" 2>/dev/null | head -1)" ]; then
            echo "   ‚úÖ API Performance Tests - IMPLEMENTED (Go benchmarks)"
            IMPLEMENTED_TESTS=$((IMPLEMENTED_TESTS + 1))
          else
            echo "   ‚ùå API Performance Tests - MISSING"
            MISSING_TESTS+=("API Performance Tests (K6/JMeter/Taurus)")
          fi

          # Test 7: Bundle Size/Performance Budget
          echo "7Ô∏è‚É£ Bundle Size Monitoring (Performance Budget)"
          FRONTEND_PATH="$MODULE_PATH/frontend"
          [ -d "$MODULE_PATH/upstream/frontend" ] && FRONTEND_PATH="$MODULE_PATH/upstream/frontend"

          if [ -f "$FRONTEND_PATH/package.json" ] && grep -qE 'bundlesize|size-limit|bundlewatch' "$FRONTEND_PATH/package.json"; then
            echo "   ‚úÖ Bundle Size Monitoring - IMPLEMENTED"
            IMPLEMENTED_TESTS=$((IMPLEMENTED_TESTS + 1))
          elif [ -n "$(find "$MODULE_PATH" -name "webpack*.js" -exec grep -lE "performance|BundleAnalyzer" {} \; 2>/dev/null | head -1)" ]; then
            echo "   ‚úÖ Bundle Size Monitoring - IMPLEMENTED (Webpack analysis)"
            IMPLEMENTED_TESTS=$((IMPLEMENTED_TESTS + 1))
          else
            echo "   ‚ùå Bundle Size Monitoring - MISSING"
            MISSING_TESTS+=("Bundle Size Monitoring (size-limit/bundlewatch)")
          fi

          # Calculate testing completeness
          COMPLETENESS=$((IMPLEMENTED_TESTS * 100 / TOTAL_TESTS))

          # Calculate specific API and UI testing scores for RHOAI readiness
          API_TESTING_READY="false"
          UI_TESTING_READY="false"
          RHOAI_READY="false"

          # Check API Testing readiness (BFF + Performance + Contract)
          API_TESTS_FOUND=0
          if [ -d "$MODULE_PATH/bff" ] && [ -n "$(find "$MODULE_PATH/bff" -name "*_test.go" 2>/dev/null | head -1)" ]; then
            API_TESTS_FOUND=$((API_TESTS_FOUND + 1))
          fi
          if [ -n "$(find "$MODULE_PATH" -name "*.k6.js" -o -name "*.k6.ts" -o -name "load-test.*" -o -name "*.jmx" 2>/dev/null | head -1)" ]; then
            API_TESTS_FOUND=$((API_TESTS_FOUND + 1))
          fi
          if [ -n "$(find "$MODULE_PATH" -name "*.pact.js" -o -name "*.pact.ts" -o -name "pact.json" 2>/dev/null | head -1)" ]; then
            API_TESTS_FOUND=$((API_TESTS_FOUND + 1))
          fi

          if [ "$API_TESTS_FOUND" -ge 2 ]; then
            API_TESTING_READY="true"
          fi

          # Check UI Testing readiness (Unit + Integration + Mock)
          UI_TESTS_FOUND=0
          FRONTEND_PATH="$MODULE_PATH/frontend"
          [ -d "$MODULE_PATH/upstream/frontend" ] && FRONTEND_PATH="$MODULE_PATH/upstream/frontend"
          MODULE_NAME=$(basename "$MODULE_PATH")

          # Unit tests
          if [ -f "$FRONTEND_PATH/package.json" ] && grep -qE '"test.*jest|jest.*test"' "$FRONTEND_PATH/package.json"; then
            UI_TESTS_FOUND=$((UI_TESTS_FOUND + 1))
          fi

          # Integration tests (module-specific + main dashboard)
          if [ -n "$(find "$MODULE_PATH" -path "*/cypress/*" -name "*.cy.*" -exec grep -lE "step|visit.*\(|click\(\)|type\(|should\(" {} \; 2>/dev/null | head -1)" ]; then
            UI_TESTS_FOUND=$((UI_TESTS_FOUND + 1))
          elif [ -d "frontend/src/__tests__/cypress/cypress/tests/e2e/$MODULE_NAME" ] || [ -d "frontend/src/__tests__/cypress/cypress/tests/e2e/$(echo $MODULE_NAME | sed 's/-//g')" ]; then
            UI_TESTS_FOUND=$((UI_TESTS_FOUND + 1))
          fi

          # Mock tests (module-specific + main dashboard)
          if [ -n "$(find "$MODULE_PATH" -path "*/cypress/*" -name "*.cy.*" -exec grep -lE "mock|stub|intercept" {} \; 2>/dev/null | head -1)" ]; then
            UI_TESTS_FOUND=$((UI_TESTS_FOUND + 1))
          elif [ -d "frontend/src/__tests__/cypress/cypress/tests/mocked/$MODULE_NAME" ] || [ -d "frontend/src/__tests__/cypress/cypress/tests/mocked/$(echo $MODULE_NAME | sed 's/-//g')" ]; then
            UI_TESTS_FOUND=$((UI_TESTS_FOUND + 1))
          fi

          if [ "$UI_TESTS_FOUND" -ge 2 ]; then
            UI_TESTING_READY="true"
          fi

          # RHOAI readiness assessment
          if [ "$API_TESTING_READY" = "true" ] && [ "$UI_TESTING_READY" = "true" ] && [ "$COMPLETENESS" -ge 75 ]; then
            RHOAI_READY="true"
          fi

          echo ""
          echo "üìä Testing Maturity Summary:"
          echo "   Implemented: $IMPLEMENTED_TESTS/$TOTAL_TESTS tests ($COMPLETENESS%)"
          echo ""
          echo "üéØ Platform Readiness Assessment:"
          echo "   üìç ODH (Upstream): ‚úÖ Ready at any maturity level"
          if [ "$RHOAI_READY" = "true" ]; then
            echo "   üìç RHOAI (Enterprise): ‚úÖ Ready for enablement"
            echo "     - API Testing: ‚úÖ ($API_TESTS_FOUND/3 categories)"
            echo "     - UI Testing: ‚úÖ ($UI_TESTS_FOUND/3 categories)"
            echo "     - Overall Coverage: ‚úÖ ($COMPLETENESS% ‚â• 75%)"
          else
            echo "   üìç RHOAI (Enterprise): ‚ùå NOT READY - Quality standards not met"
            echo "     - API Testing: $([ "$API_TESTING_READY" = "true" ] && echo "‚úÖ" || echo "‚ùå") ($API_TESTS_FOUND/3 categories) $([ "$API_TESTING_READY" = "false" ] && echo "- Need 2+ of: BFF tests, Performance, Contract")"
            echo "     - UI Testing: $([ "$UI_TESTING_READY" = "true" ] && echo "‚úÖ" || echo "‚ùå") ($UI_TESTS_FOUND/3 categories) $([ "$UI_TESTING_READY" = "false" ] && echo "- Need 2+ of: Unit, E2E, Mock")"
            echo "     - Overall Coverage: $([ "$COMPLETENESS" -ge 75 ] && echo "‚úÖ" || echo "‚ùå") ($COMPLETENESS% - Need ‚â•75%)"
            echo ""
            echo "   üö´ DO NOT ENABLE IN RHOAI until these requirements are met!"
          fi

          # Set outputs
          echo "completeness=$COMPLETENESS" >> $GITHUB_OUTPUT
          echo "implemented=$IMPLEMENTED_TESTS" >> $GITHUB_OUTPUT
          echo "total=$TOTAL_TESTS" >> $GITHUB_OUTPUT

          # Don't fail the gate initially - just report
          if [ $COMPLETENESS -lt 50 ]; then
            echo ""
            echo "‚ö†Ô∏è  Application Quality Gate: LOW MATURITY ($COMPLETENESS%)"
            echo "   Consider improving test coverage for better quality assurance"
          elif [ $COMPLETENESS -lt 75 ]; then
            echo ""
            echo "‚úÖ Application Quality Gate: MODERATE MATURITY ($COMPLETENESS%)"
            echo "   Good progress! Consider completing remaining test types"
          else
            echo ""
            echo "‚úÖ Application Quality Gate: HIGH MATURITY ($COMPLETENESS%)"
            echo "   Excellent testing coverage across all levels!"
          fi

      - name: üß™ Run Available Tests with Coverage
        id: coverage-check
        run: |
          MODULE_PATH="frontend/packages/${{ matrix.module }}"
          HAS_COVERAGE=false

          # Skip actual testing in silent mode but still set output
          if [ "${{ steps.check-config.outputs.silent_mode }}" = "true" ]; then
            echo "üîï Skipping coverage tests in silent mode"
            echo "has-coverage=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Run frontend tests with coverage
          if [ -d "$MODULE_PATH/frontend" ]; then
            cd "$MODULE_PATH/frontend"

            if [ -f "package.json" ]; then
              npm ci

              # Run unit tests with coverage
              if grep -q '"test:coverage"' package.json; then
                echo "üß™ Running unit tests with coverage..."
                npm run test:coverage
                HAS_COVERAGE=true

                # Create coverage directory for upload
                mkdir -p "$GITHUB_WORKSPACE/coverage"
                if [ -f "coverage/coverage-final.json" ]; then
                  cp coverage/coverage-final.json "$GITHUB_WORKSPACE/coverage/${{ matrix.module }}-unit-coverage.json"
                fi
              elif grep -q '"test:unit"' package.json; then
                echo "üß™ Running unit tests..."
                npm run test:unit
              fi

              # Run cypress tests if available
              if grep -q '"test:cypress"' package.json; then
                echo "üß™ Running Cypress tests..."
                # Note: In a real scenario, you'd want to start the BFF first
                npm run test:cypress-ci || echo "‚ö†Ô∏è Cypress tests failed or not properly configured"
              fi
            fi

            cd - > /dev/null
          fi

          # Run BFF tests
          if [ -d "$MODULE_PATH/bff" ]; then
            cd "$MODULE_PATH/bff"

            if [ -f "Makefile" ] && grep -q "^test:" Makefile; then
              echo "üß™ Running BFF tests..."
              make test
            fi

            cd - > /dev/null
          fi

          echo "has-coverage=$HAS_COVERAGE" >> $GITHUB_OUTPUT

      - name: Upload Coverage Results
        if: steps.coverage-check.outputs.has-coverage == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.module }}
          path: coverage/

  # Quality Gate 2: Deployment Quality Gate
  deployment-quality-gate:
    name: Deployment Quality Gate
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    strategy:
      fail-fast: false
      matrix:
        module: ${{ fromJson(needs.detect-changes.outputs.modules-matrix) }}
    steps:
      - uses: actions/checkout@v4

      - name: üîç Check Quality Gates Configuration
        id: check-config
        run: |
          MODULE_PATH="frontend/packages/${{ matrix.module }}"

          # Check if quality gate notifications should be silenced for this module
          SILENT_MODE="false"
          SILENT_REASON=""

          # Check for .quality-gates-config.yml
          if [ -f ".quality-gates-config.yml" ]; then
            if grep -q "^  ${{ matrix.module }}:" .quality-gates-config.yml; then
              STATUS=$(grep -A1 "^  ${{ matrix.module }}:" .quality-gates-config.yml | grep "status:" | awk '{print $2}' | tr -d '"')
              if [ "$STATUS" = "silent" ]; then
                SILENT_MODE="true"
                REASON=$(grep -A2 "^  ${{ matrix.module }}:" .quality-gates-config.yml | grep "reason:" | cut -d'"' -f2)
                SILENT_REASON="${REASON:-Quality gate notifications silenced}"
              fi
            fi
          fi

          echo "silent_mode=$SILENT_MODE" >> $GITHUB_OUTPUT
          echo "silent_reason=$SILENT_REASON" >> $GITHUB_OUTPUT

          if [ "$SILENT_MODE" = "true" ]; then
            echo "üîï Quality Gate Notifications SILENCED for ${{ matrix.module }}"
            echo "üìã Reason: $SILENT_REASON"
            echo ""
            echo "‚ÑπÔ∏è  Quality checks may still run in background for metrics"
            echo "‚ÑπÔ∏è  To restore notifications, update .quality-gates-config.yml"
          else
            echo "üîç Running quality gates with full notifications for ${{ matrix.module }}"
          fi

      - name: üöÄ Deployment Readiness Assessment
        if: steps.check-config.outputs.silent_mode != 'true'
        id: deployment-assessment
        run: |
          MODULE_PATH="frontend/packages/${{ matrix.module }}"
          echo "üöÄ Assessing deployment readiness for: ${{ matrix.module }}"
          echo "Based on Model Registry ODH enablement patterns (PR #4540)"
          echo "üìç Model Registry Status: ‚úÖ ODH (Enabled) | ‚è≥ RHOAI (Planned)"
          echo ""

          TOTAL_CHECKS=4
          IMPLEMENTED_CHECKS=0
          MISSING_CHECKS=()

          # Check 1: Dockerfile for container deployment
          if [ -f "$MODULE_PATH/Dockerfile" ]; then
            echo "‚úÖ Dockerfile - PRESENT"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))

            # Validate Dockerfile best practices
            if grep -q "FROM.*node.*AS.*builder" "$MODULE_PATH/Dockerfile" && grep -q "FROM.*golang.*AS.*builder" "$MODULE_PATH/Dockerfile"; then
              echo "   ‚úÖ Multi-stage build detected (Node.js + Go)"
            elif grep -q "FROM.*node" "$MODULE_PATH/Dockerfile"; then
              echo "   ‚úÖ Node.js build stage detected"
            else
              echo "   ‚ö†Ô∏è  Consider using multi-stage build for optimization"
            fi

            if grep -q "USER.*65532" "$MODULE_PATH/Dockerfile" || grep -q "USER.*nonroot" "$MODULE_PATH/Dockerfile"; then
              echo "   ‚úÖ Non-root user configuration found"
            else
              echo "   ‚ö†Ô∏è  Consider adding non-root user for security"
            fi

            if grep -q "EXPOSE" "$MODULE_PATH/Dockerfile"; then
              echo "   ‚úÖ Port exposure documented"
            else
              echo "   ‚ö†Ô∏è  Consider documenting exposed ports"
            fi
          else
            echo "‚ùå Dockerfile - MISSING"
            echo "   Required for containerized deployment in ODH/RHOAI"
            MISSING_CHECKS+=("Dockerfile (multi-stage build recommended)")
          fi

          # Check 2: Module Federation configuration
          if [ -f "$MODULE_PATH/package.json" ] && grep -q '"module-federation"' "$MODULE_PATH/package.json"; then
            echo "‚úÖ Module Federation Config - PRESENT"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))

            # Validate federation config
            if grep -A 20 '"module-federation"' "$MODULE_PATH/package.json" | grep -q '"remoteEntry"'; then
              echo "   ‚úÖ Remote entry configured"
            fi

            if grep -A 20 '"module-federation"' "$MODULE_PATH/package.json" | grep -q '"proxy"'; then
              echo "   ‚úÖ API proxy configuration found"
            fi

            if grep -A 20 '"module-federation"' "$MODULE_PATH/package.json" | grep -q '"authorize"'; then
              echo "   ‚úÖ Authorization setting configured"
            fi
          else
            echo "‚ùå Module Federation Config - MISSING"
            echo "   Required for federated deployment in ODH Dashboard"
            MISSING_CHECKS+=("Module Federation configuration in package.json")
          fi

          # Check 3: ODH Manifest compatibility
          ODH_MANIFEST_READY=false
          if [ -f "$MODULE_PATH/upstream/Makefile" ]; then
            if grep -q "build.*prod" "$MODULE_PATH/upstream/Makefile" || grep -q "build:prod" "$MODULE_PATH/upstream/Makefile"; then
              echo "‚úÖ Production Build Support - PRESENT"
              IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
              ODH_MANIFEST_READY=true
            fi
          elif [ -f "$MODULE_PATH/frontend/package.json" ] && grep -q '"build"' "$MODULE_PATH/frontend/package.json"; then
            echo "‚úÖ Production Build Support - PRESENT"
            IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
            ODH_MANIFEST_READY=true
          fi

          if [ "$ODH_MANIFEST_READY" = false ]; then
            echo "‚ùå Production Build Support - MISSING"
            echo "   Required for ODH/RHOAI manifest integration"
            MISSING_CHECKS+=("Production build scripts")
          fi

          # Check 4: Health check endpoint (for BFF)
          if [ -d "$MODULE_PATH/bff" ] || [ -d "$MODULE_PATH/upstream/bff" ]; then
            BFF_PATH="$MODULE_PATH/bff"
            [ -d "$MODULE_PATH/upstream/bff" ] && BFF_PATH="$MODULE_PATH/upstream/bff"

            if [ -n "$(find "$BFF_PATH" -name "*.go" -exec grep -lE "health|/health|healthcheck" {} \; 2>/dev/null | head -1)" ]; then
              echo "‚úÖ Health Check Endpoint - PRESENT"
              IMPLEMENTED_CHECKS=$((IMPLEMENTED_CHECKS + 1))
            else
              echo "‚ùå Health Check Endpoint - MISSING"
              echo "   Required for Kubernetes readiness/liveness probes"
              MISSING_CHECKS+=("Health check endpoint (/api/health)")
            fi
          else
            echo "‚ö†Ô∏è  Health Check Endpoint - NO BFF DETECTED"
            TOTAL_CHECKS=3  # Adjust total if no BFF
          fi

          # Calculate deployment readiness
          READINESS=$((IMPLEMENTED_CHECKS * 100 / TOTAL_CHECKS))

          echo ""
          echo "üìä Deployment Readiness Summary:"
          echo "   Ready: $IMPLEMENTED_CHECKS/$TOTAL_CHECKS checks ($READINESS%)"

          if [ ${#MISSING_CHECKS[@]} -gt 0 ]; then
            echo ""
            echo "üö® Missing Deployment Requirements:"
            for missing in "${MISSING_CHECKS[@]}"; do
              echo "   - $missing"
            done
            echo ""
            echo "üìñ Deployment Recommendations:"
            echo "   1. Add multi-stage Dockerfile (see model-registry example)"
            echo "   2. Configure module federation in package.json"
            echo "   3. Ensure production build scripts are available"
            echo "   4. Add health check endpoint for BFF (/api/health)"
            echo "   5. Reference PR #4540 for ODH enablement patterns"
          fi

          # Set outputs
          echo "readiness=$READINESS" >> $GITHUB_OUTPUT
          echo "implemented=$IMPLEMENTED_CHECKS" >> $GITHUB_OUTPUT
          echo "total=$TOTAL_CHECKS" >> $GITHUB_OUTPUT

          # Assessment levels (not blocking)
          if [ $READINESS -lt 50 ]; then
            echo ""
            echo "‚ö†Ô∏è  Deployment Quality Gate: LOW READINESS ($READINESS%)"
            echo "   Not ready for ODH/RHOAI deployment"
          elif [ $READINESS -lt 75 ]; then
            echo ""
            echo "‚úÖ Deployment Quality Gate: MODERATE READINESS ($READINESS%)"
            echo "   Good foundation! Complete remaining items for full deployment"
          else
            echo ""
            echo "‚úÖ Deployment Quality Gate: HIGH READINESS ($READINESS%)"
            echo "   Ready for ODH/RHOAI integration!"
          fi

      - name: üê≥ Container Security & Standards Check
        run: |
          MODULE_PATH="frontend/packages/${{ matrix.module }}"

          if [ -f "$MODULE_PATH/Dockerfile" ]; then
            echo "üê≥ Analyzing container security and standards..."

            # Check for security best practices
            if grep -q "FROM.*distroless" "$MODULE_PATH/Dockerfile"; then
              echo "‚úÖ Distroless base image - excellent security"
            elif grep -q "FROM.*alpine" "$MODULE_PATH/Dockerfile"; then
              echo "‚úÖ Alpine base image - good security"
            else
              echo "‚ö†Ô∏è  Consider using distroless or alpine for better security"
            fi

            # Check for EXPOSE documentation
            if grep -q "EXPOSE" "$MODULE_PATH/Dockerfile"; then
              EXPOSED_PORT=$(grep "EXPOSE" "$MODULE_PATH/Dockerfile" | awk '{print $2}')
              echo "‚úÖ Port $EXPOSED_PORT documented"
            fi

            # Check for proper layering
            if grep -q "COPY.*--from=" "$MODULE_PATH/Dockerfile"; then
              echo "‚úÖ Multi-stage copy optimization detected"
            fi

            # Check for health check
            if grep -q "HEALTHCHECK" "$MODULE_PATH/Dockerfile"; then
              echo "‚úÖ Health check defined in Dockerfile"
            else
              echo "‚ÑπÔ∏è  Consider adding HEALTHCHECK instruction (optional)"
            fi
          else
            echo "‚ÑπÔ∏è  No Dockerfile found - skipping container analysis"
          fi

  # Combine coverage and upload to Codecov (similar to existing test.yml)
  combine-coverage:
    name: Combine Coverage & Upload
    runs-on: ubuntu-latest
    needs: [application-quality-gate]
    if: always() && needs.application-quality-gate.result != 'skipped'
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Download coverage artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-coverage
          pattern: coverage-*

      - name: Combine coverage reports
        run: |
          if [ -d "all-coverage" ] && [ "$(ls -A all-coverage)" ]; then
            echo "üìä Combining coverage reports..."
            npm install nyc --no-save

            mkdir -p ./combined-coverage

            # Find and combine all coverage files
            find all-coverage -name "*-coverage.json" -type f | while read file; do
              module=$(basename "$file" | sed 's/-coverage.json//')
              cp "$file" "./combined-coverage/${module}-coverage.json"
            done

            if [ "$(ls -A ./combined-coverage)" ]; then
              npx nyc merge ./combined-coverage ./combined-coverage/merged-coverage.json
              echo "üìä Coverage files merged successfully"
            else
              echo "‚ö†Ô∏è No coverage files found to combine"
            fi
          else
            echo "‚ö†Ô∏è No coverage artifacts found"
          fi

      - name: Upload to Codecov
        if: hashFiles('./combined-coverage/merged-coverage.json') != ''
        uses: codecov/codecov-action@v4
        with:
          files: ./combined-coverage/merged-coverage.json
          flags: modular-arch
          token: ${{ secrets.CODECOV_TOKEN }}

  quality-gates-summary:
    name: Quality Gates Summary
    runs-on: ubuntu-latest
    needs: [detect-changes, code-quality-gate, application-quality-gate, deployment-quality-gate, combine-coverage]
    if: always() && needs.detect-changes.outputs.has-changes == 'true'
    steps:
      - name: Generate Quality Report
        run: |
          echo "# üö¶ Modular Architecture Quality Gates Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Code Quality Gate Status (with BIG WARNING if failed)
          if [ "${{ needs.code-quality-gate.result }}" != "success" ]; then
            echo "## üö® CODE QUALITY GATE: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ‚õî DO NOT ENABLE THIS MODULE IN DEPLOYMENT ‚õî" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**MODULE DOES NOT MEET ARCHITECTURE STANDARDS**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üö´ **Platform Team:** DO NOT add to federation-configmap.yaml" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üõ†Ô∏è **Development Team:** Fix quality issues to enable module" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚úÖ Code Quality Gate: PASSED" >> $GITHUB_STEP_SUMMARY
            echo "- Module can be ENABLED in deployment manifests" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY

          # Application Quality Gate Status
          if [ "${{ needs.application-quality-gate.result }}" == "success" ]; then
            echo "## ‚úÖ Application Quality Gate: COMPLETED" >> $GITHUB_STEP_SUMMARY
            echo "- Testing maturity assessed" >> $GITHUB_STEP_SUMMARY
            echo "- Available tests executed successfully" >> $GITHUB_STEP_SUMMARY

            # Add RHOAI readiness status to summary
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üéØ Platform Readiness:" >> $GITHUB_STEP_SUMMARY
            echo "- **ODH (Upstream)**: ‚úÖ Ready at any maturity level" >> $GITHUB_STEP_SUMMARY

            # Note: In a real implementation, we'd pass the RHOAI status from the job
            # For now, showing the pattern - this would be dynamic based on actual assessment
            echo "- **RHOAI (Enterprise)**: Check job logs for detailed readiness assessment" >> $GITHUB_STEP_SUMMARY
            echo "  - Requires: 75% coverage + API/UI testing standards" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚ö†Ô∏è Application Quality Gate: NEEDS ATTENTION" >> $GITHUB_STEP_SUMMARY
            echo "- Consider implementing missing test types" >> $GITHUB_STEP_SUMMARY
            echo "- See job output for specific recommendations" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üéØ Platform Readiness:" >> $GITHUB_STEP_SUMMARY
            echo "- **ODH (Upstream)**: ‚úÖ Ready at any maturity level" >> $GITHUB_STEP_SUMMARY
            echo "- **RHOAI (Enterprise)**: ‚ùå Not ready - Quality standards not met" >> $GITHUB_STEP_SUMMARY
            echo "  - **Required**: 75% test coverage + API/UI testing standards" >> $GITHUB_STEP_SUMMARY
            echo "  - **Action**: Implement missing test categories before RHOAI enablement" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY

          # Deployment Quality Gate Status
          if [ "${{ needs.deployment-quality-gate.result }}" == "success" ]; then
            echo "## ‚úÖ Deployment Quality Gate: COMPLETED" >> $GITHUB_STEP_SUMMARY
            echo "- Deployment readiness assessed" >> $GITHUB_STEP_SUMMARY
            echo "- Container and ODH integration requirements checked" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚ö†Ô∏è Deployment Quality Gate: NEEDS ATTENTION" >> $GITHUB_STEP_SUMMARY
            echo "- Complete deployment requirements for ODH/RHOAI enablement" >> $GITHUB_STEP_SUMMARY
            echo "- Reference Model Registry example (PR #4540)" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìö Resources" >> $GITHUB_STEP_SUMMARY
          echo "- [Modular Architecture Guide](https://github.com/opendatahub-io/mod-arch-shared-library)" >> $GITHUB_STEP_SUMMARY
          echo "- [Testing Strategy (Miro Board)](https://miro.com/app/board/uXjVJYjWx4I=/)" >> $GITHUB_STEP_SUMMARY

          # Code Quality Gate determines module deployment status (not PR blocking)
          if [ "${{ needs.code-quality-gate.result }}" != "success" ]; then
            echo ""
            echo "üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®"
            echo "üö®                                                        üö®"
            echo "üö®    ‚õî DO NOT ENABLE THIS MODULE IN DEPLOYMENT ‚õî     üö®"
            echo "üö®                                                        üö®"
            echo "üö®         CODE QUALITY GATE FAILED - MODULE            üö®"
            echo "üö®         DOES NOT MEET ARCHITECTURE STANDARDS         üö®"
            echo "üö®                                                        üö®"
            echo "üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®"
            echo ""
            echo "‚ùå Code Quality Gate FAILED - Module must be TOGGLED OFF"
            echo ""
            echo "üö´ PLATFORM TEAM ACTION REQUIRED:"
            echo "   ‚ùå DO NOT add this module to federation-configmap.yaml"
            echo "   ‚ùå DO NOT add container to deployment.yaml"
            echo "   ‚ùå DO NOT add image to kustomization.yaml"
            echo ""
            echo "üõ†Ô∏è  DEVELOPMENT TEAM - Fix these issues to enable module:"
            echo "   ‚ùå Add mod-arch-shared dependency"
            echo "   ‚ùå Ensure ModularArchContextProvider usage"
            echo "   ‚ùå Fix any missing architectural requirements"
            echo ""
            echo "‚úÖ PR can still merge - but module MUST remain disabled until fixed"
            echo ""
            echo "üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®"
            # Note: Don't exit 1 - allow PR to merge but module stays toggled off
          else
            echo "‚úÖ Code Quality Gate passed - Module can be ENABLED in deployment"
          fi

      - name: Generate Quality Gates Summary
        id: generate-summary
        run: |
          # Build comprehensive quality gates summary
          SUMMARY_FILE="quality-gates-summary.md"
          
          # Compute stats
          CODE_PASS=$([ "${{ needs.code-quality-gate.result }}" == "success" ] && echo 1 || echo 0)
          APP_PASS=$([ "${{ needs.application-quality-gate.result }}" == "success" ] && echo 1 || echo 0)
          DEP_PASS=$([ "${{ needs.deployment-quality-gate.result }}" == "success" ] && echo 1 || echo 0)
          TOTAL=$((3))
          PASSED=$((CODE_PASS + APP_PASS + DEP_PASS))
          FAILED=$((TOTAL - PASSED))

          echo "## üö¶ Modular Architecture Quality Gates Results" > $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "**Summary:** ${PASSED}/${TOTAL} gates passed (${FAILED} failed)" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE

          # Code Quality Gate
          if [ "${{ needs.code-quality-gate.result }}" != "success" ]; then
            cat >> $SUMMARY_FILE << 'EOF'
          ### üö® Code Quality Gate: FAILED

          **‚õî MODULE MUST BE TOGGLED OFF ‚õî**

          - Module does not meet architectural standards
          - Cannot be enabled in deployment until fixed
          - Fix mod-arch-shared dependency and other quality issues

          EOF
          else
            cat >> $SUMMARY_FILE << 'EOF'
          ### ‚úÖ Code Quality Gate: PASSED

          - Module meets architectural standards
          - Ready for deployment enablement

          EOF
          fi

          # Application Quality Gate
          if [ "${{ needs.application-quality-gate.result }}" == "success" ]; then
            cat >> $SUMMARY_FILE << 'EOF'
          ### ‚úÖ Application Quality Gate: COMPLETED

          - Testing maturity assessed
          - Available tests executed successfully
          - Check detailed output for RHOAI readiness

          EOF
          else
            cat >> $SUMMARY_FILE << 'EOF'
          ### ‚ö†Ô∏è Application Quality Gate: NEEDS ATTENTION

          - Consider implementing missing test types
          - RHOAI requires 75% coverage + API/UI testing standards
          - See job logs for specific recommendations

          EOF
          fi

          # Deployment Quality Gate
          if [ "${{ needs.deployment-quality-gate.result }}" == "success" ]; then
            cat >> $SUMMARY_FILE << 'EOF'
          ### ‚úÖ Deployment Quality Gate: COMPLETED

          - Deployment readiness assessed
          - Container and ODH integration requirements checked

          EOF
          else
            cat >> $SUMMARY_FILE << 'EOF'
          ### ‚ö†Ô∏è Deployment Quality Gate: NEEDS ATTENTION

          - Complete deployment requirements for ODH/RHOAI
          - Reference Model Registry example (PR #4540)

          EOF
          fi

          # Add resources
          cat >> $SUMMARY_FILE << 'EOF'

          **üìö Resources:**
          - [Modular Architecture Guide](https://github.com/opendatahub-io/mod-arch-shared-library)
          - [Testing Strategy](https://miro.com/app/board/uXjVJYjWx4I=/)
          - [Quality Gates Documentation](docs/modular-architecture-quality-gates.md)

          > üí° This is an automated assessment. PRs can merge regardless of gate status, but modules with Code Quality failures must remain disabled.
          EOF

          # Output to GitHub Step Summary (always visible)
          cat $SUMMARY_FILE >> $GITHUB_STEP_SUMMARY

          echo "üìÑ Quality gates summary generated and added to job summary"
          echo "üìä Summary file size: $(wc -l < $SUMMARY_FILE) lines"
          echo "üìÑ Summary file path: $(pwd)/$SUMMARY_FILE"


      - name: Upload Quality Gates Summary
        uses: actions/upload-artifact@v4
        with:
          name: quality-gates-summary
          path: quality-gates-summary.md
          retention-days: 30
