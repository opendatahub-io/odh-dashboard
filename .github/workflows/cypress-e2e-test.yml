name: E2E Direct Commit PR Tests

on: [push, pull_request]

permissions:
  contents: read

env:
  NODE_VERSION: 20.x
  DO_NOT_TRACK: 1

jobs:
  get-test-tags:
    runs-on: self-hosted
    outputs:
      test-tags: ${{ steps.set-tags.outputs.test-tags }}
    steps:
      - name: Set default test tags
        id: set-tags
        # Created 2 new tags - @ci-dashboard-set-1 and @ci-dashboard-set-2
        # ToDO: Use turbo to run tests according to PR changes.
        run: |
          echo "test-tags=[\"@ci-dashboard-set-1\",\"@ci-dashboard-set-2\"]" >> $GITHUB_OUTPUT

  e2e-tests:
    needs: [get-test-tags]
    runs-on: self-hosted
    strategy:
      fail-fast: false
      matrix:
        test-tag: ${{ fromJson(needs.get-test-tags.outputs.test-tags) }}
    steps:
      - name: Calculate unique port for this workflow run
        run: |
          # Dynamic port allocation for parallel execution
          BASE_PORT=$((4000 + (${{ github.run_id }} % 100) * 10))
          
          # Add matrix offset to separate concurrent jobs within same PR
          if [[ "${{ matrix.test-tag }}" == *"set-1"* ]]; then
            MATRIX_OFFSET=0
          elif [[ "${{ matrix.test-tag }}" == *"set-2"* ]]; then
            MATRIX_OFFSET=1
          else
            MATRIX_OFFSET=2
          fi
          
          WEBPACK_PORT=$((BASE_PORT + MATRIX_OFFSET))
          echo "WEBPACK_PORT=$WEBPACK_PORT" >> $GITHUB_ENV
          echo "📍 Using port ${WEBPACK_PORT} for ${{ matrix.test-tag }}"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache npm dependencies
        uses: actions/cache@v4
        id: npm-cache
        with:
          path: |
            ~/.cache/Cypress
            **/node_modules
          key: ${{ runner.os }}-${{ env.NODE_VERSION }}-all-modules-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-${{ env.NODE_VERSION }}-all-modules-

      - name: Setup Node.js ${{ env.NODE_VERSION }}
        if: steps.npm-cache.outputs.cache-hit != 'true'
        uses: actions/setup-node@v4.3.0
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        if: steps.npm-cache.outputs.cache-hit != 'true'
        run: npm ci

      - name: Cache turbo build artifacts
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/.turbo
          key: ${{ runner.os }}-${{ env.NODE_VERSION }}-turbo-${{ github.sha }}-e2e
          restore-keys: |
            ${{ runner.os }}-${{ env.NODE_VERSION }}-turbo-

      - name: Cache OpenShift CLI tarball
        uses: actions/cache@v4
        id: oc-cache
        with:
          path: ${{ runner.temp }}/oc.tar.gz
          key: ${{ runner.os }}-oc-tarball-${{ env.OC_VERSION || '4.15.0' }}

      - name: Check and Install OpenShift CLI
        run: |
          echo "🔍 Checking if OpenShift CLI (oc) is installed..."

          # Check if oc is already installed
          if command -v oc &> /dev/null; then
            echo "✅ OpenShift CLI (oc) is already installed"
            oc version --client
          else
            echo "❌ OpenShift CLI (oc) not found, installing..."
            echo "📦 Installing oc CLI for Linux..."

            OC_TARBALL="${{ runner.temp }}/oc.tar.gz"

            # Check if tarball was cached
            if [ -f "$OC_TARBALL" ]; then
              echo "✅ Using cached OpenShift CLI tarball"
            else
              echo "📥 Downloading OpenShift CLI tarball..."
              curl -LO https://mirror.openshift.com/pub/openshift-v4/clients/oc/latest/linux/oc.tar.gz -o "$OC_TARBALL"
            fi

            # Extract and install oc
            echo "📦 Extracting OpenShift CLI..."
            tar -xzf "$OC_TARBALL"
            sudo mv oc /usr/local/bin/
            sudo chmod +x /usr/local/bin/oc

            # Verify installation
            echo "✅ OpenShift CLI installed successfully"
            oc version --client
          fi

          # Final verification
          echo "🎯 Final oc version check:"
          oc version --client || echo "⚠️  Could not determine oc version"

      - name: Install Cypress Dependencies
        run: |
          echo "🔧 Installing Cypress system dependencies for Fedora (based on Cypress docs)..."

          # Use the simplified approach from Cypress documentation for Amazon Linux 2023 (Fedora-compatible)
          if [[ "$RUNNER_OS" == "Linux" ]]; then
            echo "📦 Installing minimal Cypress dependencies for Linux..."

            # Based on Cypress docs for Amazon Linux 2023 - Fedora compatible
            echo "Installing core dependencies..."
            sudo dnf install -y xorg-x11-server-Xvfb gtk3-devel nss alsa-lib

            # Add the missing ATK packages that Cypress actually needs
            echo "Installing ATK dependencies..."
            sudo dnf install -y atk atk-devel at-spi2-atk

            # Add additional GUI libraries that might be needed
            echo "Installing additional GUI libraries..."
            sudo dnf install -y libgbm libgbm-devel libnotify libnotify-devel

            # Update library cache
            sudo ldconfig

            # Verify installations
            echo "🔍 Verifying installations..."
            if command -v Xvfb &> /dev/null; then
              echo "✅ Xvfb installed"
            else
              echo "❌ Xvfb missing"
            fi

            if ldconfig -p | grep -q libnss3; then
              echo "✅ NSS libraries installed"
            else
              echo "❌ NSS libraries missing"
            fi

            if ldconfig -p | grep -q libatk; then
              echo "✅ ATK libraries installed (fixes libatk-1.0.so.0 error)"
              echo "📋 ATK libraries found:"
              ldconfig -p | grep libatk
            else
              echo "❌ ATK libraries missing - checking what we have..."
              sudo dnf list installed | grep -i atk || echo "No ATK packages found"
              find /usr/lib* -name "*libatk*" 2>/dev/null || echo "No ATK libraries found in filesystem"
            fi

            echo "🎯 Cypress dependencies installation completed"
          fi

      - name: Download test configuration
        run: |
          echo "🔧 Downloading test configuration from GitLab..."
          
          if [ -n "${{ secrets.GITLAB_TOKEN }}" ] && [ -n "${{ secrets.GITLAB_TEST_VARS_URL }}" ]; then
            if curl -f -k -H "Authorization: Bearer ${{ secrets.GITLAB_TOKEN }}" \
                        "${{ secrets.GITLAB_TEST_VARS_URL }}" \
                        -o ${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml; then
              echo "✅ Successfully downloaded test configuration"
            else
              echo "❌ Failed to download test configuration from GitLab"
              exit 1
            fi
          else
            echo "❌ GitLab secrets not available"
            echo "💡 This workflow requires GITLAB_TOKEN and GITLAB_TEST_VARS_URL secrets"
            exit 1
          fi

      - name: Login to OpenShift cluster
        run: |
          # For forked PRs, skip OpenShift login since secrets are not available
          if [ -z "${{ secrets.OC_SERVER }}" ]; then
            echo "⚠️  OpenShift secrets not available (forked PR) - skipping cluster login"
            echo "💡 Tests will run in mock mode or against local test environment"
            exit 0
          fi

          # Read credentials from downloaded test-variables.yml
          TEST_VARS_FILE="${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml"

          # Extract OC_USERNAME from OCP_ADMIN_USER section
          OC_USERNAME=$(grep -A 10 "^OCP_ADMIN_USER:" "$TEST_VARS_FILE" | grep "USERNAME:" | head -1 | sed 's/.*USERNAME: //' | tr -d ' ')

          # Extract OC_PASSWORD from OCP_ADMIN_USER section
          OC_PASSWORD=$(grep -A 10 "^OCP_ADMIN_USER:" "$TEST_VARS_FILE" | grep "PASSWORD:" | head -1 | sed 's/.*PASSWORD: //' | tr -d ' ')

          # Mask sensitive data in logs
          echo "::add-mask::$OC_PASSWORD"
          echo "::add-mask::$OC_USERNAME"

          # Extract TEST_USER_3_AUTH_TYPE from TEST_USER_3 section
          TEST_USER_3_AUTH_TYPE=$(grep -A 10 "^TEST_USER_3:" "$TEST_VARS_FILE" | grep "AUTH_TYPE:" | head -1 | sed 's/.*AUTH_TYPE: //' | tr -d ' ')

          # Extract TEST_USER_3_USERNAME from TEST_USER_3 section
          TEST_USER_3_USERNAME=$(grep -A 10 "^TEST_USER_3:" "$TEST_VARS_FILE" | grep "USERNAME:" | head -1 | sed 's/.*USERNAME: //' | tr -d ' ')

          # Extract TEST_USER_3_PASSWORD from TEST_USER_3 section
          TEST_USER_3_PASSWORD=$(grep -A 10 "^TEST_USER_3:" "$TEST_VARS_FILE" | grep "PASSWORD:" | head -1 | sed 's/.*PASSWORD: //' | tr -d ' ')

          # Mask TEST_USER_3 credentials in logs (must happen after extraction)
          echo "::add-mask::$TEST_USER_3_USERNAME"
          echo "::add-mask::$TEST_USER_3_PASSWORD"

          # Export TEST_USER_3 credentials as environment variables for Cypress
          echo "TEST_USER_3_AUTH_TYPE=$TEST_USER_3_AUTH_TYPE" >> $GITHUB_ENV
          echo "TEST_USER_3_USERNAME=$TEST_USER_3_USERNAME" >> $GITHUB_ENV
          echo "TEST_USER_3_PASSWORD=$TEST_USER_3_PASSWORD" >> $GITHUB_ENV
          
          echo "Logging in to OpenShift cluster..."
          oc login -u "$OC_USERNAME" -p "$OC_PASSWORD" --server="${{ secrets.OC_SERVER }}" --insecure-skip-tls-verify > /dev/null 2>&1
          
          if [ $? -eq 0 ]; then
            echo "✅ Successfully logged in to OpenShift cluster (dash-e2e-odh)"
          else
            echo "❌ Failed to login to OpenShift cluster"
            exit 1
          fi

          # Export OpenShift configuration for Cypress tests
          export KUBECONFIG="$HOME/.kube/config"
          echo "KUBECONFIG=$KUBECONFIG" >> $GITHUB_ENV

      - name: Set test configuration
        run: |
          export CY_TEST_CONFIG="${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml"
          echo "CY_TEST_CONFIG=$CY_TEST_CONFIG" >> $GITHUB_ENV
          echo "✅ Test configuration set (Cypress will connect to localhost:${WEBPACK_PORT})"

      - name: Start Cypress Server
        run: |
          echo "🧹 Cleaning up port ${WEBPACK_PORT}..."
          
          # Kill processes using this specific port only (preserves other parallel jobs)
          if lsof -i:${WEBPACK_PORT} > /dev/null 2>&1; then
            echo "⚠️  Port ${WEBPACK_PORT} is in use, cleaning up..."
            lsof -ti:${WEBPACK_PORT} | xargs -r kill -9 2>/dev/null || true
            sleep 3
          fi
          
          # Verify port is free with retry logic
          RETRY_COUNT=0
          while lsof -i:${WEBPACK_PORT} > /dev/null 2>&1; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -gt 10 ]; then
              echo "❌ Port ${WEBPACK_PORT} still in use after cleanup!"
              lsof -i:${WEBPACK_PORT}
              exit 1
            fi
            echo "⏳ Retrying cleanup... (attempt $RETRY_COUNT/10)"
            lsof -ti:${WEBPACK_PORT} | xargs -r kill -9 2>/dev/null || true
            sleep 2
          done
          
          echo "✅ Port ${WEBPACK_PORT} is free"
          echo "🚀 Starting webpack dev server on port ${WEBPACK_PORT} (dash-e2e-odh)..."
          
          # Start webpack and filter sensitive output
          cd frontend && ODH_PORT=${WEBPACK_PORT} npm run start:dev:ext > /tmp/webpack_${WEBPACK_PORT}.log 2>&1 &
          SERVER_PID=$!
          echo "SERVER_PID=$SERVER_PID" >> $GITHUB_ENV
          
          # Give server time to initialize
          sleep 20
          
          # Show filtered webpack status (hide sensitive cluster URLs)
          if [ -f /tmp/webpack_${WEBPACK_PORT}.log ]; then
            tail -20 /tmp/webpack_${WEBPACK_PORT}.log | \
              grep -v "Dashboard host:" | \
              grep -v "Proxy created:" | \
              grep -v "Logged in as user:" | \
              grep -v "Using project:" || true
          fi

      - name: Wait for Server Ready
        run: |
          echo "⏳ Waiting for localhost:${WEBPACK_PORT} to be ready..."
          npx wait-on http://localhost:${WEBPACK_PORT} --timeout 120000
          
          # Verify the application loads with dashboard content
          for i in {1..10}; do
            if curl -s -f http://localhost:${WEBPACK_PORT}/ | grep -q "Data Science Projects\|ODH\|Open Data Hub\|Dashboard"; then
              echo "✅ Server is ready and application is loaded!"
              break
            fi
            
            if [ $i -lt 10 ]; then
              echo "⏳ Waiting for application to load... (attempt $i/10)"
              sleep 8
            else
              echo "❌ Application failed to load properly after 10 attempts"
              exit 1
            fi
          done

      - name: Run E2E Tests
        run: |
          cd frontend

          echo "🧪 Running E2E tests for ${{ matrix.test-tag }}..."
          echo "🚀 Running tests against live dashboard on port ${WEBPACK_PORT}"

          export CY_RESULTS_DIR="${{ github.workspace }}/frontend/src/__tests__/cypress/results/${{ matrix.test-tag }}"
          mkdir -p "$CY_RESULTS_DIR"

          # Run Cypress tests with Electron browser
          BASE_URL=http://localhost:${WEBPACK_PORT} npm run cypress:run:electron -- \
            --env skipTags="@Bug @Maintain @NonConcurrent",grepTags="${{ matrix.test-tag }}",grepFilterSpecs=true \
            --config video=false,screenshotsFolder="$CY_RESULTS_DIR/screenshots"

      - name: Test tag name
        if: ${{ always() }}
        run: |
          TEST_TAG_NAME=$(echo '${{ matrix.test-tag }}' | tr '/' '_' | tr '@' '_')
          echo "TEST_TAG_NAME=$TEST_TAG_NAME" >> $GITHUB_ENV

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results-${{ matrix.test-tag }}
          path: |
            frontend/src/__tests__/cypress/results/
            frontend/src/__tests__/cypress/videos/
            frontend/src/__tests__/cypress/screenshots/
            frontend/src/__tests__/cypress/coverage/
          retention-days: 7

      - name: Log test completion
        if: always()
        run: |
          echo "🏁 E2E Test completed!"
          echo "Status: ${{ job.status }}"
          echo "Event: ${{ github.event_name }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Test Tag: ${{ matrix.test-tag }}"
          echo "Commit: ${{ github.sha }}"
          echo "Run ID: ${{ github.run_id }}"
          echo ""
          echo "📊 Test artifacts uploaded to:"
          echo "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

  cleanup-server:
    needs: [e2e-tests]
    runs-on: self-hosted
    if: ${{ always() && needs.e2e-tests.result != 'skipped' }}
    steps:
      - name: Stop Cypress Servers
        run: |
          echo "🛑 Stopping webpack dev server..."
          if [ -n "$SERVER_PID" ]; then
            kill $SERVER_PID || echo "Failed to kill SERVER_PID"
          fi
          pkill -f "webpack.*serve" || echo "No webpack processes found"
          pkill -f "node.*40[0-9][0-9]" || echo "No node processes on dynamic ports"
          echo "✅ Server cleanup completed"
