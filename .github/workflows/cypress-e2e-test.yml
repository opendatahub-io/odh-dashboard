name: E2E Direct Commit PR Tests

on: [push, pull_request]

permissions:
  contents: read

env:
  NODE_VERSION: 20.x
  DO_NOT_TRACK: 1

jobs:
  get-test-tags:
    runs-on: self-hosted
    outputs:
      test-tags: ${{ steps.set-tags.outputs.test-tags }}
    steps:
      - name: Set default test tags
        id: set-tags
        # Created 2 new tags - @ci-dashboard-set-1 and @ci-dashboard-set-2
        # ToDO: Use turbo to run tests according to PR changes.
        run: |
          echo "test-tags=[\"@ci-dashboard-set-1\",\"@ci-dashboard-set-2\"]" >> $GITHUB_OUTPUT

  e2e-tests:
    needs: [get-test-tags]
    runs-on: self-hosted
    strategy:
      fail-fast: false
      matrix:
        test-tag: ${{ fromJson(needs.get-test-tags.outputs.test-tags) }}
    steps:
      - name: Calculate unique port for this workflow run
        run: |
          # Generate unique port using run_id + matrix index to avoid conflicts
          # Port range: 4000-4990 (100 possible base ports)
          # Each matrix job gets +10 offset from base
          BASE_PORT=$((4000 + ((${{ github.run_id }} % 100) * 10)))
          
          # Add matrix offset based on test tag to ensure jobs in same run use different ports
          if [[ "${{ matrix.test-tag }}" == *"set-1"* ]]; then
            MATRIX_OFFSET=0
          elif [[ "${{ matrix.test-tag }}" == *"set-2"* ]]; then
            MATRIX_OFFSET=1
          else
            MATRIX_OFFSET=2
          fi
          
          CYPRESS_PORT=$((BASE_PORT + MATRIX_OFFSET))
          
          echo "CYPRESS_PORT=$CYPRESS_PORT" >> $GITHUB_ENV
          echo "ðŸ“ Workflow run ${{ github.run_id }} (tag: ${{ matrix.test-tag }}) will use port: $CYPRESS_PORT"
          echo "ðŸ”¢ Calculation: BASE=$BASE_PORT, OFFSET=$MATRIX_OFFSET, FINAL=$CYPRESS_PORT"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache npm dependencies
        uses: actions/cache@v4
        id: npm-cache
        with:
          path: |
            ~/.cache/Cypress
            **/node_modules
          key: ${{ runner.os }}-${{ env.NODE_VERSION }}-all-modules-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-${{ env.NODE_VERSION }}-all-modules-

      - name: Setup Node.js ${{ env.NODE_VERSION }}
        if: steps.npm-cache.outputs.cache-hit != 'true'
        uses: actions/setup-node@v4.3.0
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        if: steps.npm-cache.outputs.cache-hit != 'true'
        run: npm ci

      - name: Cache turbo build artifacts
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/.turbo
          key: ${{ runner.os }}-${{ env.NODE_VERSION }}-turbo-${{ github.sha }}-e2e
          restore-keys: |
            ${{ runner.os }}-${{ env.NODE_VERSION }}-turbo-

      - name: Cache OpenShift CLI tarball
        uses: actions/cache@v4
        id: oc-cache
        with:
          path: ${{ runner.temp }}/oc.tar.gz
          key: ${{ runner.os }}-oc-tarball-${{ env.OC_VERSION || '4.15.0' }}

      - name: Check and Install OpenShift CLI
        run: |
          echo "ðŸ” Checking if OpenShift CLI (oc) is installed..."

          # Check if oc is already installed
          if command -v oc &> /dev/null; then
            echo "âœ… OpenShift CLI (oc) is already installed"
            oc version --client
          else
            echo "âŒ OpenShift CLI (oc) not found, installing..."
            echo "ðŸ“¦ Installing oc CLI for Linux..."

            OC_TARBALL="${{ runner.temp }}/oc.tar.gz"

            # Check if tarball was cached
            if [ -f "$OC_TARBALL" ]; then
              echo "âœ… Using cached OpenShift CLI tarball"
            else
              echo "ðŸ“¥ Downloading OpenShift CLI tarball..."
              curl -LO https://mirror.openshift.com/pub/openshift-v4/clients/oc/latest/linux/oc.tar.gz -o "$OC_TARBALL"
            fi

            # Extract and install oc
            echo "ðŸ“¦ Extracting OpenShift CLI..."
            tar -xzf "$OC_TARBALL"
            sudo mv oc /usr/local/bin/
            sudo chmod +x /usr/local/bin/oc

            # Verify installation
            echo "âœ… OpenShift CLI installed successfully"
            oc version --client
          fi

          # Final verification
          echo "ðŸŽ¯ Final oc version check:"
          oc version --client || echo "âš ï¸  Could not determine oc version"

      - name: Install Cypress Dependencies
        run: |
          echo "ðŸ”§ Installing Cypress system dependencies for Fedora (based on Cypress docs)..."

          # Use the simplified approach from Cypress documentation for Amazon Linux 2023 (Fedora-compatible)
          if [[ "$RUNNER_OS" == "Linux" ]]; then
            echo "ðŸ“¦ Installing minimal Cypress dependencies for Linux..."

            # Based on Cypress docs for Amazon Linux 2023 - Fedora compatible
            echo "Installing core dependencies..."
            sudo dnf install -y xorg-x11-server-Xvfb gtk3-devel nss alsa-lib

            # Add the missing ATK packages that Cypress actually needs
            echo "Installing ATK dependencies..."
            sudo dnf install -y atk atk-devel at-spi2-atk

            # Add additional GUI libraries that might be needed
            echo "Installing additional GUI libraries..."
            sudo dnf install -y libgbm libgbm-devel libnotify libnotify-devel

            # Update library cache
            sudo ldconfig

            # Verify installations
            echo "ðŸ” Verifying installations..."
            if command -v Xvfb &> /dev/null; then
              echo "âœ… Xvfb installed"
            else
              echo "âŒ Xvfb missing"
            fi

            if ldconfig -p | grep -q libnss3; then
              echo "âœ… NSS libraries installed"
            else
              echo "âŒ NSS libraries missing"
            fi

            if ldconfig -p | grep -q libatk; then
              echo "âœ… ATK libraries installed (fixes libatk-1.0.so.0 error)"
              echo "ðŸ“‹ ATK libraries found:"
              ldconfig -p | grep libatk
            else
              echo "âŒ ATK libraries missing - checking what we have..."
              sudo dnf list installed | grep -i atk || echo "No ATK packages found"
              find /usr/lib* -name "*libatk*" 2>/dev/null || echo "No ATK libraries found in filesystem"
            fi

            echo "ðŸŽ¯ Cypress dependencies installation completed"
          fi

      - name: Debug available secrets
        run: |
          echo "ðŸ” DEBUG: Checking available secrets..."
          echo "Event name: ${{ github.event_name }}"
          echo "Repository: ${{ github.repository }}"
          echo "Repository owner: ${{ github.repository_owner }}"
          echo "Ref: ${{ github.ref }}"
          echo "Base ref: ${{ github.base_ref }}"
          echo "Head ref: ${{ github.head_ref }}"

          # Check for specific secrets without revealing values
          if [ -n "${{ secrets.GITLAB_TOKEN }}" ]; then
            echo "âœ… GITLAB_TOKEN: Available (length: ${#GITLAB_TOKEN})"
          else
            echo "âŒ GITLAB_TOKEN: Not available or empty"
          fi

          if [ -n "${{ secrets.GITLAB_TEST_VARS_URL }}" ]; then
            echo "âœ… GITLAB_TEST_VARS_URL: Available (length: ${#GITLAB_TEST_VARS_URL})"
          else
            echo "âŒ GITLAB_TEST_VARS_URL: Not available or empty"
          fi

          # Check other potentially relevant secrets
          if [ -n "${{ secrets.OC_SERVER }}" ]; then
            echo "âœ… OC_SERVER: Available"
          else
            echo "âŒ OC_SERVER: Not available"
          fi

          if [ -n "${{ secrets.OCP_CONSOLE_URL }}" ]; then
            echo "âœ… OCP_CONSOLE_URL: Available"
          else
            echo "âŒ OCP_CONSOLE_URL: Not available"
          fi

          if [ -n "${{ secrets.ODH_DASHBOARD_URL }}" ]; then
            echo "âœ… ODH_DASHBOARD_URL: Available"
          else
            echo "âŒ ODH_DASHBOARD_URL: Not available"
          fi

          # List all available secrets (names only)
          echo "ðŸ“‹ Available secrets in this environment:"
          env | grep -E '^[^=]+=' | sed 's/=.*//' | grep -i secret || echo "No SECRET variables found"

      - name: Download test configuration
        run: |
          # Debug: Show what we're working with
          echo "ðŸ”§ DEBUG: Attempting to download test configuration..."
          echo "GITLAB_TOKEN present: $([ -n "${{ secrets.GITLAB_TOKEN }}" ] && echo 'YES' || echo 'NO')"
          echo "GITLAB_TEST_VARS_URL present: $([ -n "${{ secrets.GITLAB_TEST_VARS_URL }}" ] && echo 'YES' || echo 'NO')"

          # Try to download test-variables.yml from GitLab securely
          if [ -n "${{ secrets.GITLAB_TOKEN }}" ] && [ -n "${{ secrets.GITLAB_TEST_VARS_URL }}" ]; then
            echo "ðŸ”„ Both secrets are available, attempting download..."
            echo "Token length: ${#GITLAB_TOKEN}"
            echo "URL length: ${#GITLAB_TEST_VARS_URL}"

            # Debug: Show first few characters of secrets (safely)
            if [ -n "${{ secrets.GITLAB_TOKEN }}" ]; then
              echo "Token starts with: ${{ secrets.GITLAB_TOKEN }}" | cut -c1-10
            fi
            if [ -n "${{ secrets.GITLAB_TEST_VARS_URL }}" ]; then
              echo "URL starts with: ${{ secrets.GITLAB_TEST_VARS_URL }}" | cut -c1-20
            fi

            # Try with SSL verification disabled (for self-signed certs)
            if curl -f -k -H "Authorization: Bearer ${{ secrets.GITLAB_TOKEN }}" \
                        "${{ secrets.GITLAB_TEST_VARS_URL }}" \
                        -o ${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml; then
              echo "âœ… Successfully downloaded test configuration from GitLab"
              ls -la ${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml
            else
              echo "âŒ Failed to download from GitLab"
              echo "Curl exit code: $?"

              # Try to get more details about the failure
              echo "Trying without -f to see error details..."
              curl -k -H "Authorization: Bearer ${{ secrets.GITLAB_TOKEN }}" \
                  "${{ secrets.GITLAB_TEST_VARS_URL }}" \
                  -o /tmp/test-response 2>&1 || echo "Curl failed with: $?"

              if [ -f /tmp/test-response ]; then
                echo "GitLab API Response:"
                head -10 /tmp/test-response
              fi

              exit 1
            fi
          else
            echo "âš ï¸  GitLab secrets not available - cannot download test configuration"
            echo "ðŸ’¡ This workflow requires GITLAB_TOKEN and GITLAB_TEST_VARS_URL secrets to be configured"
            echo "ðŸ’¡ For forked PRs, these secrets need to be available in the upstream repository"
            echo ""
            echo "ðŸ” DEBUG INFO:"
            echo "- Repository: ${{ github.repository }}"
            echo "- Event: ${{ github.event_name }}"
            echo "- Is fork: $([ '${{ github.repository_owner }}' != 'opendatahub-io' ] && echo 'YES' || echo 'NO')"
            echo "- Base repo: ${{ github.base_ref && github.repository || 'N/A' }}"
            echo ""
            echo "ðŸ’¡ POSSIBLE SOLUTIONS:"
            echo "1. Ensure secrets are configured in upstream repo (opendatahub-io/odh-dashboard)"
            echo "2. For testing, secrets need to be available when PR is merged"
            echo "3. Check secret names match exactly: GITLAB_TOKEN, GITLAB_TEST_VARS_URL"
            exit 1
          fi

      - name: Login to OpenShift cluster
        run: |
          # For forked PRs, skip OpenShift login since secrets are not available
          if [ -z "${{ secrets.OC_SERVER }}" ]; then
            echo "âš ï¸  OpenShift secrets not available (forked PR) - skipping cluster login"
            echo "ðŸ’¡ Tests will run in mock mode or against local test environment"
            exit 0
          fi

          # Read credentials from downloaded test-variables.yml
          TEST_VARS_FILE="${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml"

          # Extract OC_USERNAME from OCP_ADMIN_USER section
          OC_USERNAME=$(grep -A 10 "^OCP_ADMIN_USER:" "$TEST_VARS_FILE" | grep "USERNAME:" | head -1 | sed 's/.*USERNAME: //' | tr -d ' ')

          # Extract OC_PASSWORD from OCP_ADMIN_USER section
          OC_PASSWORD=$(grep -A 10 "^OCP_ADMIN_USER:" "$TEST_VARS_FILE" | grep "PASSWORD:" | head -1 | sed 's/.*PASSWORD: //' | tr -d ' ')

          # Mask sensitive data in logs
          echo "::add-mask::$OC_PASSWORD"
          echo "::add-mask::$OC_USERNAME"

          # Extract TEST_USER_3_AUTH_TYPE from TEST_USER_3 section
          TEST_USER_3_AUTH_TYPE=$(grep -A 10 "^TEST_USER_3:" "$TEST_VARS_FILE" | grep "AUTH_TYPE:" | head -1 | sed 's/.*AUTH_TYPE: //' | tr -d ' ')

          # Extract TEST_USER_3_USERNAME from TEST_USER_3 section
          TEST_USER_3_USERNAME=$(grep -A 10 "^TEST_USER_3:" "$TEST_VARS_FILE" | grep "USERNAME:" | head -1 | sed 's/.*USERNAME: //' | tr -d ' ')

          # Extract TEST_USER_3_PASSWORD from TEST_USER_3 section
          TEST_USER_3_PASSWORD=$(grep -A 10 "^TEST_USER_3:" "$TEST_VARS_FILE" | grep "PASSWORD:" | head -1 | sed 's/.*PASSWORD: //' | tr -d ' ')

          # Mask TEST_USER_3 credentials in logs (must happen after extraction)
          echo "::add-mask::$TEST_USER_3_USERNAME"
          echo "::add-mask::$TEST_USER_3_PASSWORD"

          # Export TEST_USER_3 credentials as environment variables for Cypress
          echo "TEST_USER_3_AUTH_TYPE=$TEST_USER_3_AUTH_TYPE" >> $GITHUB_ENV
          echo "TEST_USER_3_USERNAME=$TEST_USER_3_USERNAME" >> $GITHUB_ENV
          echo "TEST_USER_3_PASSWORD=$TEST_USER_3_PASSWORD" >> $GITHUB_ENV
          
          echo "Logging in to OpenShift cluster..."
          oc login -u "$OC_USERNAME" -p "$OC_PASSWORD" --server="${{ secrets.OC_SERVER }}" --insecure-skip-tls-verify

          # Export OpenShift configuration for Cypress tests
          echo "ðŸ”§ Setting up OpenShift configuration for Cypress tests..."
          export KUBECONFIG="$HOME/.kube/config"
          echo "KUBECONFIG=$KUBECONFIG" >> $GITHUB_ENV

      - name: Set test configuration with dynamic port
        run: |
          # Create unique test-variables file for this workflow run + matrix job
          TEST_VARS_FILE="${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables-${{ github.run_id }}-${{ matrix.test-tag }}.yml"
          cp ${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml "$TEST_VARS_FILE"
          
          # ALWAYS use localhost with dynamic port for dev server
          # Webpack will proxy API calls to the real cluster (via OC login)
          DYNAMIC_URL="http://localhost:${CYPRESS_PORT}"
          
          echo "ðŸŒ Using localhost with port ${CYPRESS_PORT} (webpack will proxy to cluster)"
          sed -i.bak "s|OCP_CONSOLE_URL:.*|OCP_CONSOLE_URL: $DYNAMIC_URL|" "$TEST_VARS_FILE"
          sed -i.bak "s|ODH_DASHBOARD_URL:.*|ODH_DASHBOARD_URL: $DYNAMIC_URL|" "$TEST_VARS_FILE"

          # Export the unique config file path
          echo "CY_TEST_CONFIG=$TEST_VARS_FILE" >> $GITHUB_ENV
          echo "ðŸ“ Test config file: $TEST_VARS_FILE"
          echo "ðŸŒ Dynamic URL: $DYNAMIC_URL"

      - name: Start Cypress Server on dynamic port
        run: |
          # Increase file descriptor limit for Chrome/Cypress
          ulimit -n 65536 || echo "âš ï¸  Could not increase file descriptor limit"
          echo "ðŸ“Š File descriptor limit: $(ulimit -n)"
          
          echo "ðŸ§¹ Cleaning up zombie Chrome processes (older than 2 hours)..."
          # Find and kill old Chrome processes from previous failed runs
          ps aux | grep 'chrome --test-type' | grep -v grep | awk '{if ($10 ~ /[0-9]+:[0-9]+/ && $10 !~ /^0:/) print $2}' | xargs -r kill -9 2>/dev/null || echo "No old Chrome processes found"
          
          echo "ðŸ§¹ Cleaning up any existing processes on port ${CYPRESS_PORT}..."
          lsof -ti:${CYPRESS_PORT} | xargs kill -9 2>/dev/null || echo "No processes on port ${CYPRESS_PORT}"
          pkill -f "webpack.*serve.*${CYPRESS_PORT}" 2>/dev/null || echo "No webpack processes for port ${CYPRESS_PORT}"
          sleep 2
          
          echo "ðŸš€ Starting webpack dev server on port ${CYPRESS_PORT} with cluster proxy..."
          cd frontend && ODH_PORT=${CYPRESS_PORT} npm run start:dev:ext &
          
          SERVER_PID=$!
          echo "SERVER_PID=$SERVER_PID" >> $GITHUB_ENV
          echo "Started webpack dev server with PID: $SERVER_PID on port ${CYPRESS_PORT}"
          
          # Give the server extra time to start in CI
          echo "â³ Giving server 15 seconds to initialize..."
          sleep 15

      - name: Wait for Server Ready on dynamic port
        run: |
          echo "â³ Waiting for localhost:${CYPRESS_PORT} to be ready..."
          # Use HTTP check instead of TCP since server is clearly running
          npx wait-on http://localhost:${CYPRESS_PORT} --timeout 120000
          echo "âœ… Server is responding to HTTP on port ${CYPRESS_PORT}!"
          
          # Verify the application actually loads with more details
          echo "ðŸ” Verifying application loads properly..."
          for i in {1..10}; do
            echo "ðŸ”„ Attempt $i/10: Testing application on port ${CYPRESS_PORT}..."
            
            # Check if basic page loads
            if curl -s -f http://localhost:${CYPRESS_PORT}/ > /tmp/response-${CYPRESS_PORT}.html 2>/dev/null; then
              echo "âœ… HTTP 200 response received"
              
              # Check for dashboard content
              if grep -q "Data Science Projects\|ODH\|Open Data Hub\|Dashboard" /tmp/response-${CYPRESS_PORT}.html; then
                echo "âœ… Found dashboard content!"
                break
              else
                echo "âš ï¸  Page loads but no dashboard content yet..."
                echo "ðŸ“„ Response contains: $(head -c 200 /tmp/response-${CYPRESS_PORT}.html | tr '\n' ' ')"
              fi
            else
              echo "âŒ HTTP request failed"
              curl_exit_code=$?
              echo "Curl exit code: $curl_exit_code"
            fi
            
            if [ $i -lt 10 ]; then
              echo "â³ Waiting 8 seconds before retry..."
              sleep 8
            fi
          done
          
          # Final verification with detailed debugging
          echo "ðŸ” Final application verification..."
          if curl -s -f http://localhost:${CYPRESS_PORT}/ | grep -q "Data Science Projects\|ODH\|Open Data Hub\|Dashboard"; then
            echo "âœ… Server is ready and application is loaded on port ${CYPRESS_PORT}!"
            
            # Test API endpoint
            echo "ðŸ” Testing API endpoint..."
            if curl -s -f http://localhost:${CYPRESS_PORT}/api/status > /dev/null; then
              echo "âœ… API proxy is working!"
            else
              echo "âš ï¸  API endpoint test failed, but frontend is working"
            fi
          else
            echo "âŒ Application failed to load properly on port ${CYPRESS_PORT}"
            echo ""
            echo "ðŸ“Š Debugging information:"
            echo "ðŸ”„ Server process status:"
            ps aux | grep -E "(webpack|node.*${CYPRESS_PORT})" | head -5 || echo "No matching processes found"
            
            echo ""
            echo "ðŸŒ Network connectivity test:"
            curl -I http://localhost:${CYPRESS_PORT}/ 2>&1 || echo "Connection failed"
            
            echo ""
            echo "ðŸ“„ Raw response (first 1000 chars):"
            curl -s http://localhost:${CYPRESS_PORT}/ 2>/dev/null | head -c 1000 || echo "Failed to get response"
            
            exit 1
          fi

      - name: Run E2E Tests with dynamic port
        run: |
          # Ensure file descriptor limit is high for Chrome/Cypress
          ulimit -n 65536 || echo "âš ï¸  Could not increase file descriptor limit"
          
          cd frontend

          echo "Event: ${{ github.event_name }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Port: ${CYPRESS_PORT}"
          echo "Config: ${CY_TEST_CONFIG}"
          echo "ðŸ“Š File descriptors: $(ulimit -n)"

          # Set Cypress environment
          export CY_RESULTS_DIR="${{ github.workspace }}/frontend/src/__tests__/cypress/results/${{ matrix.test-tag }}"
          export BASE_URL="http://localhost:${CYPRESS_PORT}"

          # Ensure OpenShift configuration is available to Cypress process
          if [ -n "$KUBECONFIG" ]; then
            echo "ðŸ”§ OpenShift configuration available: $KUBECONFIG"
            oc whoami || echo "âš ï¸  oc whoami failed, but continuing with tests"
          else
            echo "âš ï¸  No KUBECONFIG set, OpenShift commands may fail"
          fi

          echo "ðŸŽ¯ Running tests with tags: ${{ matrix.test-tag }}"
          echo "ðŸš« Skipping tags: @Bug,@Maintain,@NonConcurrent"
          echo "ðŸ“‹ Test group: ${{ matrix.test-tag }}"
          echo "ðŸŒ Base URL: $BASE_URL"

          # Create results directory
          mkdir -p "$CY_RESULTS_DIR"
          
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ðŸ” PRE-TEST DEBUGGING - Chrome/Cypress Connection"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ðŸ“ Working directory: $(pwd)"
          echo "ðŸ“ Webpack URL: $BASE_URL"
          echo ""
          echo "ðŸ” GitHub Actions Environment:"
          echo "  CI=$CI"
          echo "  GITHUB_ACTIONS=$GITHUB_ACTIONS"
          echo "  RUNNER_NAME=$RUNNER_NAME"
          echo ""
          echo "ðŸ” Display/Graphics:"
          env | grep -E "DISPLAY|XAUTH|WAYLAND" || echo "  None set (headless mode)"
          echo ""
          echo "ðŸ” Process Info:"
          echo "  Parent PID: $PPID"
          echo "  Current PID: $$"
          ps -p $$ -o ppid,pid,cmd --no-headers
          echo "ðŸ“Š Current user: $(whoami)"
          echo "ðŸ“Š Process limits:"
          ulimit -a | grep -E "open files|processes|max memory"
          echo ""
          echo "ðŸŒ Network state before tests:"
          echo "Listening ports 4000-5000:"
          lsof -i :4000-5000 2>/dev/null | grep LISTEN || echo "No ports listening in range"
          echo ""
          echo "ðŸ“¦ Existing Chrome processes:"
          CHROME_COUNT=$(ps aux | grep -i chrome | grep -v grep | wc -l)
          echo "Total: $CHROME_COUNT"
          if [ $CHROME_COUNT -gt 0 ]; then
            echo "Checking for zombie processes (older than 1 hour CPU time):"
            ps aux | grep 'chrome --test-type' | grep -v grep | awk '{if ($10 ~ /[0-9]+:[0-9]+/) print "PID:"$2" CPU:"$3"% MEM:"$4"% TIME:"$10}' | head -5
          fi
          echo ""
          echo "ðŸ”Œ Testing webpack connectivity:"
          curl -f -s -o /dev/null -w "HTTP Status: %{http_code}\n" http://localhost:${CYPRESS_PORT}/ || echo "âŒ Webpack not responding!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""

          # Monitor Chrome/Cypress connection in background
          (
            echo "ðŸ” Starting Chrome monitoring..."
            for i in 10 20 30 45 60; do
              sleep $i
              echo ""
              echo "ðŸ” [$i s] Chrome Status Check:"
              
              # Check if Chrome launched
              CHROME_PIDS=$(pgrep -f "chrome --test-type.*$CYPRESS_PORT" 2>/dev/null)
              if [ -n "$CHROME_PIDS" ]; then
                CHROME_COUNT=$(echo "$CHROME_PIDS" | wc -l)
                echo "  âœ… Chrome running: $CHROME_COUNT process(es)"
                
                # Check DevTools port
                DEVTOOLS_PORT=$(lsof -i -n 2>/dev/null | grep chrome | grep LISTEN | grep -v "$CYPRESS_PORT" | awk '{print $9}' | cut -d: -f2 | head -1)
                if [ -n "$DEVTOOLS_PORT" ]; then
                  echo "  âœ… DevTools port open: $DEVTOOLS_PORT"
                  
                  # Test if we can connect to it
                  if timeout 2 nc -z 127.0.0.1 $DEVTOOLS_PORT 2>/dev/null; then
                    echo "  âœ… DevTools port is ACCESSIBLE"
                  else
                    echo "  âŒ DevTools port NOT accessible (Cypress can't connect!)"
                  fi
                else
                  echo "  âŒ DevTools port NOT listening (Chrome debugging disabled?)"
                fi
              else
                echo "  âŒ Chrome not running yet or already crashed"
              fi
              
              # Stop monitoring after timeout period
              [ $i -ge 60 ] && break
            done
          ) &
          MONITOR_PID=$!
          
          # CRITICAL FIX: Unset CI variables that may interfere with Chrome DevTools
          # Testing hypothesis: GitHub Actions environment prevents Chrome connection
          unset CI
          unset GITHUB_ACTIONS
          
          echo "ðŸ”§ Temporarily unset CI variables for Chrome compatibility"
          echo "   CI is now: ${CI:-unset}"
          echo "   GITHUB_ACTIONS is now: ${GITHUB_ACTIONS:-unset}"
          echo ""
          
          # Run tests with dynamic base URL set BEFORE Cypress starts
          # Capture output to monitor Chrome startup
          # CRITICAL FIX: Increased browserLaunchTimeout from 30s (default) to 120s
          npm run cypress:run:chrome -- \
            --env skipTags="@Bug @Maintain @NonConcurrent",grepTags="${{ matrix.test-tag }}",grepFilterSpecs=true \
            --config baseUrl="$BASE_URL",video=true,screenshotsFolder="$CY_RESULTS_DIR/screenshots",videosFolder="$CY_RESULTS_DIR/videos",browserLaunchTimeout=120000 \
            2>&1 | tee /tmp/cypress-run-${{ matrix.test-tag }}.log || CYPRESS_EXIT=$?
          
          # Capture the exit code
          CYPRESS_EXIT=${CYPRESS_EXIT:-${PIPESTATUS[0]}}
          
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ðŸ” POST-TEST DEBUGGING - What Happened?"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ðŸ“Š Cypress exit code: $CYPRESS_EXIT"
          echo ""
          
          if [ $CYPRESS_EXIT -ne 0 ]; then
            echo "âŒ Test failed. Analyzing Cypress connection logs..."
            echo ""
            
            # Show Chrome/browser connection errors (safe to print)
            if grep -q "Timed out waiting.*browser" /tmp/cypress-run-${{ matrix.test-tag }}.log 2>/dev/null; then
              echo "ðŸš¨ BROWSER TIMEOUT DETECTED!"
              echo ""
              echo "Chrome launch and connection details:"
              # Show DevTools messages
              grep -E "DevTools listening on|Chrome.*version|Browser.*launched|Launching browser|browser.*connect|ECONNREFUSED|connection refused" /tmp/cypress-run-${{ matrix.test-tag }}.log | head -20
              echo ""
              echo "Browser timeout messages:"
              grep -A5 -B5 "Timed out waiting.*browser" /tmp/cypress-run-${{ matrix.test-tag }}.log | head -30
            fi
            
            # Check for other connection errors
            if grep -qE "ECONNREFUSED|ENOTFOUND|ETIMEDOUT|ERR_CONNECTION" /tmp/cypress-run-${{ matrix.test-tag }}.log 2>/dev/null; then
              echo ""
              echo "ðŸ”Œ Network connection errors found:"
              grep -E "ECONNREFUSED|ENOTFOUND|ETIMEDOUT|ERR_CONNECTION" /tmp/cypress-run-${{ matrix.test-tag }}.log | head -10
            fi
            
            # Check for Chrome crash
            if grep -qE "Chrome.*crashed|Chrome.*killed|Browser.*crashed" /tmp/cypress-run-${{ matrix.test-tag }}.log 2>/dev/null; then
              echo ""
              echo "ðŸ’¥ Chrome crash detected:"
              grep -E "Chrome.*crashed|Chrome.*killed|Browser.*crashed" /tmp/cypress-run-${{ matrix.test-tag }}.log | head -10
            fi
            
            echo ""
            echo "Last 20 lines of Cypress output (may contain error details):"
            tail -20 /tmp/cypress-run-${{ matrix.test-tag }}.log
          else
            echo "âœ… Tests passed!"
          fi
          
          # Stop the monitoring background process
          if [ -n "$MONITOR_PID" ]; then
            kill $MONITOR_PID 2>/dev/null || true
          fi
          echo ""
          echo ""
          
          if [ $CYPRESS_EXIT -ne 0 ]; then
            echo "âŒ Tests failed or timed out. Detailed debugging:"
            echo ""
            
            echo "ðŸ” Chrome processes after failure:"
            ps aux | grep chrome | grep -v grep || echo "No Chrome processes found"
            echo ""
            
            echo "ðŸ” Chrome remote debugging ports:"
            lsof -i -n | grep chrome | grep LISTEN || echo "No Chrome listening ports found"
            echo ""
            
            echo "ðŸ” Searching for 'Timed out' in Cypress output:"
            grep -i "timed out" /tmp/cypress-run-${{ matrix.test-tag }}.log || echo "No timeout messages found"
            echo ""
            
            echo "ðŸ” Searching for 'browser' errors in Cypress output:"
            grep -i "browser" /tmp/cypress-run-${{ matrix.test-tag }}.log | tail -20 || echo "No browser error messages found"
            echo ""
            
            echo "ðŸ” DevTools connection attempts:"
            grep -i "devtools\|ws://" /tmp/cypress-run-${{ matrix.test-tag }}.log || echo "No DevTools connection info found"
            echo ""
            
            echo "ðŸ” Last 50 lines of Cypress output:"
            tail -50 /tmp/cypress-run-${{ matrix.test-tag }}.log
          fi
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          # Preserve the exit code
          exit $CYPRESS_EXIT

      - name: Cleanup dynamic port resources
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up resources for port ${CYPRESS_PORT}..."
          if [ -n "$SERVER_PID" ]; then
            kill $SERVER_PID 2>/dev/null || echo "Failed to kill SERVER_PID $SERVER_PID"
          fi
          lsof -ti:${CYPRESS_PORT} | xargs kill -9 2>/dev/null || echo "No processes on port ${CYPRESS_PORT}"
          pkill -f "webpack.*serve.*${CYPRESS_PORT}" 2>/dev/null || echo "No webpack processes for port ${CYPRESS_PORT}"
          
          # Remove unique test config file
          rm -f "${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables-${{ github.run_id }}-${{ matrix.test-tag }}.yml"
          rm -f /tmp/response-${CYPRESS_PORT}.html
          echo "âœ… Cleanup completed for port ${CYPRESS_PORT}"

      - name: Test tag name
        if: ${{ always() }}
        run: |
          TEST_TAG_NAME=$(echo '${{ matrix.test-tag }}' | tr '/' '_' | tr '@' '_')
          echo "TEST_TAG_NAME=$TEST_TAG_NAME" >> $GITHUB_ENV

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results-${{ matrix.test-tag }}
          path: |
            frontend/src/__tests__/cypress/results/
            frontend/src/__tests__/cypress/videos/
            frontend/src/__tests__/cypress/screenshots/
            frontend/src/__tests__/cypress/coverage/
          retention-days: 7

      - name: Log test completion
        if: always()
        run: |
          echo "ðŸ E2E Test completed!"
          echo "Status: ${{ job.status }}"
          echo "Event: ${{ github.event_name }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Test Tag: ${{ matrix.test-tag }}"
          echo "Commit: ${{ github.sha }}"
          echo "Run ID: ${{ github.run_id }}"
          echo ""
          echo "ðŸ“Š Test artifacts uploaded to:"
          echo "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

  cleanup-server:
    needs: [e2e-tests]
    runs-on: self-hosted
    if: ${{ always() && needs.e2e-tests.result != 'skipped' }}
    steps:
      - name: Stop all Cypress Servers (final cleanup)
        run: |
          echo "ðŸ›‘ Final cleanup - stopping all webpack dev servers..."
          pkill -f "webpack.*serve" || echo "No webpack processes found"
          
          # Clean up common port range used by dynamic port allocation
          echo "ðŸ§¹ Cleaning up dynamic port range (4000-5000)..."
          for port in {4000..5000..1}; do
            if lsof -ti:$port >/dev/null 2>&1; then
              echo "ðŸ”§ Found process on port $port, cleaning up..."
              lsof -ti:$port | xargs kill -9 2>/dev/null || true
            fi
          done
          
          # Clean up any test-variables files
          rm -f /home/fedora/actions-runner*/_work/odh-dashboard/odh-dashboard/frontend/src/__tests__/cypress/test-variables-*.yml 2>/dev/null || true
          
          echo "âœ… Server cleanup completed"
