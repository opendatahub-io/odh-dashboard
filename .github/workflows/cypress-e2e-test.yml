name: E2E Direct Commit PR Tests

on: [push, pull_request]

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  NODE_VERSION: 20.x
  DO_NOT_TRACK: 1

jobs:
  get-test-tags:
    runs-on: self-hosted
    outputs:
      test-tags: ${{ steps.set-tags.outputs.test-tags }}
    steps:
      - name: Set default test tags
        id: set-tags
        run: |
          echo "test-tags=[\"@SmokeSet1\",\"@SmokeSet2\",\"@SmokeSet3\"]" >> $GITHUB_OUTPUT

  e2e-tests:
    needs: [get-test-tags]
    runs-on: self-hosted
    strategy:
      fail-fast: false
      matrix:
        test-tag: ${{ fromJson(needs.get-test-tags.outputs.test-tags) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4.3.0
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies (self-hosted optimized)
        run: |
          echo "Installing dependencies for self-hosted runner..."
          npm ci --prefer-offline --no-audit --no-fund
          echo "Dependencies installed"

      - name: Cache turbo build artifacts
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/.turbo
          key: ${{ runner.os }}-${{ env.NODE_VERSION }}-turbo-${{ github.sha }}-e2e
          restore-keys: |
            ${{ runner.os }}-${{ env.NODE_VERSION }}-turbo-

      - name: Check and Install OpenShift CLI (self-hosted optimized)
        run: |
          echo "Checking if OpenShift CLI (oc) is installed..."
          if command -v oc &> /dev/null; then
            echo "OpenShift CLI (oc) is already installed"
            oc version --client
          else
            echo "OpenShift CLI (oc) not found, installing..."
            curl -LO https://mirror.openshift.com/pub/openshift-v4/clients/oc/latest/linux/oc.tar.gz
            tar -xzf oc.tar.gz
            sudo mv oc /usr/local/bin/
            sudo chmod +x /usr/local/bin/oc
            rm -f oc.tar.gz
            echo "OpenShift CLI installed successfully"
            oc version --client
          fi

      - name: Install jq for Cypress tests
        run: |
          if command -v jq &> /dev/null; then
            echo "jq is already installed"
          else
            echo "Installing jq..."
            if command -v dnf &> /dev/null; then
              sudo dnf install -y jq
            elif command -v yum &> /dev/null; then
              sudo yum install -y jq
            else
              sudo wget -O /usr/local/bin/jq https://github.com/stedolan/jq/releases/latest/download/jq-linux64
              sudo chmod +x /usr/local/bin/jq
            fi
            echo "jq installed"
          fi

      - name: Install Cypress Dependencies
        run: |
          if [[ "$RUNNER_OS" == "Linux" ]]; then
            echo "Installing Cypress system dependencies..."
            sudo dnf install -y xorg-x11-server-Xvfb gtk3-devel nss alsa-lib
            sudo dnf install -y atk atk-devel at-spi2-atk
            sudo dnf install -y libgbm libgbm-devel libnotify libnotify-devel
            sudo dnf install -y lsof
            sudo ldconfig
            echo "Cypress dependencies installed"
          fi


      - name: Download test configuration
        run: |
          if [ -n "${{ secrets.GITLAB_TOKEN }}" ] && [ -n "${{ secrets.GITLAB_TEST_VARS_URL }}" ]; then
            curl -f -k -H "Authorization: Bearer ${{ secrets.GITLAB_TOKEN }}" \
                 "${{ secrets.GITLAB_TEST_VARS_URL }}" \
                 -o ${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml
            echo "Successfully downloaded test configuration from GitLab"
          else
            echo "GitLab secrets not available - cannot download test configuration"
            exit 1
          fi

      - name: Login to OpenShift cluster
        run: |
          if [ -z "${{ secrets.OC_SERVER }}" ]; then
            echo "⚠️  OpenShift secrets not available - skipping cluster login"
            exit 0
          fi

          TEST_VARS_FILE="${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml"
          OC_USERNAME=$(grep -A 10 "^OCP_ADMIN_USER:" "$TEST_VARS_FILE" | grep "USERNAME:" | head -1 | sed 's/.*USERNAME: //' | tr -d ' ')
          OC_PASSWORD=$(grep -A 10 "^OCP_ADMIN_USER:" "$TEST_VARS_FILE" | grep "PASSWORD:" | head -1 | sed 's/.*PASSWORD: //' | tr -d ' ')

          if [ -n "$OC_PASSWORD" ]; then
            echo "::add-mask::$OC_PASSWORD"
          fi
          if [ -n "$OC_USERNAME" ]; then
            echo "::add-mask::$OC_USERNAME"
          fi

          oc login -u "$OC_USERNAME" -p "$OC_PASSWORD" --server="${{ secrets.OC_SERVER }}" --insecure-skip-tls-verify
          echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV

      - name: Set test configuration URLs from secrets
        run: |
          # Only update URLs if secrets are provided
          # Port will be set dynamically at server start time
          if [ -n "${{ secrets.OCP_CONSOLE_URL }}" ]; then
            sed -i.bak "s|OCP_CONSOLE_URL:.*|OCP_CONSOLE_URL: ${{ secrets.OCP_CONSOLE_URL }}|" ${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml
          fi
          
          if [ -n "${{ secrets.ODH_DASHBOARD_URL }}" ]; then
            sed -i.bak "s|ODH_DASHBOARD_URL:.*|ODH_DASHBOARD_URL: ${{ secrets.ODH_DASHBOARD_URL }}|" ${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml
          fi
          
          # Note: If secrets not provided, BASE_URL will be set at test run time with dynamic port

      - name: Calculate unique port for this job
        run: |
          # Dynamic port allocation to support concurrent PRs with any tags
          # Use hash-based approach for better distribution across port space
          # This minimizes collisions even with many concurrent PRs
          
          # Hash the run_id to spread PRs across port space (reduces collision probability)
          # Using last 3 digits gives us 1000 possible port ranges (vs 100 with simple modulo)
          RUN_HASH=$(echo "${{ github.run_id }}" | md5sum | cut -c1-8)
          RUN_OFFSET=$((0x$RUN_HASH % 500))  # 500 possible base ports
          BASE_PORT=$((4000 + (RUN_OFFSET * 10)))
          
          # Use strategy.job-index for port offset (works with ANY tag values)
          # job-index is 0-based: first job=0, second=1, third=2, etc.
          PORT_OFFSET=${{ strategy.job-index }}
          
          CYPRESS_PORT=$((BASE_PORT + PORT_OFFSET))
          echo "CYPRESS_PORT=$CYPRESS_PORT" >> $GITHUB_ENV
          
          echo "Allocated port $CYPRESS_PORT for ${{ matrix.test-tag }}"
          echo "  run_id=${{ github.run_id }}, base=$BASE_PORT, job-index=$PORT_OFFSET"
          echo "  Port range for this PR: $BASE_PORT-$((BASE_PORT + 9))"
      
      - name: Cleanup and start webpack server
        run: |
          # Cleanup any existing processes on this specific port (critical for self-hosted runners)
          echo "Cleaning up any existing processes on port $CYPRESS_PORT..."
          if lsof -ti:$CYPRESS_PORT > /dev/null 2>&1; then
            echo "Found processes on port $CYPRESS_PORT, killing them..."
            lsof -ti:$CYPRESS_PORT | xargs kill -9 2>/dev/null || true
            sleep 3
          else
            echo "No existing processes on port $CYPRESS_PORT"
          fi
          
          # Double-check port is free before starting
          if lsof -ti:$CYPRESS_PORT > /dev/null 2>&1; then
            echo "ERROR: Port $CYPRESS_PORT is still in use after cleanup!"
            lsof -i:$CYPRESS_PORT
            exit 1
          fi
          
          # Start server with dynamic port
          echo "Starting webpack dev server on port $CYPRESS_PORT with cluster proxy..."
          cd frontend && ODH_PORT=$CYPRESS_PORT npm run start:dev:ext &
          
          SERVER_PID=$!
          echo "SERVER_PID=$SERVER_PID" >> $GITHUB_ENV
          echo "Started webpack dev server with PID: $SERVER_PID on port $CYPRESS_PORT"
          
          echo "Giving server 15 seconds to initialize..."
          sleep 15

      - name: Wait for Server Ready
        run: |
          echo "Waiting for server on port $CYPRESS_PORT..."
          npx wait-on http://localhost:$CYPRESS_PORT --timeout 120000
          echo "Server is responding!"
          
          # Verify application HTML is served (check for static content in the shell)
          FOUND=false
          for i in {1..10}; do
            echo "Attempt $i/10: Checking for dashboard HTML shell..."
            if curl -s -f http://localhost:$CYPRESS_PORT/ | grep -q "Open Data Hub\|id=\"root\""; then
              echo "Dashboard HTML shell loaded successfully!"
              FOUND=true
              break
            fi
            [ $i -lt 10 ] && sleep 8
          done
          
          if [ "$FOUND" = false ]; then
            echo "Dashboard HTML not found after 10 attempts"
            echo "Checking what content is returned:"
            curl -s http://localhost:$CYPRESS_PORT/ | head -c 500
            exit 1
          fi

      - name: Set Test Configuration
        run: |
          # Match OLD workflow: use cluster URLs from secrets if available
          if [ -n "${{ secrets.OCP_CONSOLE_URL }}" ]; then
            sed -i.bak "s|OCP_CONSOLE_URL:.*|OCP_CONSOLE_URL: ${{ secrets.OCP_CONSOLE_URL }}|" ${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml
          fi
          if [ -n "${{ secrets.ODH_DASHBOARD_URL }}" ]; then
            sed -i.bak "s|ODH_DASHBOARD_URL:.*|ODH_DASHBOARD_URL: ${{ secrets.ODH_DASHBOARD_URL }}|" ${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml
          fi
          
          # For forked PRs, use localhost with dynamic port
          if [ -z "${{ secrets.OCP_CONSOLE_URL }}" ]; then
            echo "OCP_CONSOLE_URL secret not available (forked PR) - using localhost:$CYPRESS_PORT"
            sed -i.bak "s|OCP_CONSOLE_URL:.*|OCP_CONSOLE_URL: http://localhost:$CYPRESS_PORT|" ${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml
          fi
          if [ -z "${{ secrets.ODH_DASHBOARD_URL }}" ]; then
            echo "ODH_DASHBOARD_URL secret not available (forked PR) - using localhost:$CYPRESS_PORT"
            sed -i.bak "s|ODH_DASHBOARD_URL:.*|ODH_DASHBOARD_URL: http://localhost:$CYPRESS_PORT|" ${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml
          fi
          
          export CY_TEST_CONFIG="${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml"

      - name: Pre-test diagnostics
        run: |
          echo "=== PRE-TEST SYSTEM DIAGNOSTICS ==="
          echo ""
          echo "Runner: ${{ runner.name }}"
          echo "Job: ${{ matrix.test-tag }}"
          echo "Port: $CYPRESS_PORT"
          echo ""
          echo "File descriptor limit:"
          ulimit -n
          echo ""
          echo "File descriptors in use by current user:"
          lsof -u $(whoami) 2>/dev/null | wc -l || echo "Unable to check"
          echo ""
          echo "Existing Cypress/Electron processes (count only):"
          ps aux | grep -E "(cypress|Cypress|electron|Electron)" | grep -v grep | wc -l || echo "0"
          echo ""
          echo "Memory usage:"
          free -h || echo "Unable to check memory"
          echo ""
          echo "Disk space on /dev/shm:"
          df -h /dev/shm || echo "Unable to check"
          echo ""
          echo "Test configuration verification (localhost only):"
          ODH_URL=$(grep "ODH_DASHBOARD_URL:" ${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml | head -1)
          if echo "$ODH_URL" | grep -q "localhost"; then
            echo "  ✓ ODH_DASHBOARD_URL is set to localhost (safe)"
          else
            echo "  ✗ WARNING: ODH_DASHBOARD_URL is NOT localhost (this may cause issues)"
          fi
          echo ""
      
      - name: Run E2E Tests
        id: run-tests
        run: |
          cd frontend
          export CY_TEST_CONFIG="${{ github.workspace }}/frontend/src/__tests__/cypress/test-variables.yml"
          export CY_RESULTS_DIR="${{ github.workspace }}/frontend/src/__tests__/cypress/results/${{ matrix.test-tag }}"
          mkdir -p "$CY_RESULTS_DIR"
          
          echo "Running E2E tests on port $CYPRESS_PORT"
          echo "Test tag: ${{ matrix.test-tag }}"
          echo "Start time: $(date)"
          
          # Run tests against dynamic port
          BASE_URL=http://localhost:$CYPRESS_PORT npm run cypress:run:electron -- \
            --env skipTags="@Bug @Maintain @NonConcurrent",grepTags="${{ matrix.test-tag }}",grepFilterSpecs=true \
            --config video=true,screenshotsFolder="$CY_RESULTS_DIR/screenshots",videosFolder="$CY_RESULTS_DIR/videos" \
            2>&1 | tee /tmp/cypress-run-${{ matrix.test-tag }}.log
      
      - name: Post-test diagnostics on failure
        if: failure() && steps.run-tests.outcome == 'failure'
        run: |
          echo "=== POST-FAILURE DIAGNOSTICS ==="
          echo ""
          echo "Test failed for: ${{ matrix.test-tag }}"
          echo "Failure time: $(date)"
          echo ""
          
          echo "--- Checking for specific error patterns ---"
          if grep -qi "timed out waiting for the browser" /tmp/cypress-run-${{ matrix.test-tag }}.log 2>/dev/null; then
            echo "✗ FOUND: 'Timed out waiting for the browser to connect' error"
            echo "  Number of occurrences:"
            grep -i "timed out waiting for the browser" /tmp/cypress-run-${{ matrix.test-tag }}.log | wc -l
            echo "  Retry attempts:"
            grep -i "retrying" /tmp/cypress-run-${{ matrix.test-tag }}.log | wc -l
          else
            echo "✓ No browser connection timeout found"
          fi
          
          if grep -qi "DevTools.*disconnect\|CDP.*error\|protocol error" /tmp/cypress-run-${{ matrix.test-tag }}.log 2>/dev/null; then
            echo "✗ FOUND: DevTools/CDP protocol errors"
          fi
          
          if grep -qi "ECONNREFUSED\|ETIMEDOUT\|ENOTFOUND" /tmp/cypress-run-${{ matrix.test-tag }}.log 2>/dev/null; then
            echo "✗ FOUND: Network connection errors"
          fi
          echo ""
          
          echo "--- System state at failure ---"
          echo "Cypress/Electron processes still running (count):"
          ps aux | grep -E "(cypress|Cypress|electron|Electron)" | grep -v grep | wc -l || echo "0"
          echo ""
          echo "File descriptors in use:"
          lsof -u $(whoami) 2>/dev/null | wc -l || echo "Unable to check"
          echo ""
          echo "Server still running on port $CYPRESS_PORT?"
          if lsof -i:$CYPRESS_PORT >/dev/null 2>&1; then
            echo "Yes, server is still running"
            echo "Server response test:"
            timeout 3 curl -s -o /dev/null -w "HTTP Status: %{http_code}\n" http://localhost:$CYPRESS_PORT/ || echo "Server not responding"
          else
            echo "No server on port $CYPRESS_PORT"
          fi
          echo ""
          
          echo "--- Last 40 lines of Cypress output (sanitized) ---"
          tail -40 /tmp/cypress-run-${{ matrix.test-tag }}.log 2>/dev/null | sed 's/https:\/\/[^/]*\.[^/]*\.[^/]*\.[^/]*/https:\/\/[REDACTED]/g' || echo "Log file not found"
          echo ""

      - name: Cleanup server for this job
        if: always()
        run: |
          echo "Cleaning up server on port $CYPRESS_PORT (this job only)..."
          
          # Kill server by PID if available
          if [ -n "$SERVER_PID" ]; then
            echo "Killing server PID: $SERVER_PID"
            kill -9 $SERVER_PID 2>/dev/null || echo "PID $SERVER_PID already terminated"
          fi
          
          # Also kill by port as backup
          if lsof -ti:$CYPRESS_PORT > /dev/null 2>&1; then
            echo "Killing remaining processes on port $CYPRESS_PORT"
            lsof -ti:$CYPRESS_PORT | xargs kill -9 2>/dev/null || true
          fi
          
          echo "Cleanup complete for port $CYPRESS_PORT"

      - name: Test tag name
        if: always()
        run: |
          TEST_TAG_NAME=$(echo '${{ matrix.test-tag }}' | tr '/' '_' | tr '@' '_')
          echo "TEST_TAG_NAME=$TEST_TAG_NAME" >> $GITHUB_ENV

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results-${{ env.TEST_TAG_NAME }}-${{ github.run_id }}
          path: |
            frontend/src/__tests__/cypress/results/
          if-no-files-found: ignore
          retention-days: 7

      - name: Log test completion
        if: always()
        run: |
          echo "Test completed: ${{ matrix.test-tag }}"
          echo "Status: ${{ job.status }}"
          echo "Port used: $CYPRESS_PORT"
          echo "Run ID: ${{ github.run_id }}"

  cleanup-stale-servers:
    needs: [e2e-tests]
    runs-on: self-hosted
    if: always()
    steps:
      - name: Clean up any stale processes
        run: |
          echo "Final cleanup: removing any stale processes on self-hosted runner..."
          
          # Kill any webpack processes older than 1 hour (stale from failed runs)
          # Find processes older than 3600 seconds (1 hour)
          for pid in $(ps -eo pid,etimes,cmd | grep -E "webpack.*serve|node.*start:dev" | awk '$2 > 3600 {print $1}'); do
            echo "Killing stale process $pid (running for more than 1 hour)"
            kill -9 $pid 2>/dev/null || true
          done
          
          # Clean up any orphaned Electron/Cypress processes
          pkill -f "Cypress|Electron" 2>/dev/null || echo "No Cypress/Electron processes found"
          
          echo "Final cleanup complete"
