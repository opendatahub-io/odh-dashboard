// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v5.27.1
// source: ml_metadata/proto/metadata_store.proto

/* eslint-disable */
import Long from 'long';
import _m0 from 'protobufjs/minimal';
import { Any } from '../../google/protobuf/any';
import { Struct } from '../../google/protobuf/struct';

export const protobufPackage = 'ml_metadata';

/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ==============================================================================
 */

/** The list of supported property value types. */
export enum PropertyType {
  UNKNOWN = 0,
  INT = 1,
  DOUBLE = 2,
  STRING = 3,
  /**
   * STRUCT - Prefer to use `PROTO` to store structed data since this option has
   * inefficient database storage usage.
   */
  STRUCT = 4,
  PROTO = 5,
  BOOLEAN = 6,
  UNRECOGNIZED = -1,
}

export function propertyTypeFromJSON(object: any): PropertyType {
  switch (object) {
    case 0:
    case 'UNKNOWN':
      return PropertyType.UNKNOWN;
    case 1:
    case 'INT':
      return PropertyType.INT;
    case 2:
    case 'DOUBLE':
      return PropertyType.DOUBLE;
    case 3:
    case 'STRING':
      return PropertyType.STRING;
    case 4:
    case 'STRUCT':
      return PropertyType.STRUCT;
    case 5:
    case 'PROTO':
      return PropertyType.PROTO;
    case 6:
    case 'BOOLEAN':
      return PropertyType.BOOLEAN;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return PropertyType.UNRECOGNIZED;
  }
}

export function propertyTypeToJSON(object: PropertyType): string {
  switch (object) {
    case PropertyType.UNKNOWN:
      return 'UNKNOWN';
    case PropertyType.INT:
      return 'INT';
    case PropertyType.DOUBLE:
      return 'DOUBLE';
    case PropertyType.STRING:
      return 'STRING';
    case PropertyType.STRUCT:
      return 'STRUCT';
    case PropertyType.PROTO:
      return 'PROTO';
    case PropertyType.BOOLEAN:
      return 'BOOLEAN';
    case PropertyType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface SystemTypeExtension {
  /** The name of a system defined type. */
  typeName?: string | undefined;
}

/** A value in properties. */
export interface Value {
  intValue?: number | undefined;
  doubleValue?: number | undefined;
  stringValue?: string | undefined;
  structValue?: { [key: string]: any } | undefined;
  protoValue?: Any | undefined;
  boolValue?: boolean | undefined;
}

export interface Artifact {
  /** Output only. The unique server generated id of the artifact. */
  id?: number | undefined;
  /**
   * The client provided name of the artifact. This field is optional. If set,
   * it must be unique among all the artifacts of the same artifact type within
   * a database instance and cannot be changed once set.
   */
  name?: string | undefined;
  /**
   * The id of an ArtifactType. This needs to be specified when an artifact is
   * created, and it cannot be changed.
   */
  typeId?: number | undefined;
  /** Output only. The name of an ArtifactType. */
  type?: string | undefined;
  /**
   * The uniform resource identifier of the physical artifact.
   * May be empty if there is no physical artifact.
   */
  uri?: string | undefined;
  /**
   * The external id that come from the clients’ system. This field is optional.
   * If set, it must be unique among all artifacts within a database instance.
   */
  externalId?: string | undefined;
  /**
   * Properties of the artifact.
   * Properties must be specified in the ArtifactType.
   */
  properties: { [key: string]: Value };
  /** User provided custom properties which are not defined by its type. */
  customProperties: { [key: string]: Value };
  /** The state of the artifact known to the system. */
  state?: Artifact_State | undefined;
  /** Output only. Create time of the artifact in millisecond since epoch. */
  createTimeSinceEpoch?: number | undefined;
  /**
   * Output only. Last update time of the artifact since epoch in millisecond
   * since epoch.
   */
  lastUpdateTimeSinceEpoch?: number | undefined;
  /** Output only. */
  systemMetadata?: Any | undefined;
}

export enum Artifact_State {
  UNKNOWN = 0,
  /** PENDING - A state indicating that the artifact may exist. */
  PENDING = 1,
  /**
   * LIVE - A state indicating that the artifact should exist, unless something
   * external to the system deletes it.
   */
  LIVE = 2,
  /** MARKED_FOR_DELETION - A state indicating that the artifact should be deleted. */
  MARKED_FOR_DELETION = 3,
  /** DELETED - A state indicating that the artifact has been deleted. */
  DELETED = 4,
  /**
   * ABANDONED - A state indicating that the artifact has been abandoned, which may be
   * due to a failed or cancelled execution.
   */
  ABANDONED = 5,
  /**
   * REFERENCE - A state indicating that the artifact is a reference artifact. At
   * execution start time, the orchestrator produces an output artifact for
   * each output key with state PENDING. However, for an intermediate
   * artifact, this first artifact's state will be REFERENCE. Intermediate
   * artifacts emitted during a component's execution will copy the REFERENCE
   * artifact's attributes. At the end of an execution, the artifact state
   * should remain REFERENCE instead of being changed to LIVE.
   */
  REFERENCE = 6,
  UNRECOGNIZED = -1,
}

export function artifact_StateFromJSON(object: any): Artifact_State {
  switch (object) {
    case 0:
    case 'UNKNOWN':
      return Artifact_State.UNKNOWN;
    case 1:
    case 'PENDING':
      return Artifact_State.PENDING;
    case 2:
    case 'LIVE':
      return Artifact_State.LIVE;
    case 3:
    case 'MARKED_FOR_DELETION':
      return Artifact_State.MARKED_FOR_DELETION;
    case 4:
    case 'DELETED':
      return Artifact_State.DELETED;
    case 5:
    case 'ABANDONED':
      return Artifact_State.ABANDONED;
    case 6:
    case 'REFERENCE':
      return Artifact_State.REFERENCE;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return Artifact_State.UNRECOGNIZED;
  }
}

export function artifact_StateToJSON(object: Artifact_State): string {
  switch (object) {
    case Artifact_State.UNKNOWN:
      return 'UNKNOWN';
    case Artifact_State.PENDING:
      return 'PENDING';
    case Artifact_State.LIVE:
      return 'LIVE';
    case Artifact_State.MARKED_FOR_DELETION:
      return 'MARKED_FOR_DELETION';
    case Artifact_State.DELETED:
      return 'DELETED';
    case Artifact_State.ABANDONED:
      return 'ABANDONED';
    case Artifact_State.REFERENCE:
      return 'REFERENCE';
    case Artifact_State.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface Artifact_PropertiesEntry {
  key: string;
  value: Value | undefined;
}

export interface Artifact_CustomPropertiesEntry {
  key: string;
  value: Value | undefined;
}

export interface ArtifactType {
  /** The id of the type. 1-1 relationship between type names and IDs. */
  id?: number | undefined;
  /**
   * The name of the type. It must be unique among ArtifactTypes within a
   * database instance.
   */
  name?: string | undefined;
  /** An optional version of the type. An empty string is treated as unset. */
  version?: string | undefined;
  /** An optional description about the type. */
  description?: string | undefined;
  /**
   * The external id that come from the clients’ system. This field is optional.
   * If set, it must be unique among all artifact types within a database
   * instance.
   */
  externalId?: string | undefined;
  /**
   * The schema of the type.
   * Properties are always optional in the artifact.
   * Properties of an artifact type can be expanded but not contracted (i.e.,
   * you can add columns but not remove them).
   */
  properties: { [key: string]: PropertyType };
  /**
   * An optional system defined base_type expressing the intent of the current
   * type. This field is useful for the tool builders to utilize the stored MLMD
   * information, e.g., `MyModel` ArtifactType could set base_type = MODEL.
   */
  baseType?: ArtifactType_SystemDefinedBaseType | undefined;
}

/** An enum of system-defined artifact types. */
export enum ArtifactType_SystemDefinedBaseType {
  UNSET = 0,
  DATASET = 1,
  MODEL = 2,
  METRICS = 3,
  STATISTICS = 4,
  UNRECOGNIZED = -1,
}

export function artifactType_SystemDefinedBaseTypeFromJSON(
  object: any,
): ArtifactType_SystemDefinedBaseType {
  switch (object) {
    case 0:
    case 'UNSET':
      return ArtifactType_SystemDefinedBaseType.UNSET;
    case 1:
    case 'DATASET':
      return ArtifactType_SystemDefinedBaseType.DATASET;
    case 2:
    case 'MODEL':
      return ArtifactType_SystemDefinedBaseType.MODEL;
    case 3:
    case 'METRICS':
      return ArtifactType_SystemDefinedBaseType.METRICS;
    case 4:
    case 'STATISTICS':
      return ArtifactType_SystemDefinedBaseType.STATISTICS;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return ArtifactType_SystemDefinedBaseType.UNRECOGNIZED;
  }
}

export function artifactType_SystemDefinedBaseTypeToJSON(
  object: ArtifactType_SystemDefinedBaseType,
): string {
  switch (object) {
    case ArtifactType_SystemDefinedBaseType.UNSET:
      return 'UNSET';
    case ArtifactType_SystemDefinedBaseType.DATASET:
      return 'DATASET';
    case ArtifactType_SystemDefinedBaseType.MODEL:
      return 'MODEL';
    case ArtifactType_SystemDefinedBaseType.METRICS:
      return 'METRICS';
    case ArtifactType_SystemDefinedBaseType.STATISTICS:
      return 'STATISTICS';
    case ArtifactType_SystemDefinedBaseType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface ArtifactType_PropertiesEntry {
  key: string;
  value: PropertyType;
}

/**
 * An event represents a relationship between an artifact and an execution.
 * There are different kinds of events, relating to both input and output, as
 * well as how they are used by the mlmd powered system.
 * For example, the DECLARED_INPUT and DECLARED_OUTPUT events are part of the
 * signature of an execution. For example, consider:
 *
 *   my_result = my_execution({"data":[3,7],"schema":8})
 *
 * Where 3, 7, and 8 are artifact_ids, Assuming execution_id of my_execution is
 * 12 and artifact_id of my_result is 15, the events are:
 *   {
 *       artifact_id:3,
 *       execution_id: 12,
 *       type:DECLARED_INPUT,
 *       path:{step:[{"key":"data"},{"index":0}]}
 *   }
 *   {
 *       artifact_id:7,
 *       execution_id: 12,
 *       type:DECLARED_INPUT,
 *       path:{step:[{"key":"data"},{"index":1}]}
 *   }
 *   {
 *       artifact_id:8,
 *       execution_id: 12,
 *       type:DECLARED_INPUT,
 *       path:{step:[{"key":"schema"}]}
 *   }
 *   {
 *       artifact_id:15,
 *       execution_id: 12,
 *       type:DECLARED_OUTPUT,
 *       path:{step:[{"key":"my_result"}]}
 *   }
 *
 * Other event types include INPUT/OUTPUT, INTERNAL_INPUT/_OUTPUT and
 * PENDING_OUTPUT:
 *
 * * The INPUT/OUTPUT is an event that actually reads/writes an artifact by an
 *   execution. The input/output artifacts may not declared in the signature,
 *   For example, the trainer may output multiple caches of the parameters
 *   (as an OUTPUT), then finally write the SavedModel as a DECLARED_OUTPUT.
 *
 * * The INTERNAL_INPUT/_OUTPUT are event types which are only meaningful to
 *   an orchestration system to keep track of the details for later debugging.
 *   For example, a fork happened conditioning on an artifact, then an execution
 *   is triggered, such fork implementing may need to log the read and write
 *   of artifacts and may not be worth displaying to the users.
 *
 *   For instance, in the above example,
 *
 *     my_result = my_execution({"data":[3,7],"schema":8})
 *
 *   there is another execution (id: 15), which represents a
 *   `garbage_collection` step in an orchestration system
 *
 *     gc_result = garbage_collection(my_result)
 *
 *   that cleans `my_result` if needed. The details should be invisible to the
 *   end users and lineage tracking. The orchestrator can emit following events:
 *
 *     {
 *         artifact_id: 15,
 *         execution_id: 15,
 *         type:INTERNAL_INPUT,
 *     }
 *     {
 *         artifact_id:16,  // New artifact containing the GC job result.
 *         execution_id: 15,
 *         type:INTERNAL_OUTPUT,
 *         path:{step:[{"key":"gc_result"}]}
 *     }
 *
 * * The PENDING_OUTPUT event is used to indicate that an artifact is
 *   tentatively associated with an active execution which has not yet been
 *   finalized. For example, an orchestration system can register output
 *   artifacts of a running execution with PENDING_OUTPUT events to indicate
 *   the output artifacts the execution is expected to produce. When the
 *   execution is finished, the final set of output artifacts can be associated
 *   with the exeution using OUTPUT events, and any unused artifacts which were
 *   previously registered with PENDING_OUTPUT events can be updated to set
 *   their Artifact.State to ABANDONED.
 *
 * Events are unique of the same
 * (artifact_id, execution_id, type) combination within a metadata store.
 */
export interface Event {
  /**
   * The artifact id is required for an event, and should refer to an
   * existing artifact.
   */
  artifactId?: number | undefined;
  /**
   * The execution_id is required for an event, and should refer to an
   * existing execution.
   */
  executionId?: number | undefined;
  /** The path in an artifact struct, or the name of an artifact. */
  path?: Event_Path | undefined;
  /** The type of an event. */
  type?: Event_Type | undefined;
  /**
   * Time the event occurred
   * Epoch is Jan 1, 1970, UTC
   */
  millisecondsSinceEpoch?: number | undefined;
  /** Output only. */
  systemMetadata?: Any | undefined;
}

/**
 * Events distinguish between an artifact that is written by the execution
 * (possibly as a cache), versus artifacts that are part of the declared
 * output of the Execution. For more information on what DECLARED_ means,
 * see the comment on the message.
 */
export enum Event_Type {
  UNKNOWN = 0,
  /** DECLARED_OUTPUT - A declared output of the execution. */
  DECLARED_OUTPUT = 1,
  /** DECLARED_INPUT - A declared input of the execution. */
  DECLARED_INPUT = 2,
  /** INPUT - An input of the execution. */
  INPUT = 3,
  /** OUTPUT - An output of the execution. */
  OUTPUT = 4,
  /** INTERNAL_INPUT - An internal input of the execution. */
  INTERNAL_INPUT = 5,
  /** INTERNAL_OUTPUT - An internal output of the execution. */
  INTERNAL_OUTPUT = 6,
  /** PENDING_OUTPUT - A pending output of the execution. */
  PENDING_OUTPUT = 7,
  UNRECOGNIZED = -1,
}

export function event_TypeFromJSON(object: any): Event_Type {
  switch (object) {
    case 0:
    case 'UNKNOWN':
      return Event_Type.UNKNOWN;
    case 1:
    case 'DECLARED_OUTPUT':
      return Event_Type.DECLARED_OUTPUT;
    case 2:
    case 'DECLARED_INPUT':
      return Event_Type.DECLARED_INPUT;
    case 3:
    case 'INPUT':
      return Event_Type.INPUT;
    case 4:
    case 'OUTPUT':
      return Event_Type.OUTPUT;
    case 5:
    case 'INTERNAL_INPUT':
      return Event_Type.INTERNAL_INPUT;
    case 6:
    case 'INTERNAL_OUTPUT':
      return Event_Type.INTERNAL_OUTPUT;
    case 7:
    case 'PENDING_OUTPUT':
      return Event_Type.PENDING_OUTPUT;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return Event_Type.UNRECOGNIZED;
  }
}

export function event_TypeToJSON(object: Event_Type): string {
  switch (object) {
    case Event_Type.UNKNOWN:
      return 'UNKNOWN';
    case Event_Type.DECLARED_OUTPUT:
      return 'DECLARED_OUTPUT';
    case Event_Type.DECLARED_INPUT:
      return 'DECLARED_INPUT';
    case Event_Type.INPUT:
      return 'INPUT';
    case Event_Type.OUTPUT:
      return 'OUTPUT';
    case Event_Type.INTERNAL_INPUT:
      return 'INTERNAL_INPUT';
    case Event_Type.INTERNAL_OUTPUT:
      return 'INTERNAL_OUTPUT';
    case Event_Type.PENDING_OUTPUT:
      return 'PENDING_OUTPUT';
    case Event_Type.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

/**
 * A simple path (e.g. {step{key:"foo"}}) can name an artifact in the context
 * of an execution.
 */
export interface Event_Path {
  /**
   * A simple path (e.g. {step{key:"foo"}}) can name an artifact in the
   * context of an execution.
   */
  steps: Event_Path_Step[];
}

export interface Event_Path_Step {
  index?: number | undefined;
  key?: string | undefined;
}

export interface Execution {
  /** Output only. The unique server generated id of the execution. */
  id?: number | undefined;
  /**
   * The client provided name of the execution. This field is optional. If set,
   * it must be unique among all the executions of the same execution type
   * within a database instance and cannot be changed once set.
   */
  name?: string | undefined;
  /**
   * The id of an ExecutionType. This needs to be specified when an execution is
   * created, and it cannot be changed.
   * The id of an ExecutionType.
   */
  typeId?: number | undefined;
  /** Output only. The name of an ExecutionType. */
  type?: string | undefined;
  /**
   * The external id that come from the clients’ system. This field is optional.
   * If set, it must be unique among all executions within a database instance.
   */
  externalId?: string | undefined;
  /** The last known state of an execution in the system. */
  lastKnownState?: Execution_State | undefined;
  /**
   * Properties of the Execution.
   * Properties must be specified in the ExecutionType.
   */
  properties: { [key: string]: Value };
  /** User provided custom properties which are not defined by its type. */
  customProperties: { [key: string]: Value };
  /** Output only. Create time of the execution in millisecond since epoch. */
  createTimeSinceEpoch?: number | undefined;
  /** Output only. Last update time of the execution in millisecond since epoch. */
  lastUpdateTimeSinceEpoch?: number | undefined;
  /** Output only. */
  systemMetadata?: Any | undefined;
}

/**
 * The state of the Execution. The state transitions are
 *   NEW -> RUNNING -> COMPLETE | CACHED | FAILED | CANCELED
 * CACHED means the execution is skipped due to cached results.
 * CANCELED means the execution is skipped due to precondition not met. It is
 * different from CACHED in that a CANCELED execution will not have any event
 * associated with it. It is different from FAILED in that there is no
 * unexpected error happened and it is regarded as a normal state.
 */
export enum Execution_State {
  UNKNOWN = 0,
  NEW = 1,
  RUNNING = 2,
  COMPLETE = 3,
  FAILED = 4,
  CACHED = 5,
  CANCELED = 6,
  UNRECOGNIZED = -1,
}

export function execution_StateFromJSON(object: any): Execution_State {
  switch (object) {
    case 0:
    case 'UNKNOWN':
      return Execution_State.UNKNOWN;
    case 1:
    case 'NEW':
      return Execution_State.NEW;
    case 2:
    case 'RUNNING':
      return Execution_State.RUNNING;
    case 3:
    case 'COMPLETE':
      return Execution_State.COMPLETE;
    case 4:
    case 'FAILED':
      return Execution_State.FAILED;
    case 5:
    case 'CACHED':
      return Execution_State.CACHED;
    case 6:
    case 'CANCELED':
      return Execution_State.CANCELED;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return Execution_State.UNRECOGNIZED;
  }
}

export function execution_StateToJSON(object: Execution_State): string {
  switch (object) {
    case Execution_State.UNKNOWN:
      return 'UNKNOWN';
    case Execution_State.NEW:
      return 'NEW';
    case Execution_State.RUNNING:
      return 'RUNNING';
    case Execution_State.COMPLETE:
      return 'COMPLETE';
    case Execution_State.FAILED:
      return 'FAILED';
    case Execution_State.CACHED:
      return 'CACHED';
    case Execution_State.CANCELED:
      return 'CANCELED';
    case Execution_State.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface Execution_PropertiesEntry {
  key: string;
  value: Value | undefined;
}

export interface Execution_CustomPropertiesEntry {
  key: string;
  value: Value | undefined;
}

export interface ExecutionType {
  /** The id of the type. 1-1 relationship between type names and IDs. */
  id?: number | undefined;
  /**
   * The name of the type. It must be unique among ExecutionTypes within a
   * database instance.
   */
  name?: string | undefined;
  /** An optional version of the type. An empty string is treated as unset. */
  version?: string | undefined;
  /** An optional description about the type. */
  description?: string | undefined;
  /**
   * The external id that come from the clients’ system. This field is optional.
   * If set, it must be unique among all execution types within a database
   * instance.
   */
  externalId?: string | undefined;
  /**
   * The schema of the type.
   * Properties are always optional in the execution.
   */
  properties: { [key: string]: PropertyType };
  /**
   * The ArtifactStructType of the input.
   * For example: {
   *     "dict":{
   *        "properties":{
   *          "schema":{
   *            "union_type":{
   *              "none":{},
   *              "simple":{...schema type...}
   *             },
   *          },
   *          "data":{
   *            "simple":{...data_type...}
   *          }
   *       }
   *     }
   * }
   * That would be an optional schema field with a required data field.
   */
  inputType?: ArtifactStructType | undefined;
  /**
   * The ArtifactStructType of the output.
   * For example {"simple":{...stats gen output type...}}
   */
  outputType?: ArtifactStructType | undefined;
  /**
   * An optional system defined base_type expressing the intent of the current
   * type. This field is useful for the tool builders to utilize the stored MLMD
   * information, e.g., `MyTrainer` ExecutionType could set base_type = TRAIN.
   */
  baseType?: ExecutionType_SystemDefinedBaseType | undefined;
}

/** An enum of system-defined execution types. */
export enum ExecutionType_SystemDefinedBaseType {
  UNSET = 0,
  TRAIN = 1,
  TRANSFORM = 2,
  PROCESS = 3,
  EVALUATE = 4,
  DEPLOY = 5,
  UNRECOGNIZED = -1,
}

export function executionType_SystemDefinedBaseTypeFromJSON(
  object: any,
): ExecutionType_SystemDefinedBaseType {
  switch (object) {
    case 0:
    case 'UNSET':
      return ExecutionType_SystemDefinedBaseType.UNSET;
    case 1:
    case 'TRAIN':
      return ExecutionType_SystemDefinedBaseType.TRAIN;
    case 2:
    case 'TRANSFORM':
      return ExecutionType_SystemDefinedBaseType.TRANSFORM;
    case 3:
    case 'PROCESS':
      return ExecutionType_SystemDefinedBaseType.PROCESS;
    case 4:
    case 'EVALUATE':
      return ExecutionType_SystemDefinedBaseType.EVALUATE;
    case 5:
    case 'DEPLOY':
      return ExecutionType_SystemDefinedBaseType.DEPLOY;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return ExecutionType_SystemDefinedBaseType.UNRECOGNIZED;
  }
}

export function executionType_SystemDefinedBaseTypeToJSON(
  object: ExecutionType_SystemDefinedBaseType,
): string {
  switch (object) {
    case ExecutionType_SystemDefinedBaseType.UNSET:
      return 'UNSET';
    case ExecutionType_SystemDefinedBaseType.TRAIN:
      return 'TRAIN';
    case ExecutionType_SystemDefinedBaseType.TRANSFORM:
      return 'TRANSFORM';
    case ExecutionType_SystemDefinedBaseType.PROCESS:
      return 'PROCESS';
    case ExecutionType_SystemDefinedBaseType.EVALUATE:
      return 'EVALUATE';
    case ExecutionType_SystemDefinedBaseType.DEPLOY:
      return 'DEPLOY';
    case ExecutionType_SystemDefinedBaseType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface ExecutionType_PropertiesEntry {
  key: string;
  value: PropertyType;
}

export interface ContextType {
  /** The id of the type. 1-1 relationship between type names and IDs. */
  id?: number | undefined;
  /**
   * The name of the type, e.g., Pipeline, Task, Session, User, etc. It must be
   * unique among ContextTypes within a database instance.
   */
  name?: string | undefined;
  /** An optional version of the type. An empty string is treated as unset. */
  version?: string | undefined;
  /** An optional description about the type. */
  description?: string | undefined;
  /**
   * The external id that come from the clients’ system. This field is optional.
   * If set, it must be unique among all context types within a database
   * instance.
   */
  externalId?: string | undefined;
  /**
   * The schema of the type, e.g., name: string, owner: string
   * Properties are always optional in the context.
   * Properties of an context type can be expanded but not contracted (i.e.,
   * you can add columns but not remove them).
   */
  properties: { [key: string]: PropertyType };
  /**
   * An optional system defined base_type expressing the intent of the current
   * context type.
   * *NOTE: currently there are no system Context types defined, and the field
   * is not used for ContextType.
   */
  baseType?: ContextType_SystemDefinedBaseType | undefined;
}

/** An enum of system-defined context types. */
export enum ContextType_SystemDefinedBaseType {
  UNSET = 0,
  UNRECOGNIZED = -1,
}

export function contextType_SystemDefinedBaseTypeFromJSON(
  object: any,
): ContextType_SystemDefinedBaseType {
  switch (object) {
    case 0:
    case 'UNSET':
      return ContextType_SystemDefinedBaseType.UNSET;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return ContextType_SystemDefinedBaseType.UNRECOGNIZED;
  }
}

export function contextType_SystemDefinedBaseTypeToJSON(
  object: ContextType_SystemDefinedBaseType,
): string {
  switch (object) {
    case ContextType_SystemDefinedBaseType.UNSET:
      return 'UNSET';
    case ContextType_SystemDefinedBaseType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface ContextType_PropertiesEntry {
  key: string;
  value: PropertyType;
}

export interface Context {
  /** Output Only. The unique server generated id of the context. */
  id?: number | undefined;
  /**
   * The client provided name of the context. It must be unique within a
   * database instance.
   */
  name?: string | undefined;
  /**
   * The id of a ContextType. This needs to be specified when a context is
   * created, and it cannot be changed.
   */
  typeId?: number | undefined;
  /** Output only. The name of a ContextType. */
  type?: string | undefined;
  /**
   * The external id that come from the clients’ system. This field is optional.
   * If set, it must be unique among all contexts within a virtual database.
   */
  externalId?: string | undefined;
  /** Values of the properties, which must be specified in the ContextType. */
  properties: { [key: string]: Value };
  /** User provided custom properties which are not defined by its type. */
  customProperties: { [key: string]: Value };
  /** Output only. Create time of the context in millisecond since epoch. */
  createTimeSinceEpoch?: number | undefined;
  /** Output only. Last update time of the context in millisecond since epoch. */
  lastUpdateTimeSinceEpoch?: number | undefined;
  /** Output only system metadata. */
  systemMetadata?: Any | undefined;
}

export interface Context_PropertiesEntry {
  key: string;
  value: Value | undefined;
}

export interface Context_CustomPropertiesEntry {
  key: string;
  value: Value | undefined;
}

/** the Attribution edges between Context and Artifact instances. */
export interface Attribution {
  artifactId?: number | undefined;
  contextId?: number | undefined;
}

/** the Association edges between Context and Execution instances. */
export interface Association {
  executionId?: number | undefined;
  contextId?: number | undefined;
}

/** the Parental Context edges between Context and Context instances. */
export interface ParentContext {
  childId?: number | undefined;
  parentId?: number | undefined;
}

/**
 * A self-contained provenance (sub)graph representation consists of MLMD nodes
 * and their relationships. It is used to represent the query results from the
 * persistent backend (e.g., lineage about a node, reachability of two nodes).
 */
export interface LineageGraph {
  /** extracted types */
  artifactTypes: ArtifactType[];
  executionTypes: ExecutionType[];
  contextTypes: ContextType[];
  /** extracted nodes */
  artifacts: Artifact[];
  executions: Execution[];
  contexts: Context[];
  /** extracted edges */
  events: Event[];
  attributions: Attribution[];
  associations: Association[];
}

/**
 * The list of ArtifactStruct is EXPERIMENTAL and not in use yet.
 * The type of an ArtifactStruct.
 * An artifact struct type represents an infinite set of artifact structs.
 * It can specify the input or output type of an ExecutionType.
 * See the more specific types referenced in the message for more details.
 */
export interface ArtifactStructType {
  /** Matches exactly this type. */
  simple?: ArtifactType | undefined;
  unionType?: UnionArtifactStructType | undefined;
  intersection?: IntersectionArtifactStructType | undefined;
  list?: ListArtifactStructType | undefined;
  none?: NoneArtifactStructType | undefined;
  any?: AnyArtifactStructType | undefined;
  tuple?: TupleArtifactStructType | undefined;
  dict?: DictArtifactStructType | undefined;
}

/** Represents a union of types. */
export interface UnionArtifactStructType {
  /**
   * An artifact struct matches this type if it matches any of the candidates.
   * If candidates is empty, this is a bottom type (matches no artifacts).
   */
  candidates: ArtifactStructType[];
}

/**
 * A member of this type must satisfy all constraints.
 * This primarily useful not as an end-user type, but something calculated
 * as an intermediate type in the system.
 *
 * For example, suppose you have a method:
 * def infer_my_input_type(a): # try to infer the input type of this method.
 *   use_in_method_x(a) # with input type x_input
 *   use_in_method_y(a) # with input type y_input
 *
 * Given this information, you know that infer_my_input_type has
 * type {"intersection":{"constraints":[x_input, y_input]}}.
 *
 * IntersectionArtifactStructType intersection_type = {"constraints":[
 *     {"dict":{"properties":{"schema":{"any":{}}},
 *              "extra_properties":{"any":{}}}},
 *     {"dict":{"properties":{"data":{"any":{}}},
 *              "extra_properties":{"any":{}}}}]}
 * Since the first constraint requires the dictionary to have a schema
 * property, and the second constraint requires it to have a data property, this
 * is equivalent to:
 * ArtifactStructType other_type =
 *      {"dict":{"properties":{"schema":{"any":{}},"data":{"any":{}}}},
 *       "extra_properties":{"any":{}}}
 */
export interface IntersectionArtifactStructType {
  constraints: ArtifactStructType[];
}

/** Represents an ArtifactStruct list type with homogeneous elements. */
export interface ListArtifactStructType {
  /**
   * Every entry in the list must be of this type.
   * Note: if this type is Any, then the list can have arbitrary elements.
   */
  element?: ArtifactStructType | undefined;
}

/**
 * The only member of this type is a None artifact.
 * Note: ArtifactStruct{} is a None artifact.
 * This can represent an execution that has no outputs (or inputs),
 * or can be part of a UnionArtifactStructType to represent an optional
 * input.
 * For example, StatsGen has an "optional" schema input.
 * A practical example of this is:
 * stats_gen_type = {
 *     "dict":{
 *        "properties":{
 *          "schema":{
 *            "union_type":{
 *              "none":{},
 *              "simple":{...schema type...}
 *             },
 *          },
 *          "data":{
 *            "simple":{...data_type...}
 *          }
 *       }
 *     }
 * };
 */
export interface NoneArtifactStructType {}

/** Every ArtifactStruct is a member of this type. */
export interface AnyArtifactStructType {}

/**
 * An ordered list of heterogeneous artifact structs.
 * The length of the list is fixed.
 * Each position in the list can have a different type.
 */
export interface TupleArtifactStructType {
  elements: ArtifactStructType[];
}

/**
 * A artifact struct type that represents a record or struct-like dictionary.
 * ArtifactStruct would be map (i.e. ArtifactStructMap)
 */
export interface DictArtifactStructType {
  /** Underlying properties for the type. */
  properties: { [key: string]: ArtifactStructType };
  /**
   * If true, then if properties["foo"] can be None, then that key is not
   * required.
   */
  noneTypeNotRequired?: boolean | undefined;
  /**
   * Extra keys are allowed that are not specified in properties. These
   * keys must have the type specified below.
   * If this is not specified, then extra properties are not allowed.
   */
  extraPropertiesType?: ArtifactStructType | undefined;
}

export interface DictArtifactStructType_PropertiesEntry {
  key: string;
  value: ArtifactStructType | undefined;
}

/**
 * Configuration for a "fake" database.
 * This database is an in-memory SQLite database that lives only as
 * long as the associated object lives.
 */
export interface FakeDatabaseConfig {}

export interface MySQLDatabaseConfig {
  /**
   * The hostname or IP address of the MYSQL server:
   * * If unspecified, a connection to the local host is assumed.
   *   The client connects using a Unix socket specified by `socket`.
   * * Otherwise, TCP/IP is used.
   * Currently a replicated MYSQL backend is not supported.
   */
  host?: string | undefined;
  /**
   * The TCP Port number that the MYSQL server accepts connections on.
   * If unspecified, the default MYSQL port (3306) is used.
   */
  port?: number | undefined;
  /**
   * The database to connect to. Must be specified.
   * After connecting to the MYSQL server, this database is created if not
   * already present unless skip_db_creation is set.
   * All queries after Connect() are assumed to be for this database.
   */
  database?: string | undefined;
  /** The MYSQL login id. If empty, the current user is assumed. */
  user?: string | undefined;
  /**
   * The password to use for `user`. If empty, only MYSQL user ids that don't
   * have a password set are allowed to connect.
   */
  password?: string | undefined;
  /**
   * The Unix socket to use to connect to the server. If unspecified, a
   * `host` must be provided.
   */
  socket?: string | undefined;
  /**
   * If the field is set, the ssl options are set in mysql_options before
   * establishing a connection. It is ignored if the mysql server does not
   * enable SSL.
   */
  sslOptions?: MySQLDatabaseConfig_SSLOptions | undefined;
  /**
   * A config to skip the database creation if not exist when connecting the
   * db instance. It is useful when the db creation is handled by an admin
   * process, while the lib user should not issue db creation clauses.
   */
  skipDbCreation?: boolean | undefined;
}

/** The options to establish encrypted connections to MySQL using SSL. */
export interface MySQLDatabaseConfig_SSLOptions {
  /** The path name of the client private key file. */
  key?: string | undefined;
  /** The path name of the client public key certificate file. */
  cert?: string | undefined;
  /** The path name of the CA certificate file. */
  ca?: string | undefined;
  /** The path name of the directory that contains trusted SSL CA certificates. */
  capath?: string | undefined;
  /** The list of permissible ciphers for SSL encryption. */
  cipher?: string | undefined;
  /**
   * If set, enable verification of the server certificate against the host
   * name used when connecting to the server.
   */
  verifyServerCert?: boolean | undefined;
}

/** A config contains the parameters when using with SqliteMetadatSource. */
export interface SqliteMetadataSourceConfig {
  /**
   * A uri specifying Sqlite3 database filename, for example:
   *
   *   file:some_sqlite3_file_in_local_dir.db
   *   file:///home/username/some_sqlite3_file.db
   *
   * see https://www.sqlite.org/c3ref/open.html for model details
   *
   * If not given, a in-memory sqlite3 database is used, and destroyed when
   * disconnecting the metadata source.
   */
  filenameUri?: string | undefined;
  /**
   * A flag specifying the connection mode. If not given, default connection
   * mode is set to READWRITE_OPENCREATE.
   */
  connectionMode?: SqliteMetadataSourceConfig_ConnectionMode | undefined;
}

/** Connection parameters for SQLite3 based metadata source. */
export enum SqliteMetadataSourceConfig_ConnectionMode {
  UNKNOWN = 0,
  /**
   * READONLY - Connect a metadata source in read-only mode. Connection fail if the
   * sqlite3 database at the `filename` does not exist. Any queries modifying
   * the database fail.
   */
  READONLY = 1,
  /**
   * READWRITE - Connect a metadata source in read/write mode. Connection fail if the
   * sqlite3 database at the `filename` does not exist.
   */
  READWRITE = 2,
  /**
   * READWRITE_OPENCREATE - Similar to READWRITE. In addition, it creates the database if it does not
   * exist.
   */
  READWRITE_OPENCREATE = 3,
  UNRECOGNIZED = -1,
}

export function sqliteMetadataSourceConfig_ConnectionModeFromJSON(
  object: any,
): SqliteMetadataSourceConfig_ConnectionMode {
  switch (object) {
    case 0:
    case 'UNKNOWN':
      return SqliteMetadataSourceConfig_ConnectionMode.UNKNOWN;
    case 1:
    case 'READONLY':
      return SqliteMetadataSourceConfig_ConnectionMode.READONLY;
    case 2:
    case 'READWRITE':
      return SqliteMetadataSourceConfig_ConnectionMode.READWRITE;
    case 3:
    case 'READWRITE_OPENCREATE':
      return SqliteMetadataSourceConfig_ConnectionMode.READWRITE_OPENCREATE;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return SqliteMetadataSourceConfig_ConnectionMode.UNRECOGNIZED;
  }
}

export function sqliteMetadataSourceConfig_ConnectionModeToJSON(
  object: SqliteMetadataSourceConfig_ConnectionMode,
): string {
  switch (object) {
    case SqliteMetadataSourceConfig_ConnectionMode.UNKNOWN:
      return 'UNKNOWN';
    case SqliteMetadataSourceConfig_ConnectionMode.READONLY:
      return 'READONLY';
    case SqliteMetadataSourceConfig_ConnectionMode.READWRITE:
      return 'READWRITE';
    case SqliteMetadataSourceConfig_ConnectionMode.READWRITE_OPENCREATE:
      return 'READWRITE_OPENCREATE';
    case SqliteMetadataSourceConfig_ConnectionMode.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

/**
 * A config contains the parameters when using with PostgreSQLMetadatSource.
 * Next index: 10
 */
export interface PostgreSQLDatabaseConfig {
  /**
   * Name of host to connect to. If the host name starts with /, it is taken as
   * a Unix-domain socket in the abstract namespace.
   */
  host?: string | undefined;
  /**
   * Numeric IP address of host to connect to. If this field is provided, `host`
   * field is ignored.
   */
  hostaddr?: string | undefined;
  /**
   * Port number to connect to at the server host, or socket file name extension
   * for Unix-domain connections.
   */
  port?: string | undefined;
  /**
   * PostgreSQL user name to connect as. Defaults to be the same as the
   * operating system name of the user running the application.
   */
  user?: string | undefined;
  /** Password to be used if the server demands password authentication. */
  password?: string | undefined;
  /** Specifies the name of the file used to store passwords. */
  passfile?: string | undefined;
  /** The database name. Defaults to be the same as the user name. */
  dbname?: string | undefined;
  /**
   * A config to skip the database creation if not exist when connecting the
   * db instance. It is useful when the db creation is handled by an admin
   * process, while the lib user should not issue db creation clauses.
   */
  skipDbCreation?: boolean | undefined;
  ssloption?: PostgreSQLDatabaseConfig_SSLOptions | undefined;
}

export interface PostgreSQLDatabaseConfig_SSLOptions {
  /**
   * disable, allow, verify-ca, verify-full, etc. Reference:
   * https://www.postgresql.org/docs/current/libpq-connect.html
   */
  sslmode?: string | undefined;
  /**
   * This parameter specifies the file name of the client SSL certificate,
   * replacing the default ~/.postgresql/postgresql.crt. This parameter is
   * ignored if an SSL connection is not made.
   */
  sslcert?: string | undefined;
  /**
   * This parameter specifies the location for the secret key used for the
   * client certificate. It can either specify a file name that will be used
   * instead of the default ~/.postgresql/postgresql.key, this parameter is
   * ignored if an SSL connection is not made.
   */
  sslkey?: string | undefined;
  /**
   * This parameter specifies the password for the secret key specified in
   * sslkey, allowing client certificate private keys to be stored in
   * encrypted form on disk even when interactive passphrase input is not
   * practical.
   */
  sslpassword?: string | undefined;
  /**
   * This parameter specifies the name of a file containing SSL certificate
   * authority (CA) certificate(s). If the file exists, the server's
   * certificate will be verified to be signed by one of these authorities.
   * The default is ~/.postgresql/root.crt.
   */
  sslrootcert?: string | undefined;
}

export interface MigrationOptions {
  /**
   * If not set, by default the upgrade migration is disabled. MLMD only
   * compares db_v with the lib_v, and raise error if the two do not align.
   * If the field is set to true, MLMD performs upgrade migration. It upgrades
   * the database schema version (db_v) to align with the library schema
   * version (lib_v) when connecting to the database.
   * Schema migration should not be run concurrently with multiple clients to
   * prevent data races.
   */
  enableUpgradeMigration?: boolean | undefined;
  /**
   * Downgrade the given database to the specified schema version.
   * For v0.13.2 release, the schema_version is 0.
   * For 0.14.0 and 0.15.0 release, the schema_version is 4.
   * More details are described in g3doc/get_start.md#upgrade-mlmd-library
   * Set this field only when a database is accidentally upgraded by a newer
   * version library. Each library version only knows how to downgrade to
   * previous schema versions. As downgrade migrations inevitably introduce
   * data loss, please consider taking a backup of the database before
   * downgrading schema.
   * After downgrade migration, the database connection is canceled. The user
   * needs to downgrade the library to use the database.
   */
  downgradeToSchemaVersion?: number | undefined;
}

export interface RetryOptions {
  /** The max number of retries when transaction returns Aborted error. */
  maxNumRetries?: number | undefined;
}

export interface ConnectionConfig {
  fakeDatabase?: FakeDatabaseConfig | undefined;
  mysql?: MySQLDatabaseConfig | undefined;
  sqlite?: SqliteMetadataSourceConfig | undefined;
  /** PostgreSQL database connection config. */
  postgresql?: PostgreSQLDatabaseConfig | undefined;
  /**
   * Options for overwriting the default retry setting when MLMD transactions
   * returning Aborted error.
   * The setting is currently available for python client library only.
   * TODO(b/154862807) set the setting in transaction executor.
   */
  retryOptions?: RetryOptions | undefined;
}

/**
 * A list of supported GRPC arguments defined in:
 * https://grpc.github.io/grpc/core/group__grpc__arg__keys.html
 */
export interface GrpcChannelArguments {
  /** Maximum message length in bytes per response that the channel can receive. */
  maxReceiveMessageLength?: number | undefined;
  /**
   * Maximum misbehaving pings the server can bear before sending goaway and
   * closing the transport? (0 indicates infinite number of misbehaving pings)
   */
  http2MaxPingStrikes?: number | undefined;
}

/** Configuration for the gRPC metadata store client. */
export interface MetadataStoreClientConfig {
  /** The hostname or IP address of the gRPC server. Must be specified. */
  host?: string | undefined;
  /**
   * The TCP Port number that the gRPC server accepts connections on.
   * Must be specified.
   */
  port?: number | undefined;
  /**
   * Configuration for a secure gRPC channel.
   * If not given, insecure connection is used.
   */
  sslConfig?: MetadataStoreClientConfig_SSLConfig | undefined;
  /** GRPC channel creation arguments. */
  channelArguments?: GrpcChannelArguments | undefined;
  /**
   * Time duration that a client is willing to wait for a reply from the server.
   * If unset, the timeout is considered infinite. When the field is specified,
   * Grpc APIs would return DeadlineExceededError when server does not respond
   * within `client_timeout_sec`. Floating point valued, in seconds.
   */
  clientTimeoutSec?: number | undefined;
}

export interface MetadataStoreClientConfig_SSLConfig {
  /**
   * The PEM-encoded private key as a byte string, or Empty if no private key
   * should be used.
   */
  clientKey?: string | undefined;
  /**
   * The PEM-encoded certificate chain as a byte string to use or or Empty if
   * no certificate chain should be used.
   */
  serverCert?: string | undefined;
  /**
   * The PEM-encoded root certificates as a byte string, or Empty to retrieve
   * them from a default location chosen by gRPC runtime.
   */
  customCa?: string | undefined;
}

/** Configuration for the gRPC metadata store server. */
export interface MetadataStoreServerConfig {
  /** Configuration to connect the metadata source backend. */
  connectionConfig?: ConnectionConfig | undefined;
  /** Configuration for upgrade and downgrade migrations the metadata source. */
  migrationOptions?: MigrationOptions | undefined;
  /**
   * Configuration for a secure gRPC channel.
   * If not given, insecure connection is used.
   */
  sslConfig?: MetadataStoreServerConfig_SSLConfig | undefined;
}

export interface MetadataStoreServerConfig_SSLConfig {
  /** Private server key for SSL */
  serverKey?: string | undefined;
  /** Public server certificate */
  serverCert?: string | undefined;
  /** Custom certificate authority */
  customCa?: string | undefined;
  /** Valid client certificate required? */
  clientVerify?: boolean | undefined;
}

/**
 * ListOperationOptions represents the set of options and predicates to be
 * used for List operations on Artifacts, Executions and Contexts.
 */
export interface ListOperationOptions {
  /**
   * Max number of resources to return in the result. A value of zero or less
   * results in a InvalidArgumentError.
   * The API implementation also enforces an upper-bound of 100, and picks the
   * minimum between this value and the one specified here.
   */
  maxResultSize?: number | undefined;
  /** Ordering field. */
  orderByField?: ListOperationOptions_OrderByField | undefined;
  /** Identifies the next page of results. */
  nextPageToken?: string | undefined;
  /**
   * A boolean expression in SQL syntax that is used to specify the conditions
   * on node attributes and directly connected assets.
   *
   * In the current implementation, filtering Artifact/Execution/Context with
   * the following attributes and neighborhood is supported:
   *
   * Attributes:
   *     id:int64, type_id:int64, type:string,
   *     uri:string, name: string, external_id: string,
   *     create_time_since_epoch:int64, last_update_time_since_epoch:int64
   *     state:ENUM (Artifact only) last_known_state:ENUM (Execution only)
   *
   * Neighborhood
   * - Properties and Custom Properties (for all node types):
   *   syntax: properties.$name ($name is the property name)
   *           custom_properties.$name ($name is the custom property name)
   *   attributes: the following attributes can be used
   *      int_value: int64, double_value: double, string_value: string
   *      bool_value: bool
   *
   * - Context (for Artifact and Execution):
   *   syntax: contexts_$alias ($alias can be [0-9A-Za-z_])
   *   attributes: the following attributes can be used
   *      id:int64, name:string, type:string, create_time_since_epoch:int64,
   *      last_update_time_since_epoch: int64
   *
   * - Parent and Child Contexts (for Contexts):
   *   syntax: parent_contexts_$alias( $alias can be [0-9A-Za-z_]
   *           child_contexts_$alias( $alias can be [0-9A-Za-z_]
   *   attributes: the following attributes can be used
   *      id:int64, name: string, type:string
   *
   * - Event (for Artifact and Execution)
   *   syntax: events_$alias ($alias can be [0-9A-Za-z_])
   *   attributes: the following attributes can be used
   *     artifact_id: int64(Execution only), execution_id: int64(Artifact only),
   *     type: ENUM, milliseconds_since_epoch: int64
   *
   * Examples:
   * a) to filter nodes attributes:
   *    - id != 1
   *    - id IN (1, 3)
   *    - type_id = 5
   *    - type = 'my_type_name'
   *    - name = 'foo'
   *    - type = 'bar' AND name LIKE 'foo%'
   *    - external_id = 'my_external_id'
   *    - NOT(create_time_since_epoch < 1 OR last_update_time_since_epoch < 1)
   *
   * b) to filter artifacts' uri
   *    - uri = 'exact_path_string'
   *    - uri LIKE 'path_like_this%'
   *    - uri IS NOT NULL
   *
   * c) to filter artifact's state or execution's last_known_state
   *    - state = LIVE
   *    - state IS NULL
   *    - state IN (PENDING, LIVE)
   *    - last_known_state = RUNNING
   *    - last_known_state != RUNNING
   *    - last_known_state NOT IN (FAILED, CANCELED)
   *
   * d) to filter nodes having a specific context, artifact, or execution
   *    - contexts_a.id = 5
   *    - contexts_a.type = 'RunContext'
   *    - contexts_a.name = 'my_run'
   *    - contexts_a.create_time_since_epoch = 1626761453
   *    - contexts_a.last_update_time_since_epoch = 1626761453
   *    To filter nodes with conditions on multiple contexts:
   *    - contexts_a.name = 'my_run' AND contexts_b.name = 'my_pipeline'
   *    To filter context with artifacts:
   *    - artifacts_a.id = 5
   *    - artifacts_a.type = 'Dataset'
   *    - artifacts_a.name = 'my_dataset'
   *    - artifacts_a.uri = 'exact_path_string'
   *    - artifacts_a.state = LIVE
   *    - artifacts_a.state IN (PENDING, LIVE)
   *    - artifacts_a.external_id = "my_external_id"
   *    - artifacts_a.create_time_since_epoch = 1626761453
   *    - artifacts_a.last_update_time_since_epoch = 1626761453
   *    To filter contexts with conditions on multiple artifacts:
   *    - artifacts_a.name = 'my_run' AND artifacts_b.name = 'my_pipeline'
   *    To filter context with executions:
   *    - executions_a.id = 5
   *    - executions_a.type = 'Dataset'
   *    - executions_a.name = 'my_dataset'
   *    - executions_a.last_known_state = RUNNING
   * .   - executions_a.last_known_state IN (NEW, RUNNING)
   *    - executions_a.external_id = "my_external_id"
   *    - executions_a.create_time_since_epoch = 1626761453
   *    - executions_a.last_update_time_since_epoch = 1626761453
   *    To filter contexts with conditions on multiple executions:
   *    - executions_a.name = 'my_run' AND executions_b.name = 'my_pipeline'
   *
   * e) to filter nodes condition on their properties
   *    - properties.accuracy.double_value > 0.95
   *    - custom_properties.my_param.string_value = "foo"
   *    If the name of the property or custom property includes characters
   *    other than [0-9A-Za-z_], then the name need to be backquoted,
   *    e.g.,
   *    - properties.`my property`.int_value > 0
   *    - custom_properties.`my:custom.property`.bool_value = true
   *
   * f) complex query to filter both node attributes and neighborhood
   *    - type = 'DataSet' AND
   *      (contexts_a.type = 'RunContext' AND contexts_a.name = 'my_run') AND
   *      (properties.span = 1 OR custom_properties.span = 1)
   *
   * g) to filter parent/child context
   *    - parent_contexts_a.id = 5
   *    - child_contexts_a.type = 'RunContext'
   *    - parent_contexts_a.name = 'parent_context_1'
   *
   * h) to filter Artifacts on Events
   *    - events_0.execution_id = 1
   *    - events_0.type = INPUT
   *    - events_0.milliseconds_since_epoch = 1
   *    to filter Executions on Events
   *    - events_0.artifact_id = 1
   *    - events_0.type IN (INPUT, INTERNAL_INPUT)
   *    - events_0.milliseconds_since_epoch = 1
   * TODO(b/145945460) Support filtering on event step fields.
   */
  filterQuery?: string | undefined;
}

export interface ListOperationOptions_OrderByField {
  /** Field to order. */
  field?: ListOperationOptions_OrderByField_Field | undefined;
  /** Direction of ordering. */
  isAsc?: boolean | undefined;
}

/** Supported fields for Ordering. */
export enum ListOperationOptions_OrderByField_Field {
  FIELD_UNSPECIFIED = 0,
  CREATE_TIME = 1,
  LAST_UPDATE_TIME = 2,
  ID = 3,
  UNRECOGNIZED = -1,
}

export function listOperationOptions_OrderByField_FieldFromJSON(
  object: any,
): ListOperationOptions_OrderByField_Field {
  switch (object) {
    case 0:
    case 'FIELD_UNSPECIFIED':
      return ListOperationOptions_OrderByField_Field.FIELD_UNSPECIFIED;
    case 1:
    case 'CREATE_TIME':
      return ListOperationOptions_OrderByField_Field.CREATE_TIME;
    case 2:
    case 'LAST_UPDATE_TIME':
      return ListOperationOptions_OrderByField_Field.LAST_UPDATE_TIME;
    case 3:
    case 'ID':
      return ListOperationOptions_OrderByField_Field.ID;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return ListOperationOptions_OrderByField_Field.UNRECOGNIZED;
  }
}

export function listOperationOptions_OrderByField_FieldToJSON(
  object: ListOperationOptions_OrderByField_Field,
): string {
  switch (object) {
    case ListOperationOptions_OrderByField_Field.FIELD_UNSPECIFIED:
      return 'FIELD_UNSPECIFIED';
    case ListOperationOptions_OrderByField_Field.CREATE_TIME:
      return 'CREATE_TIME';
    case ListOperationOptions_OrderByField_Field.LAST_UPDATE_TIME:
      return 'LAST_UPDATE_TIME';
    case ListOperationOptions_OrderByField_Field.ID:
      return 'ID';
    case ListOperationOptions_OrderByField_Field.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

/**
 * Encapsulates information to identify the next page of resources in
 * ListOperation.
 */
export interface ListOperationNextPageToken {
  /**
   * Id offset within the resultset to start next page.
   * Id offset is returned as Id is the unique field used to break ties for
   * fields that might have duplicate entries, e.g. there could be two
   * resources with same create_time. In such cases to  break the tie in
   * ordering, id offset is used.
   * This field is currently only set whe order_by field is CREATE_TIME.
   */
  idOffset?: number | undefined;
  /**
   * Offset value of the order by field. If ID is used this value is same as
   * id_offset.
   */
  fieldOffset?: number | undefined;
  /**
   * Options set in the first call to ListOperation. This ensures that if
   * next_page_token is set by the caller then ListPipelineJobs API will always
   * use options set in the first call.
   */
  setOptions?: ListOperationOptions | undefined;
  /**
   * List of ids that have the same order_by field values. This is used to
   * ensure List Operation does not return duplicate entries for nodes that have
   * the same order_by field value.
   * This field is currently only set whe order_by field is LAST_UPDATE_TIME.
   */
  listedIds: number[];
}

/**
 * Options for transactions.
 * Note: This is under development. Clients should not use it.
 */
export interface TransactionOptions {
  /** Transaction tag for debug use only. */
  tag?: string | undefined;
}

/**
 * TODO(b/283852485): Deprecate GetLineageGraph API after migration to
 * GetLineageSubgraph API.
 * The query options for `get_lineage_graph` operation.
 * `query_nodes` is a list of nodes of interest.
 * Currently only artifacts are supported as `query_nodes`.
 * `stop_conditions` defines the filtering rules when querying a lineage graph.
 * `max_node_size` defines the total number of artifacts and executions returned
 * in the subgraph.
 */
export interface LineageGraphQueryOptions {
  artifactsOptions?: ListOperationOptions | undefined;
  /**
   * A constraint option to define the filtering rules when querying a lineage
   * graph.
   */
  stopConditions?: LineageGraphQueryOptions_BoundaryConstraint | undefined;
  /**
   * Maximum total number of artifacts and executions in the whole returned
   * lineage graph.
   * If set to 0 or below, all related nodes will be returned without any
   * number limitation.
   * The number counts toward Artifacts and Executions. Nothing else considered.
   *
   * NOTE: There is no pagination supported.
   */
  maxNodeSize?: number | undefined;
}

/** Filtering conditions for retrieving the lineage graph. */
export interface LineageGraphQueryOptions_BoundaryConstraint {
  /**
   * The maximum number of hops from the `query_nodes` to traverse.
   * A hop is defined as a jump to the next node following the path of
   * node -> event -> next_node.
   * For example, in the lineage graph a_1 -> e_1 -> a_2:
   * a_2 is 2 hops away from a_1, and e_1 is 1 hop away from a_1.
   * `max_num_hops` should be non-negative.
   * When its value is set to 0, only the `query_nodes` are returned.
   */
  maxNumHops?: number | undefined;
  /**
   * Filtering conditions for retrieving the lineage graph.
   * Please refer to `ListOperationOptions.filter_query` for the syntax.
   *
   * If set, the `boundary_artifacts` defines which artifacts to keep in the
   * returned lineage graph during the graph search.
   * Artifacts that do not satisfy the `boundary_artifacts` are filtered out,
   * and the subgraphs starting at them will be pruned.
   * If not set, no artifacts will be filtered out.
   * Taking the following lineage graph as example:
   * (`a` represents an Artifact, `e` represents an Execution, each arrow
   * represents a hop.)
   *  a_0   a_1     a_3
   *   |      \   /     \
   *  \/      \/ \/     \/
   *  e_0      e_1      e_3
   *                   /   \
   *                  \/   \/
   *        a_2     a_4     a_5
   *           \   /
   *           \/ \/
   *            e_2
   * To query all the upstream and downstream nodes 3 hops away from a_4,
   * while excluding the upstream subgraph starting at a_3, then
   * `stop_conditions` can be set as:
   * {
   *   max_num_hops: 3
   *   boundary_artifacts: 'id != 3'
   * }
   * With the `stop_conditions`, {a_3, e_1, a_1, a_0, e_0} will be filtered
   * out.
   * The returned lineage graph looks like:
   *                    e_3
   *                   /   \
   *                  \/   \/
   *        a_2     a_4     a_5
   *           \   /
   *           \/ \/
   *            e_2
   */
  boundaryArtifacts?: string | undefined;
  /**
   * If set, the `boundary_executions` defines which executions to keep in the
   * returned lineage graph during the graph search.
   * Executions that do not satisfy the `boundary_executions` are filtered out
   * and the subgraphs starting at them will be pruned.
   * If not set, no executions will be filtered out.
   * In the example above, to query for all the upstream and downstream nodes
   * 3 hops away from a_4, while excluding the upstream subgraph and the
   * downstream subgraph starting at e_3, then `stop_conditions` can be set as
   * {
   *   max_num_hops: 3
   *   boundary_executions: 'id != 3'
   * }
   * With the `stop_conditions`, {e_3, a_5, a_3, e_1, a_1, a_0, e_0} will be
   * filtered out.
   * The returned lineage graph looks like:
   *        a_2     a_4
   *           \   /
   *           \/ \/
   *            e_2
   * However, for the following graph:
   *  a_0   a_1     a_3
   *   |      \   /     \
   *  \/      \/ \/     \/
   *  e_0      e_1      e_3
   *              \    /   \
   *               \/ \/   \/
   *        a_2     a_4     a_5
   *           \   /
   *           \/ \/
   *            e_2
   * With the same `stop_conditions`, only {e_3, a_5, a_0, e_0} will be
   * filtered out.
   * The returned lineage graph looks like:
   *       a_1     a_3
   *          \   /
   *          \/ \/
   *           e_1
   *              \
   *               \/
   *        a_2     a_4
   *           \   /
   *           \/ \/
   *            e_2
   */
  boundaryExecutions?: string | undefined;
}

/** The query options for lineage graph tracing from a list of interested nodes. */
export interface LineageSubgraphQueryOptions {
  startingArtifacts?: LineageSubgraphQueryOptions_StartingNodes | undefined;
  startingExecutions?: LineageSubgraphQueryOptions_StartingNodes | undefined;
  /**
   * The maximum number of hops from the `starting_nodes` to traverse.
   * A hop is defined as a jump to the next node following the path of
   * node -> event -> next_node.
   * For example, in the lineage graph a_1 -> e_1 -> a_2:
   * a_2 is 2 hops away from a_1, and e_1 is 1 hop away from a_1.
   * `max_num_hops` should be non-negative.
   * When its value is set to 0, only the `starting_nodes` are returned.
   */
  maxNumHops?: number | undefined;
  /**
   * The direction of lineage graph tracing, which means the direction of all
   * hops in the tracing.
   *   An UPSTREAM hop means an expansion following the path of
   *     execution -> output_event -> artifact or
   *     artifact -> input_event -> execution
   *   A DOWNSTREAM hop means an expansion following the path of
   *     execution -> input_event -> artifact or
   *     artifact -> output_event -> execution
   * Please refer to `Direction` for more details.
   */
  direction?: LineageSubgraphQueryOptions_Direction | undefined;
}

export enum LineageSubgraphQueryOptions_Direction {
  /**
   * DIRECTION_UNSPECIFIED - Direction is by defult DIRECTION_UNSPECIFIED, which is equivalent to
   * BIDIRECTIONAL.
   */
  DIRECTION_UNSPECIFIED = 0,
  /** UPSTREAM - Indicates tracing the lineage graph by hops in upstream direction. */
  UPSTREAM = 1,
  /** DOWNSTREAM - Indicates tracing the lineage graph by hops in downstream direction. */
  DOWNSTREAM = 2,
  /** BIDIRECTIONAL - Indicates tracing the lineage graph in both directions. */
  BIDIRECTIONAL = 3,
  UNRECOGNIZED = -1,
}

export function lineageSubgraphQueryOptions_DirectionFromJSON(
  object: any,
): LineageSubgraphQueryOptions_Direction {
  switch (object) {
    case 0:
    case 'DIRECTION_UNSPECIFIED':
      return LineageSubgraphQueryOptions_Direction.DIRECTION_UNSPECIFIED;
    case 1:
    case 'UPSTREAM':
      return LineageSubgraphQueryOptions_Direction.UPSTREAM;
    case 2:
    case 'DOWNSTREAM':
      return LineageSubgraphQueryOptions_Direction.DOWNSTREAM;
    case 3:
    case 'BIDIRECTIONAL':
      return LineageSubgraphQueryOptions_Direction.BIDIRECTIONAL;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return LineageSubgraphQueryOptions_Direction.UNRECOGNIZED;
  }
}

export function lineageSubgraphQueryOptions_DirectionToJSON(
  object: LineageSubgraphQueryOptions_Direction,
): string {
  switch (object) {
    case LineageSubgraphQueryOptions_Direction.DIRECTION_UNSPECIFIED:
      return 'DIRECTION_UNSPECIFIED';
    case LineageSubgraphQueryOptions_Direction.UPSTREAM:
      return 'UPSTREAM';
    case LineageSubgraphQueryOptions_Direction.DOWNSTREAM:
      return 'DOWNSTREAM';
    case LineageSubgraphQueryOptions_Direction.BIDIRECTIONAL:
      return 'BIDIRECTIONAL';
    case LineageSubgraphQueryOptions_Direction.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

/**
 * `starting_nodes` is a list of nodes of interest to start graph tracing.
 * NOTE: The maximum number of starting nodes is 100 at most.
 */
export interface LineageSubgraphQueryOptions_StartingNodes {
  /**
   * `filter_query` is a boolean expression in SQL syntax that is used to
   * specify the conditions on starting nodes.
   * Please refer to ListOperationOptions.filter_query for more details.
   */
  filterQuery?: string | undefined;
}

function createBaseSystemTypeExtension(): SystemTypeExtension {
  return { typeName: '' };
}

export const SystemTypeExtension = {
  encode(message: SystemTypeExtension, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.typeName !== undefined && message.typeName !== '') {
      writer.uint32(10).string(message.typeName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SystemTypeExtension {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemTypeExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.typeName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemTypeExtension {
    return { typeName: isSet(object.typeName) ? globalThis.String(object.typeName) : '' };
  },

  toJSON(message: SystemTypeExtension): unknown {
    const obj: any = {};
    if (message.typeName !== undefined && message.typeName !== '') {
      obj.typeName = message.typeName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemTypeExtension>, I>>(base?: I): SystemTypeExtension {
    return SystemTypeExtension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemTypeExtension>, I>>(
    object: I,
  ): SystemTypeExtension {
    const message = createBaseSystemTypeExtension();
    message.typeName = object.typeName ?? '';
    return message;
  },
};

function createBaseValue(): Value {
  return {
    intValue: undefined,
    doubleValue: undefined,
    stringValue: undefined,
    structValue: undefined,
    protoValue: undefined,
    boolValue: undefined,
  };
}

export const Value = {
  encode(message: Value, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.intValue !== undefined) {
      writer.uint32(8).int64(message.intValue);
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(17).double(message.doubleValue);
    }
    if (message.stringValue !== undefined) {
      writer.uint32(26).string(message.stringValue);
    }
    if (message.structValue !== undefined) {
      Struct.encode(Struct.wrap(message.structValue), writer.uint32(34).fork()).ldelim();
    }
    if (message.protoValue !== undefined) {
      Any.encode(message.protoValue, writer.uint32(42).fork()).ldelim();
    }
    if (message.boolValue !== undefined) {
      writer.uint32(48).bool(message.boolValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Value {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.intValue = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.structValue = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.protoValue = Any.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Value {
    return {
      intValue: isSet(object.intValue) ? globalThis.Number(object.intValue) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      structValue: isObject(object.structValue) ? object.structValue : undefined,
      protoValue: isSet(object.protoValue) ? Any.fromJSON(object.protoValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
    };
  },

  toJSON(message: Value): unknown {
    const obj: any = {};
    if (message.intValue !== undefined) {
      obj.intValue = Math.round(message.intValue);
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.structValue !== undefined) {
      obj.structValue = message.structValue;
    }
    if (message.protoValue !== undefined) {
      obj.protoValue = Any.toJSON(message.protoValue);
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Value>, I>>(base?: I): Value {
    return Value.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Value>, I>>(object: I): Value {
    const message = createBaseValue();
    message.intValue = object.intValue ?? undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    message.stringValue = object.stringValue ?? undefined;
    message.structValue = object.structValue ?? undefined;
    message.protoValue =
      object.protoValue !== undefined && object.protoValue !== null
        ? Any.fromPartial(object.protoValue)
        : undefined;
    message.boolValue = object.boolValue ?? undefined;
    return message;
  },
};

function createBaseArtifact(): Artifact {
  return {
    id: 0,
    name: '',
    typeId: 0,
    type: '',
    uri: '',
    externalId: '',
    properties: {},
    customProperties: {},
    state: 0,
    createTimeSinceEpoch: 0,
    lastUpdateTimeSinceEpoch: 0,
    systemMetadata: undefined,
  };
}

export const Artifact = {
  encode(message: Artifact, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    if (message.name !== undefined && message.name !== '') {
      writer.uint32(58).string(message.name);
    }
    if (message.typeId !== undefined && message.typeId !== 0) {
      writer.uint32(16).int64(message.typeId);
    }
    if (message.type !== undefined && message.type !== '') {
      writer.uint32(66).string(message.type);
    }
    if (message.uri !== undefined && message.uri !== '') {
      writer.uint32(26).string(message.uri);
    }
    if (message.externalId !== undefined && message.externalId !== '') {
      writer.uint32(90).string(message.externalId);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      Artifact_PropertiesEntry.encode(
        { key: key as any, value },
        writer.uint32(34).fork(),
      ).ldelim();
    });
    Object.entries(message.customProperties).forEach(([key, value]) => {
      Artifact_CustomPropertiesEntry.encode(
        { key: key as any, value },
        writer.uint32(42).fork(),
      ).ldelim();
    });
    if (message.state !== undefined && message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.createTimeSinceEpoch !== undefined && message.createTimeSinceEpoch !== 0) {
      writer.uint32(72).int64(message.createTimeSinceEpoch);
    }
    if (message.lastUpdateTimeSinceEpoch !== undefined && message.lastUpdateTimeSinceEpoch !== 0) {
      writer.uint32(80).int64(message.lastUpdateTimeSinceEpoch);
    }
    if (message.systemMetadata !== undefined) {
      Any.encode(message.systemMetadata, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Artifact {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.typeId = longToNumber(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.externalId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Artifact_PropertiesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.properties[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Artifact_CustomPropertiesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.customProperties[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.createTimeSinceEpoch = longToNumber(reader.int64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.lastUpdateTimeSinceEpoch = longToNumber(reader.int64() as Long);
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.systemMetadata = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Artifact {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      typeId: isSet(object.typeId) ? globalThis.Number(object.typeId) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : '',
      uri: isSet(object.uri) ? globalThis.String(object.uri) : '',
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : '',
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: Value }>(
            (acc, [key, value]) => {
              acc[key] = Value.fromJSON(value);
              return acc;
            },
            {},
          )
        : {},
      customProperties: isObject(object.customProperties)
        ? Object.entries(object.customProperties).reduce<{ [key: string]: Value }>(
            (acc, [key, value]) => {
              acc[key] = Value.fromJSON(value);
              return acc;
            },
            {},
          )
        : {},
      state: isSet(object.state) ? artifact_StateFromJSON(object.state) : 0,
      createTimeSinceEpoch: isSet(object.createTimeSinceEpoch)
        ? globalThis.Number(object.createTimeSinceEpoch)
        : 0,
      lastUpdateTimeSinceEpoch: isSet(object.lastUpdateTimeSinceEpoch)
        ? globalThis.Number(object.lastUpdateTimeSinceEpoch)
        : 0,
      systemMetadata: isSet(object.systemMetadata)
        ? Any.fromJSON(object.systemMetadata)
        : undefined,
    };
  },

  toJSON(message: Artifact): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined && message.name !== '') {
      obj.name = message.name;
    }
    if (message.typeId !== undefined && message.typeId !== 0) {
      obj.typeId = Math.round(message.typeId);
    }
    if (message.type !== undefined && message.type !== '') {
      obj.type = message.type;
    }
    if (message.uri !== undefined && message.uri !== '') {
      obj.uri = message.uri;
    }
    if (message.externalId !== undefined && message.externalId !== '') {
      obj.externalId = message.externalId;
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = Value.toJSON(v);
        });
      }
    }
    if (message.customProperties) {
      const entries = Object.entries(message.customProperties);
      if (entries.length > 0) {
        obj.customProperties = {};
        entries.forEach(([k, v]) => {
          obj.customProperties[k] = Value.toJSON(v);
        });
      }
    }
    if (message.state !== undefined && message.state !== 0) {
      obj.state = artifact_StateToJSON(message.state);
    }
    if (message.createTimeSinceEpoch !== undefined && message.createTimeSinceEpoch !== 0) {
      obj.createTimeSinceEpoch = Math.round(message.createTimeSinceEpoch);
    }
    if (message.lastUpdateTimeSinceEpoch !== undefined && message.lastUpdateTimeSinceEpoch !== 0) {
      obj.lastUpdateTimeSinceEpoch = Math.round(message.lastUpdateTimeSinceEpoch);
    }
    if (message.systemMetadata !== undefined) {
      obj.systemMetadata = Any.toJSON(message.systemMetadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Artifact>, I>>(base?: I): Artifact {
    return Artifact.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Artifact>, I>>(object: I): Artifact {
    const message = createBaseArtifact();
    message.id = object.id ?? 0;
    message.name = object.name ?? '';
    message.typeId = object.typeId ?? 0;
    message.type = object.type ?? '';
    message.uri = object.uri ?? '';
    message.externalId = object.externalId ?? '';
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: Value }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Value.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.customProperties = Object.entries(object.customProperties ?? {}).reduce<{
      [key: string]: Value;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Value.fromPartial(value);
      }
      return acc;
    }, {});
    message.state = object.state ?? 0;
    message.createTimeSinceEpoch = object.createTimeSinceEpoch ?? 0;
    message.lastUpdateTimeSinceEpoch = object.lastUpdateTimeSinceEpoch ?? 0;
    message.systemMetadata =
      object.systemMetadata !== undefined && object.systemMetadata !== null
        ? Any.fromPartial(object.systemMetadata)
        : undefined;
    return message;
  },
};

function createBaseArtifact_PropertiesEntry(): Artifact_PropertiesEntry {
  return { key: '', value: undefined };
}

export const Artifact_PropertiesEntry = {
  encode(message: Artifact_PropertiesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Artifact_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifact_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Artifact_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : '',
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Artifact_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== '') {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Artifact_PropertiesEntry>, I>>(
    base?: I,
  ): Artifact_PropertiesEntry {
    return Artifact_PropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Artifact_PropertiesEntry>, I>>(
    object: I,
  ): Artifact_PropertiesEntry {
    const message = createBaseArtifact_PropertiesEntry();
    message.key = object.key ?? '';
    message.value =
      object.value !== undefined && object.value !== null
        ? Value.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseArtifact_CustomPropertiesEntry(): Artifact_CustomPropertiesEntry {
  return { key: '', value: undefined };
}

export const Artifact_CustomPropertiesEntry = {
  encode(
    message: Artifact_CustomPropertiesEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Artifact_CustomPropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifact_CustomPropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Artifact_CustomPropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : '',
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Artifact_CustomPropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== '') {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Artifact_CustomPropertiesEntry>, I>>(
    base?: I,
  ): Artifact_CustomPropertiesEntry {
    return Artifact_CustomPropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Artifact_CustomPropertiesEntry>, I>>(
    object: I,
  ): Artifact_CustomPropertiesEntry {
    const message = createBaseArtifact_CustomPropertiesEntry();
    message.key = object.key ?? '';
    message.value =
      object.value !== undefined && object.value !== null
        ? Value.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseArtifactType(): ArtifactType {
  return {
    id: 0,
    name: '',
    version: '',
    description: '',
    externalId: '',
    properties: {},
    baseType: 0,
  };
}

export const ArtifactType = {
  encode(message: ArtifactType, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    if (message.name !== undefined && message.name !== '') {
      writer.uint32(18).string(message.name);
    }
    if (message.version !== undefined && message.version !== '') {
      writer.uint32(34).string(message.version);
    }
    if (message.description !== undefined && message.description !== '') {
      writer.uint32(42).string(message.description);
    }
    if (message.externalId !== undefined && message.externalId !== '') {
      writer.uint32(58).string(message.externalId);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      ArtifactType_PropertiesEntry.encode(
        { key: key as any, value },
        writer.uint32(26).fork(),
      ).ldelim();
    });
    if (message.baseType !== undefined && message.baseType !== 0) {
      writer.uint32(48).int32(message.baseType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ArtifactType {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.version = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.externalId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = ArtifactType_PropertiesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.properties[entry3.key] = entry3.value;
          }
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.baseType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactType {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      version: isSet(object.version) ? globalThis.String(object.version) : '',
      description: isSet(object.description) ? globalThis.String(object.description) : '',
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : '',
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: PropertyType }>(
            (acc, [key, value]) => {
              acc[key] = propertyTypeFromJSON(value);
              return acc;
            },
            {},
          )
        : {},
      baseType: isSet(object.baseType)
        ? artifactType_SystemDefinedBaseTypeFromJSON(object.baseType)
        : 0,
    };
  },

  toJSON(message: ArtifactType): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined && message.name !== '') {
      obj.name = message.name;
    }
    if (message.version !== undefined && message.version !== '') {
      obj.version = message.version;
    }
    if (message.description !== undefined && message.description !== '') {
      obj.description = message.description;
    }
    if (message.externalId !== undefined && message.externalId !== '') {
      obj.externalId = message.externalId;
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = propertyTypeToJSON(v);
        });
      }
    }
    if (message.baseType !== undefined && message.baseType !== 0) {
      obj.baseType = artifactType_SystemDefinedBaseTypeToJSON(message.baseType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArtifactType>, I>>(base?: I): ArtifactType {
    return ArtifactType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArtifactType>, I>>(object: I): ArtifactType {
    const message = createBaseArtifactType();
    message.id = object.id ?? 0;
    message.name = object.name ?? '';
    message.version = object.version ?? '';
    message.description = object.description ?? '';
    message.externalId = object.externalId ?? '';
    message.properties = Object.entries(object.properties ?? {}).reduce<{
      [key: string]: PropertyType;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value as PropertyType;
      }
      return acc;
    }, {});
    message.baseType = object.baseType ?? 0;
    return message;
  },
};

function createBaseArtifactType_PropertiesEntry(): ArtifactType_PropertiesEntry {
  return { key: '', value: 0 };
}

export const ArtifactType_PropertiesEntry = {
  encode(
    message: ArtifactType_PropertiesEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ArtifactType_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactType_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactType_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : '',
      value: isSet(object.value) ? propertyTypeFromJSON(object.value) : 0,
    };
  },

  toJSON(message: ArtifactType_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== '') {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = propertyTypeToJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArtifactType_PropertiesEntry>, I>>(
    base?: I,
  ): ArtifactType_PropertiesEntry {
    return ArtifactType_PropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArtifactType_PropertiesEntry>, I>>(
    object: I,
  ): ArtifactType_PropertiesEntry {
    const message = createBaseArtifactType_PropertiesEntry();
    message.key = object.key ?? '';
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseEvent(): Event {
  return {
    artifactId: 0,
    executionId: 0,
    path: undefined,
    type: 0,
    millisecondsSinceEpoch: 0,
    systemMetadata: undefined,
  };
}

export const Event = {
  encode(message: Event, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.artifactId !== undefined && message.artifactId !== 0) {
      writer.uint32(8).int64(message.artifactId);
    }
    if (message.executionId !== undefined && message.executionId !== 0) {
      writer.uint32(16).int64(message.executionId);
    }
    if (message.path !== undefined) {
      Event_Path.encode(message.path, writer.uint32(26).fork()).ldelim();
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.millisecondsSinceEpoch !== undefined && message.millisecondsSinceEpoch !== 0) {
      writer.uint32(40).int64(message.millisecondsSinceEpoch);
    }
    if (message.systemMetadata !== undefined) {
      Any.encode(message.systemMetadata, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Event {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.artifactId = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.executionId = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.path = Event_Path.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.millisecondsSinceEpoch = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.systemMetadata = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      artifactId: isSet(object.artifactId) ? globalThis.Number(object.artifactId) : 0,
      executionId: isSet(object.executionId) ? globalThis.Number(object.executionId) : 0,
      path: isSet(object.path) ? Event_Path.fromJSON(object.path) : undefined,
      type: isSet(object.type) ? event_TypeFromJSON(object.type) : 0,
      millisecondsSinceEpoch: isSet(object.millisecondsSinceEpoch)
        ? globalThis.Number(object.millisecondsSinceEpoch)
        : 0,
      systemMetadata: isSet(object.systemMetadata)
        ? Any.fromJSON(object.systemMetadata)
        : undefined,
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.artifactId !== undefined && message.artifactId !== 0) {
      obj.artifactId = Math.round(message.artifactId);
    }
    if (message.executionId !== undefined && message.executionId !== 0) {
      obj.executionId = Math.round(message.executionId);
    }
    if (message.path !== undefined) {
      obj.path = Event_Path.toJSON(message.path);
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = event_TypeToJSON(message.type);
    }
    if (message.millisecondsSinceEpoch !== undefined && message.millisecondsSinceEpoch !== 0) {
      obj.millisecondsSinceEpoch = Math.round(message.millisecondsSinceEpoch);
    }
    if (message.systemMetadata !== undefined) {
      obj.systemMetadata = Any.toJSON(message.systemMetadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {
    return Event.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {
    const message = createBaseEvent();
    message.artifactId = object.artifactId ?? 0;
    message.executionId = object.executionId ?? 0;
    message.path =
      object.path !== undefined && object.path !== null
        ? Event_Path.fromPartial(object.path)
        : undefined;
    message.type = object.type ?? 0;
    message.millisecondsSinceEpoch = object.millisecondsSinceEpoch ?? 0;
    message.systemMetadata =
      object.systemMetadata !== undefined && object.systemMetadata !== null
        ? Any.fromPartial(object.systemMetadata)
        : undefined;
    return message;
  },
};

function createBaseEvent_Path(): Event_Path {
  return { steps: [] };
}

export const Event_Path = {
  encode(message: Event_Path, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.steps) {
      Event_Path_Step.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Event_Path {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent_Path();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.steps.push(Event_Path_Step.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event_Path {
    return {
      steps: globalThis.Array.isArray(object?.steps)
        ? object.steps.map((e: any) => Event_Path_Step.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Event_Path): unknown {
    const obj: any = {};
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => Event_Path_Step.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event_Path>, I>>(base?: I): Event_Path {
    return Event_Path.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event_Path>, I>>(object: I): Event_Path {
    const message = createBaseEvent_Path();
    message.steps = object.steps?.map((e) => Event_Path_Step.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEvent_Path_Step(): Event_Path_Step {
  return { index: undefined, key: undefined };
}

export const Event_Path_Step = {
  encode(message: Event_Path_Step, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.index !== undefined) {
      writer.uint32(8).int64(message.index);
    }
    if (message.key !== undefined) {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Event_Path_Step {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent_Path_Step();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event_Path_Step {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : undefined,
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
    };
  },

  toJSON(message: Event_Path_Step): unknown {
    const obj: any = {};
    if (message.index !== undefined) {
      obj.index = Math.round(message.index);
    }
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event_Path_Step>, I>>(base?: I): Event_Path_Step {
    return Event_Path_Step.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event_Path_Step>, I>>(object: I): Event_Path_Step {
    const message = createBaseEvent_Path_Step();
    message.index = object.index ?? undefined;
    message.key = object.key ?? undefined;
    return message;
  },
};

function createBaseExecution(): Execution {
  return {
    id: 0,
    name: '',
    typeId: 0,
    type: '',
    externalId: '',
    lastKnownState: 0,
    properties: {},
    customProperties: {},
    createTimeSinceEpoch: 0,
    lastUpdateTimeSinceEpoch: 0,
    systemMetadata: undefined,
  };
}

export const Execution = {
  encode(message: Execution, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    if (message.name !== undefined && message.name !== '') {
      writer.uint32(50).string(message.name);
    }
    if (message.typeId !== undefined && message.typeId !== 0) {
      writer.uint32(16).int64(message.typeId);
    }
    if (message.type !== undefined && message.type !== '') {
      writer.uint32(58).string(message.type);
    }
    if (message.externalId !== undefined && message.externalId !== '') {
      writer.uint32(82).string(message.externalId);
    }
    if (message.lastKnownState !== undefined && message.lastKnownState !== 0) {
      writer.uint32(24).int32(message.lastKnownState);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      Execution_PropertiesEntry.encode(
        { key: key as any, value },
        writer.uint32(34).fork(),
      ).ldelim();
    });
    Object.entries(message.customProperties).forEach(([key, value]) => {
      Execution_CustomPropertiesEntry.encode(
        { key: key as any, value },
        writer.uint32(42).fork(),
      ).ldelim();
    });
    if (message.createTimeSinceEpoch !== undefined && message.createTimeSinceEpoch !== 0) {
      writer.uint32(64).int64(message.createTimeSinceEpoch);
    }
    if (message.lastUpdateTimeSinceEpoch !== undefined && message.lastUpdateTimeSinceEpoch !== 0) {
      writer.uint32(72).int64(message.lastUpdateTimeSinceEpoch);
    }
    if (message.systemMetadata !== undefined) {
      Any.encode(message.systemMetadata, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Execution {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.typeId = longToNumber(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.type = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.externalId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.lastKnownState = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Execution_PropertiesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.properties[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Execution_CustomPropertiesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.customProperties[entry5.key] = entry5.value;
          }
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.createTimeSinceEpoch = longToNumber(reader.int64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.lastUpdateTimeSinceEpoch = longToNumber(reader.int64() as Long);
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.systemMetadata = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Execution {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      typeId: isSet(object.typeId) ? globalThis.Number(object.typeId) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : '',
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : '',
      lastKnownState: isSet(object.lastKnownState)
        ? execution_StateFromJSON(object.lastKnownState)
        : 0,
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: Value }>(
            (acc, [key, value]) => {
              acc[key] = Value.fromJSON(value);
              return acc;
            },
            {},
          )
        : {},
      customProperties: isObject(object.customProperties)
        ? Object.entries(object.customProperties).reduce<{ [key: string]: Value }>(
            (acc, [key, value]) => {
              acc[key] = Value.fromJSON(value);
              return acc;
            },
            {},
          )
        : {},
      createTimeSinceEpoch: isSet(object.createTimeSinceEpoch)
        ? globalThis.Number(object.createTimeSinceEpoch)
        : 0,
      lastUpdateTimeSinceEpoch: isSet(object.lastUpdateTimeSinceEpoch)
        ? globalThis.Number(object.lastUpdateTimeSinceEpoch)
        : 0,
      systemMetadata: isSet(object.systemMetadata)
        ? Any.fromJSON(object.systemMetadata)
        : undefined,
    };
  },

  toJSON(message: Execution): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined && message.name !== '') {
      obj.name = message.name;
    }
    if (message.typeId !== undefined && message.typeId !== 0) {
      obj.typeId = Math.round(message.typeId);
    }
    if (message.type !== undefined && message.type !== '') {
      obj.type = message.type;
    }
    if (message.externalId !== undefined && message.externalId !== '') {
      obj.externalId = message.externalId;
    }
    if (message.lastKnownState !== undefined && message.lastKnownState !== 0) {
      obj.lastKnownState = execution_StateToJSON(message.lastKnownState);
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = Value.toJSON(v);
        });
      }
    }
    if (message.customProperties) {
      const entries = Object.entries(message.customProperties);
      if (entries.length > 0) {
        obj.customProperties = {};
        entries.forEach(([k, v]) => {
          obj.customProperties[k] = Value.toJSON(v);
        });
      }
    }
    if (message.createTimeSinceEpoch !== undefined && message.createTimeSinceEpoch !== 0) {
      obj.createTimeSinceEpoch = Math.round(message.createTimeSinceEpoch);
    }
    if (message.lastUpdateTimeSinceEpoch !== undefined && message.lastUpdateTimeSinceEpoch !== 0) {
      obj.lastUpdateTimeSinceEpoch = Math.round(message.lastUpdateTimeSinceEpoch);
    }
    if (message.systemMetadata !== undefined) {
      obj.systemMetadata = Any.toJSON(message.systemMetadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Execution>, I>>(base?: I): Execution {
    return Execution.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Execution>, I>>(object: I): Execution {
    const message = createBaseExecution();
    message.id = object.id ?? 0;
    message.name = object.name ?? '';
    message.typeId = object.typeId ?? 0;
    message.type = object.type ?? '';
    message.externalId = object.externalId ?? '';
    message.lastKnownState = object.lastKnownState ?? 0;
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: Value }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Value.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.customProperties = Object.entries(object.customProperties ?? {}).reduce<{
      [key: string]: Value;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Value.fromPartial(value);
      }
      return acc;
    }, {});
    message.createTimeSinceEpoch = object.createTimeSinceEpoch ?? 0;
    message.lastUpdateTimeSinceEpoch = object.lastUpdateTimeSinceEpoch ?? 0;
    message.systemMetadata =
      object.systemMetadata !== undefined && object.systemMetadata !== null
        ? Any.fromPartial(object.systemMetadata)
        : undefined;
    return message;
  },
};

function createBaseExecution_PropertiesEntry(): Execution_PropertiesEntry {
  return { key: '', value: undefined };
}

export const Execution_PropertiesEntry = {
  encode(message: Execution_PropertiesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Execution_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecution_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Execution_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : '',
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Execution_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== '') {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Execution_PropertiesEntry>, I>>(
    base?: I,
  ): Execution_PropertiesEntry {
    return Execution_PropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Execution_PropertiesEntry>, I>>(
    object: I,
  ): Execution_PropertiesEntry {
    const message = createBaseExecution_PropertiesEntry();
    message.key = object.key ?? '';
    message.value =
      object.value !== undefined && object.value !== null
        ? Value.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseExecution_CustomPropertiesEntry(): Execution_CustomPropertiesEntry {
  return { key: '', value: undefined };
}

export const Execution_CustomPropertiesEntry = {
  encode(
    message: Execution_CustomPropertiesEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Execution_CustomPropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecution_CustomPropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Execution_CustomPropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : '',
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Execution_CustomPropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== '') {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Execution_CustomPropertiesEntry>, I>>(
    base?: I,
  ): Execution_CustomPropertiesEntry {
    return Execution_CustomPropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Execution_CustomPropertiesEntry>, I>>(
    object: I,
  ): Execution_CustomPropertiesEntry {
    const message = createBaseExecution_CustomPropertiesEntry();
    message.key = object.key ?? '';
    message.value =
      object.value !== undefined && object.value !== null
        ? Value.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseExecutionType(): ExecutionType {
  return {
    id: 0,
    name: '',
    version: '',
    description: '',
    externalId: '',
    properties: {},
    inputType: undefined,
    outputType: undefined,
    baseType: 0,
  };
}

export const ExecutionType = {
  encode(message: ExecutionType, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    if (message.name !== undefined && message.name !== '') {
      writer.uint32(18).string(message.name);
    }
    if (message.version !== undefined && message.version !== '') {
      writer.uint32(50).string(message.version);
    }
    if (message.description !== undefined && message.description !== '') {
      writer.uint32(58).string(message.description);
    }
    if (message.externalId !== undefined && message.externalId !== '') {
      writer.uint32(74).string(message.externalId);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      ExecutionType_PropertiesEntry.encode(
        { key: key as any, value },
        writer.uint32(26).fork(),
      ).ldelim();
    });
    if (message.inputType !== undefined) {
      ArtifactStructType.encode(message.inputType, writer.uint32(34).fork()).ldelim();
    }
    if (message.outputType !== undefined) {
      ArtifactStructType.encode(message.outputType, writer.uint32(42).fork()).ldelim();
    }
    if (message.baseType !== undefined && message.baseType !== 0) {
      writer.uint32(64).int32(message.baseType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecutionType {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.version = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.externalId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = ExecutionType_PropertiesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.properties[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.inputType = ArtifactStructType.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.outputType = ArtifactStructType.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.baseType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionType {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      version: isSet(object.version) ? globalThis.String(object.version) : '',
      description: isSet(object.description) ? globalThis.String(object.description) : '',
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : '',
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: PropertyType }>(
            (acc, [key, value]) => {
              acc[key] = propertyTypeFromJSON(value);
              return acc;
            },
            {},
          )
        : {},
      inputType: isSet(object.inputType)
        ? ArtifactStructType.fromJSON(object.inputType)
        : undefined,
      outputType: isSet(object.outputType)
        ? ArtifactStructType.fromJSON(object.outputType)
        : undefined,
      baseType: isSet(object.baseType)
        ? executionType_SystemDefinedBaseTypeFromJSON(object.baseType)
        : 0,
    };
  },

  toJSON(message: ExecutionType): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined && message.name !== '') {
      obj.name = message.name;
    }
    if (message.version !== undefined && message.version !== '') {
      obj.version = message.version;
    }
    if (message.description !== undefined && message.description !== '') {
      obj.description = message.description;
    }
    if (message.externalId !== undefined && message.externalId !== '') {
      obj.externalId = message.externalId;
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = propertyTypeToJSON(v);
        });
      }
    }
    if (message.inputType !== undefined) {
      obj.inputType = ArtifactStructType.toJSON(message.inputType);
    }
    if (message.outputType !== undefined) {
      obj.outputType = ArtifactStructType.toJSON(message.outputType);
    }
    if (message.baseType !== undefined && message.baseType !== 0) {
      obj.baseType = executionType_SystemDefinedBaseTypeToJSON(message.baseType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionType>, I>>(base?: I): ExecutionType {
    return ExecutionType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionType>, I>>(object: I): ExecutionType {
    const message = createBaseExecutionType();
    message.id = object.id ?? 0;
    message.name = object.name ?? '';
    message.version = object.version ?? '';
    message.description = object.description ?? '';
    message.externalId = object.externalId ?? '';
    message.properties = Object.entries(object.properties ?? {}).reduce<{
      [key: string]: PropertyType;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value as PropertyType;
      }
      return acc;
    }, {});
    message.inputType =
      object.inputType !== undefined && object.inputType !== null
        ? ArtifactStructType.fromPartial(object.inputType)
        : undefined;
    message.outputType =
      object.outputType !== undefined && object.outputType !== null
        ? ArtifactStructType.fromPartial(object.outputType)
        : undefined;
    message.baseType = object.baseType ?? 0;
    return message;
  },
};

function createBaseExecutionType_PropertiesEntry(): ExecutionType_PropertiesEntry {
  return { key: '', value: 0 };
}

export const ExecutionType_PropertiesEntry = {
  encode(
    message: ExecutionType_PropertiesEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecutionType_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionType_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionType_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : '',
      value: isSet(object.value) ? propertyTypeFromJSON(object.value) : 0,
    };
  },

  toJSON(message: ExecutionType_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== '') {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = propertyTypeToJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionType_PropertiesEntry>, I>>(
    base?: I,
  ): ExecutionType_PropertiesEntry {
    return ExecutionType_PropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionType_PropertiesEntry>, I>>(
    object: I,
  ): ExecutionType_PropertiesEntry {
    const message = createBaseExecutionType_PropertiesEntry();
    message.key = object.key ?? '';
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseContextType(): ContextType {
  return {
    id: 0,
    name: '',
    version: '',
    description: '',
    externalId: '',
    properties: {},
    baseType: 0,
  };
}

export const ContextType = {
  encode(message: ContextType, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    if (message.name !== undefined && message.name !== '') {
      writer.uint32(18).string(message.name);
    }
    if (message.version !== undefined && message.version !== '') {
      writer.uint32(34).string(message.version);
    }
    if (message.description !== undefined && message.description !== '') {
      writer.uint32(42).string(message.description);
    }
    if (message.externalId !== undefined && message.externalId !== '') {
      writer.uint32(58).string(message.externalId);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      ContextType_PropertiesEntry.encode(
        { key: key as any, value },
        writer.uint32(26).fork(),
      ).ldelim();
    });
    if (message.baseType !== undefined && message.baseType !== 0) {
      writer.uint32(48).int32(message.baseType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ContextType {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContextType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.version = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.externalId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = ContextType_PropertiesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.properties[entry3.key] = entry3.value;
          }
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.baseType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContextType {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      version: isSet(object.version) ? globalThis.String(object.version) : '',
      description: isSet(object.description) ? globalThis.String(object.description) : '',
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : '',
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: PropertyType }>(
            (acc, [key, value]) => {
              acc[key] = propertyTypeFromJSON(value);
              return acc;
            },
            {},
          )
        : {},
      baseType: isSet(object.baseType)
        ? contextType_SystemDefinedBaseTypeFromJSON(object.baseType)
        : 0,
    };
  },

  toJSON(message: ContextType): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined && message.name !== '') {
      obj.name = message.name;
    }
    if (message.version !== undefined && message.version !== '') {
      obj.version = message.version;
    }
    if (message.description !== undefined && message.description !== '') {
      obj.description = message.description;
    }
    if (message.externalId !== undefined && message.externalId !== '') {
      obj.externalId = message.externalId;
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = propertyTypeToJSON(v);
        });
      }
    }
    if (message.baseType !== undefined && message.baseType !== 0) {
      obj.baseType = contextType_SystemDefinedBaseTypeToJSON(message.baseType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContextType>, I>>(base?: I): ContextType {
    return ContextType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContextType>, I>>(object: I): ContextType {
    const message = createBaseContextType();
    message.id = object.id ?? 0;
    message.name = object.name ?? '';
    message.version = object.version ?? '';
    message.description = object.description ?? '';
    message.externalId = object.externalId ?? '';
    message.properties = Object.entries(object.properties ?? {}).reduce<{
      [key: string]: PropertyType;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value as PropertyType;
      }
      return acc;
    }, {});
    message.baseType = object.baseType ?? 0;
    return message;
  },
};

function createBaseContextType_PropertiesEntry(): ContextType_PropertiesEntry {
  return { key: '', value: 0 };
}

export const ContextType_PropertiesEntry = {
  encode(
    message: ContextType_PropertiesEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ContextType_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContextType_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContextType_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : '',
      value: isSet(object.value) ? propertyTypeFromJSON(object.value) : 0,
    };
  },

  toJSON(message: ContextType_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== '') {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = propertyTypeToJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContextType_PropertiesEntry>, I>>(
    base?: I,
  ): ContextType_PropertiesEntry {
    return ContextType_PropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContextType_PropertiesEntry>, I>>(
    object: I,
  ): ContextType_PropertiesEntry {
    const message = createBaseContextType_PropertiesEntry();
    message.key = object.key ?? '';
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseContext(): Context {
  return {
    id: 0,
    name: '',
    typeId: 0,
    type: '',
    externalId: '',
    properties: {},
    customProperties: {},
    createTimeSinceEpoch: 0,
    lastUpdateTimeSinceEpoch: 0,
    systemMetadata: undefined,
  };
}

export const Context = {
  encode(message: Context, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    if (message.name !== undefined && message.name !== '') {
      writer.uint32(26).string(message.name);
    }
    if (message.typeId !== undefined && message.typeId !== 0) {
      writer.uint32(16).int64(message.typeId);
    }
    if (message.type !== undefined && message.type !== '') {
      writer.uint32(50).string(message.type);
    }
    if (message.externalId !== undefined && message.externalId !== '') {
      writer.uint32(74).string(message.externalId);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      Context_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    Object.entries(message.customProperties).forEach(([key, value]) => {
      Context_CustomPropertiesEntry.encode(
        { key: key as any, value },
        writer.uint32(42).fork(),
      ).ldelim();
    });
    if (message.createTimeSinceEpoch !== undefined && message.createTimeSinceEpoch !== 0) {
      writer.uint32(56).int64(message.createTimeSinceEpoch);
    }
    if (message.lastUpdateTimeSinceEpoch !== undefined && message.lastUpdateTimeSinceEpoch !== 0) {
      writer.uint32(64).int64(message.lastUpdateTimeSinceEpoch);
    }
    if (message.systemMetadata !== undefined) {
      Any.encode(message.systemMetadata, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Context {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.typeId = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.externalId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Context_PropertiesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.properties[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Context_CustomPropertiesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.customProperties[entry5.key] = entry5.value;
          }
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.createTimeSinceEpoch = longToNumber(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.lastUpdateTimeSinceEpoch = longToNumber(reader.int64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.systemMetadata = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Context {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      typeId: isSet(object.typeId) ? globalThis.Number(object.typeId) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : '',
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : '',
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: Value }>(
            (acc, [key, value]) => {
              acc[key] = Value.fromJSON(value);
              return acc;
            },
            {},
          )
        : {},
      customProperties: isObject(object.customProperties)
        ? Object.entries(object.customProperties).reduce<{ [key: string]: Value }>(
            (acc, [key, value]) => {
              acc[key] = Value.fromJSON(value);
              return acc;
            },
            {},
          )
        : {},
      createTimeSinceEpoch: isSet(object.createTimeSinceEpoch)
        ? globalThis.Number(object.createTimeSinceEpoch)
        : 0,
      lastUpdateTimeSinceEpoch: isSet(object.lastUpdateTimeSinceEpoch)
        ? globalThis.Number(object.lastUpdateTimeSinceEpoch)
        : 0,
      systemMetadata: isSet(object.systemMetadata)
        ? Any.fromJSON(object.systemMetadata)
        : undefined,
    };
  },

  toJSON(message: Context): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined && message.name !== '') {
      obj.name = message.name;
    }
    if (message.typeId !== undefined && message.typeId !== 0) {
      obj.typeId = Math.round(message.typeId);
    }
    if (message.type !== undefined && message.type !== '') {
      obj.type = message.type;
    }
    if (message.externalId !== undefined && message.externalId !== '') {
      obj.externalId = message.externalId;
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = Value.toJSON(v);
        });
      }
    }
    if (message.customProperties) {
      const entries = Object.entries(message.customProperties);
      if (entries.length > 0) {
        obj.customProperties = {};
        entries.forEach(([k, v]) => {
          obj.customProperties[k] = Value.toJSON(v);
        });
      }
    }
    if (message.createTimeSinceEpoch !== undefined && message.createTimeSinceEpoch !== 0) {
      obj.createTimeSinceEpoch = Math.round(message.createTimeSinceEpoch);
    }
    if (message.lastUpdateTimeSinceEpoch !== undefined && message.lastUpdateTimeSinceEpoch !== 0) {
      obj.lastUpdateTimeSinceEpoch = Math.round(message.lastUpdateTimeSinceEpoch);
    }
    if (message.systemMetadata !== undefined) {
      obj.systemMetadata = Any.toJSON(message.systemMetadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Context>, I>>(base?: I): Context {
    return Context.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Context>, I>>(object: I): Context {
    const message = createBaseContext();
    message.id = object.id ?? 0;
    message.name = object.name ?? '';
    message.typeId = object.typeId ?? 0;
    message.type = object.type ?? '';
    message.externalId = object.externalId ?? '';
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: Value }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Value.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.customProperties = Object.entries(object.customProperties ?? {}).reduce<{
      [key: string]: Value;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Value.fromPartial(value);
      }
      return acc;
    }, {});
    message.createTimeSinceEpoch = object.createTimeSinceEpoch ?? 0;
    message.lastUpdateTimeSinceEpoch = object.lastUpdateTimeSinceEpoch ?? 0;
    message.systemMetadata =
      object.systemMetadata !== undefined && object.systemMetadata !== null
        ? Any.fromPartial(object.systemMetadata)
        : undefined;
    return message;
  },
};

function createBaseContext_PropertiesEntry(): Context_PropertiesEntry {
  return { key: '', value: undefined };
}

export const Context_PropertiesEntry = {
  encode(message: Context_PropertiesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Context_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContext_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Context_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : '',
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Context_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== '') {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Context_PropertiesEntry>, I>>(
    base?: I,
  ): Context_PropertiesEntry {
    return Context_PropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Context_PropertiesEntry>, I>>(
    object: I,
  ): Context_PropertiesEntry {
    const message = createBaseContext_PropertiesEntry();
    message.key = object.key ?? '';
    message.value =
      object.value !== undefined && object.value !== null
        ? Value.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseContext_CustomPropertiesEntry(): Context_CustomPropertiesEntry {
  return { key: '', value: undefined };
}

export const Context_CustomPropertiesEntry = {
  encode(
    message: Context_CustomPropertiesEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Context_CustomPropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContext_CustomPropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Context_CustomPropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : '',
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Context_CustomPropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== '') {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Context_CustomPropertiesEntry>, I>>(
    base?: I,
  ): Context_CustomPropertiesEntry {
    return Context_CustomPropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Context_CustomPropertiesEntry>, I>>(
    object: I,
  ): Context_CustomPropertiesEntry {
    const message = createBaseContext_CustomPropertiesEntry();
    message.key = object.key ?? '';
    message.value =
      object.value !== undefined && object.value !== null
        ? Value.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseAttribution(): Attribution {
  return { artifactId: 0, contextId: 0 };
}

export const Attribution = {
  encode(message: Attribution, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.artifactId !== undefined && message.artifactId !== 0) {
      writer.uint32(8).int64(message.artifactId);
    }
    if (message.contextId !== undefined && message.contextId !== 0) {
      writer.uint32(16).int64(message.contextId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Attribution {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttribution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.artifactId = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.contextId = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attribution {
    return {
      artifactId: isSet(object.artifactId) ? globalThis.Number(object.artifactId) : 0,
      contextId: isSet(object.contextId) ? globalThis.Number(object.contextId) : 0,
    };
  },

  toJSON(message: Attribution): unknown {
    const obj: any = {};
    if (message.artifactId !== undefined && message.artifactId !== 0) {
      obj.artifactId = Math.round(message.artifactId);
    }
    if (message.contextId !== undefined && message.contextId !== 0) {
      obj.contextId = Math.round(message.contextId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Attribution>, I>>(base?: I): Attribution {
    return Attribution.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Attribution>, I>>(object: I): Attribution {
    const message = createBaseAttribution();
    message.artifactId = object.artifactId ?? 0;
    message.contextId = object.contextId ?? 0;
    return message;
  },
};

function createBaseAssociation(): Association {
  return { executionId: 0, contextId: 0 };
}

export const Association = {
  encode(message: Association, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.executionId !== undefined && message.executionId !== 0) {
      writer.uint32(8).int64(message.executionId);
    }
    if (message.contextId !== undefined && message.contextId !== 0) {
      writer.uint32(16).int64(message.contextId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Association {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssociation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.executionId = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.contextId = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Association {
    return {
      executionId: isSet(object.executionId) ? globalThis.Number(object.executionId) : 0,
      contextId: isSet(object.contextId) ? globalThis.Number(object.contextId) : 0,
    };
  },

  toJSON(message: Association): unknown {
    const obj: any = {};
    if (message.executionId !== undefined && message.executionId !== 0) {
      obj.executionId = Math.round(message.executionId);
    }
    if (message.contextId !== undefined && message.contextId !== 0) {
      obj.contextId = Math.round(message.contextId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Association>, I>>(base?: I): Association {
    return Association.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Association>, I>>(object: I): Association {
    const message = createBaseAssociation();
    message.executionId = object.executionId ?? 0;
    message.contextId = object.contextId ?? 0;
    return message;
  },
};

function createBaseParentContext(): ParentContext {
  return { childId: 0, parentId: 0 };
}

export const ParentContext = {
  encode(message: ParentContext, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.childId !== undefined && message.childId !== 0) {
      writer.uint32(8).int64(message.childId);
    }
    if (message.parentId !== undefined && message.parentId !== 0) {
      writer.uint32(16).int64(message.parentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ParentContext {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParentContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.childId = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.parentId = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParentContext {
    return {
      childId: isSet(object.childId) ? globalThis.Number(object.childId) : 0,
      parentId: isSet(object.parentId) ? globalThis.Number(object.parentId) : 0,
    };
  },

  toJSON(message: ParentContext): unknown {
    const obj: any = {};
    if (message.childId !== undefined && message.childId !== 0) {
      obj.childId = Math.round(message.childId);
    }
    if (message.parentId !== undefined && message.parentId !== 0) {
      obj.parentId = Math.round(message.parentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParentContext>, I>>(base?: I): ParentContext {
    return ParentContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParentContext>, I>>(object: I): ParentContext {
    const message = createBaseParentContext();
    message.childId = object.childId ?? 0;
    message.parentId = object.parentId ?? 0;
    return message;
  },
};

function createBaseLineageGraph(): LineageGraph {
  return {
    artifactTypes: [],
    executionTypes: [],
    contextTypes: [],
    artifacts: [],
    executions: [],
    contexts: [],
    events: [],
    attributions: [],
    associations: [],
  };
}

export const LineageGraph = {
  encode(message: LineageGraph, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.artifactTypes) {
      ArtifactType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.executionTypes) {
      ExecutionType.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.contextTypes) {
      ContextType.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.artifacts) {
      Artifact.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.executions) {
      Execution.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.contexts) {
      Context.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.events) {
      Event.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.attributions) {
      Attribution.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.associations) {
      Association.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LineageGraph {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineageGraph();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactTypes.push(ArtifactType.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.executionTypes.push(ExecutionType.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contextTypes.push(ContextType.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.artifacts.push(Artifact.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.executions.push(Execution.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.contexts.push(Context.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.events.push(Event.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.attributions.push(Attribution.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.associations.push(Association.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LineageGraph {
    return {
      artifactTypes: globalThis.Array.isArray(object?.artifactTypes)
        ? object.artifactTypes.map((e: any) => ArtifactType.fromJSON(e))
        : [],
      executionTypes: globalThis.Array.isArray(object?.executionTypes)
        ? object.executionTypes.map((e: any) => ExecutionType.fromJSON(e))
        : [],
      contextTypes: globalThis.Array.isArray(object?.contextTypes)
        ? object.contextTypes.map((e: any) => ContextType.fromJSON(e))
        : [],
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => Artifact.fromJSON(e))
        : [],
      executions: globalThis.Array.isArray(object?.executions)
        ? object.executions.map((e: any) => Execution.fromJSON(e))
        : [],
      contexts: globalThis.Array.isArray(object?.contexts)
        ? object.contexts.map((e: any) => Context.fromJSON(e))
        : [],
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => Event.fromJSON(e))
        : [],
      attributions: globalThis.Array.isArray(object?.attributions)
        ? object.attributions.map((e: any) => Attribution.fromJSON(e))
        : [],
      associations: globalThis.Array.isArray(object?.associations)
        ? object.associations.map((e: any) => Association.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LineageGraph): unknown {
    const obj: any = {};
    if (message.artifactTypes?.length) {
      obj.artifactTypes = message.artifactTypes.map((e) => ArtifactType.toJSON(e));
    }
    if (message.executionTypes?.length) {
      obj.executionTypes = message.executionTypes.map((e) => ExecutionType.toJSON(e));
    }
    if (message.contextTypes?.length) {
      obj.contextTypes = message.contextTypes.map((e) => ContextType.toJSON(e));
    }
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => Artifact.toJSON(e));
    }
    if (message.executions?.length) {
      obj.executions = message.executions.map((e) => Execution.toJSON(e));
    }
    if (message.contexts?.length) {
      obj.contexts = message.contexts.map((e) => Context.toJSON(e));
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event.toJSON(e));
    }
    if (message.attributions?.length) {
      obj.attributions = message.attributions.map((e) => Attribution.toJSON(e));
    }
    if (message.associations?.length) {
      obj.associations = message.associations.map((e) => Association.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LineageGraph>, I>>(base?: I): LineageGraph {
    return LineageGraph.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LineageGraph>, I>>(object: I): LineageGraph {
    const message = createBaseLineageGraph();
    message.artifactTypes = object.artifactTypes?.map((e) => ArtifactType.fromPartial(e)) || [];
    message.executionTypes = object.executionTypes?.map((e) => ExecutionType.fromPartial(e)) || [];
    message.contextTypes = object.contextTypes?.map((e) => ContextType.fromPartial(e)) || [];
    message.artifacts = object.artifacts?.map((e) => Artifact.fromPartial(e)) || [];
    message.executions = object.executions?.map((e) => Execution.fromPartial(e)) || [];
    message.contexts = object.contexts?.map((e) => Context.fromPartial(e)) || [];
    message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
    message.attributions = object.attributions?.map((e) => Attribution.fromPartial(e)) || [];
    message.associations = object.associations?.map((e) => Association.fromPartial(e)) || [];
    return message;
  },
};

function createBaseArtifactStructType(): ArtifactStructType {
  return {
    simple: undefined,
    unionType: undefined,
    intersection: undefined,
    list: undefined,
    none: undefined,
    any: undefined,
    tuple: undefined,
    dict: undefined,
  };
}

export const ArtifactStructType = {
  encode(message: ArtifactStructType, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.simple !== undefined) {
      ArtifactType.encode(message.simple, writer.uint32(10).fork()).ldelim();
    }
    if (message.unionType !== undefined) {
      UnionArtifactStructType.encode(message.unionType, writer.uint32(18).fork()).ldelim();
    }
    if (message.intersection !== undefined) {
      IntersectionArtifactStructType.encode(
        message.intersection,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    if (message.list !== undefined) {
      ListArtifactStructType.encode(message.list, writer.uint32(34).fork()).ldelim();
    }
    if (message.none !== undefined) {
      NoneArtifactStructType.encode(message.none, writer.uint32(42).fork()).ldelim();
    }
    if (message.any !== undefined) {
      AnyArtifactStructType.encode(message.any, writer.uint32(50).fork()).ldelim();
    }
    if (message.tuple !== undefined) {
      TupleArtifactStructType.encode(message.tuple, writer.uint32(58).fork()).ldelim();
    }
    if (message.dict !== undefined) {
      DictArtifactStructType.encode(message.dict, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ArtifactStructType {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactStructType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.simple = ArtifactType.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.unionType = UnionArtifactStructType.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.intersection = IntersectionArtifactStructType.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.list = ListArtifactStructType.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.none = NoneArtifactStructType.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.any = AnyArtifactStructType.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.tuple = TupleArtifactStructType.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.dict = DictArtifactStructType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactStructType {
    return {
      simple: isSet(object.simple) ? ArtifactType.fromJSON(object.simple) : undefined,
      unionType: isSet(object.unionType)
        ? UnionArtifactStructType.fromJSON(object.unionType)
        : undefined,
      intersection: isSet(object.intersection)
        ? IntersectionArtifactStructType.fromJSON(object.intersection)
        : undefined,
      list: isSet(object.list) ? ListArtifactStructType.fromJSON(object.list) : undefined,
      none: isSet(object.none) ? NoneArtifactStructType.fromJSON(object.none) : undefined,
      any: isSet(object.any) ? AnyArtifactStructType.fromJSON(object.any) : undefined,
      tuple: isSet(object.tuple) ? TupleArtifactStructType.fromJSON(object.tuple) : undefined,
      dict: isSet(object.dict) ? DictArtifactStructType.fromJSON(object.dict) : undefined,
    };
  },

  toJSON(message: ArtifactStructType): unknown {
    const obj: any = {};
    if (message.simple !== undefined) {
      obj.simple = ArtifactType.toJSON(message.simple);
    }
    if (message.unionType !== undefined) {
      obj.unionType = UnionArtifactStructType.toJSON(message.unionType);
    }
    if (message.intersection !== undefined) {
      obj.intersection = IntersectionArtifactStructType.toJSON(message.intersection);
    }
    if (message.list !== undefined) {
      obj.list = ListArtifactStructType.toJSON(message.list);
    }
    if (message.none !== undefined) {
      obj.none = NoneArtifactStructType.toJSON(message.none);
    }
    if (message.any !== undefined) {
      obj.any = AnyArtifactStructType.toJSON(message.any);
    }
    if (message.tuple !== undefined) {
      obj.tuple = TupleArtifactStructType.toJSON(message.tuple);
    }
    if (message.dict !== undefined) {
      obj.dict = DictArtifactStructType.toJSON(message.dict);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArtifactStructType>, I>>(base?: I): ArtifactStructType {
    return ArtifactStructType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArtifactStructType>, I>>(object: I): ArtifactStructType {
    const message = createBaseArtifactStructType();
    message.simple =
      object.simple !== undefined && object.simple !== null
        ? ArtifactType.fromPartial(object.simple)
        : undefined;
    message.unionType =
      object.unionType !== undefined && object.unionType !== null
        ? UnionArtifactStructType.fromPartial(object.unionType)
        : undefined;
    message.intersection =
      object.intersection !== undefined && object.intersection !== null
        ? IntersectionArtifactStructType.fromPartial(object.intersection)
        : undefined;
    message.list =
      object.list !== undefined && object.list !== null
        ? ListArtifactStructType.fromPartial(object.list)
        : undefined;
    message.none =
      object.none !== undefined && object.none !== null
        ? NoneArtifactStructType.fromPartial(object.none)
        : undefined;
    message.any =
      object.any !== undefined && object.any !== null
        ? AnyArtifactStructType.fromPartial(object.any)
        : undefined;
    message.tuple =
      object.tuple !== undefined && object.tuple !== null
        ? TupleArtifactStructType.fromPartial(object.tuple)
        : undefined;
    message.dict =
      object.dict !== undefined && object.dict !== null
        ? DictArtifactStructType.fromPartial(object.dict)
        : undefined;
    return message;
  },
};

function createBaseUnionArtifactStructType(): UnionArtifactStructType {
  return { candidates: [] };
}

export const UnionArtifactStructType = {
  encode(message: UnionArtifactStructType, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.candidates) {
      ArtifactStructType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnionArtifactStructType {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnionArtifactStructType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.candidates.push(ArtifactStructType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnionArtifactStructType {
    return {
      candidates: globalThis.Array.isArray(object?.candidates)
        ? object.candidates.map((e: any) => ArtifactStructType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UnionArtifactStructType): unknown {
    const obj: any = {};
    if (message.candidates?.length) {
      obj.candidates = message.candidates.map((e) => ArtifactStructType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnionArtifactStructType>, I>>(
    base?: I,
  ): UnionArtifactStructType {
    return UnionArtifactStructType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnionArtifactStructType>, I>>(
    object: I,
  ): UnionArtifactStructType {
    const message = createBaseUnionArtifactStructType();
    message.candidates = object.candidates?.map((e) => ArtifactStructType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIntersectionArtifactStructType(): IntersectionArtifactStructType {
  return { constraints: [] };
}

export const IntersectionArtifactStructType = {
  encode(
    message: IntersectionArtifactStructType,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.constraints) {
      ArtifactStructType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IntersectionArtifactStructType {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntersectionArtifactStructType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.constraints.push(ArtifactStructType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntersectionArtifactStructType {
    return {
      constraints: globalThis.Array.isArray(object?.constraints)
        ? object.constraints.map((e: any) => ArtifactStructType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IntersectionArtifactStructType): unknown {
    const obj: any = {};
    if (message.constraints?.length) {
      obj.constraints = message.constraints.map((e) => ArtifactStructType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IntersectionArtifactStructType>, I>>(
    base?: I,
  ): IntersectionArtifactStructType {
    return IntersectionArtifactStructType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IntersectionArtifactStructType>, I>>(
    object: I,
  ): IntersectionArtifactStructType {
    const message = createBaseIntersectionArtifactStructType();
    message.constraints = object.constraints?.map((e) => ArtifactStructType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListArtifactStructType(): ListArtifactStructType {
  return { element: undefined };
}

export const ListArtifactStructType = {
  encode(message: ListArtifactStructType, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.element !== undefined) {
      ArtifactStructType.encode(message.element, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListArtifactStructType {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListArtifactStructType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.element = ArtifactStructType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListArtifactStructType {
    return {
      element: isSet(object.element) ? ArtifactStructType.fromJSON(object.element) : undefined,
    };
  },

  toJSON(message: ListArtifactStructType): unknown {
    const obj: any = {};
    if (message.element !== undefined) {
      obj.element = ArtifactStructType.toJSON(message.element);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListArtifactStructType>, I>>(
    base?: I,
  ): ListArtifactStructType {
    return ListArtifactStructType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListArtifactStructType>, I>>(
    object: I,
  ): ListArtifactStructType {
    const message = createBaseListArtifactStructType();
    message.element =
      object.element !== undefined && object.element !== null
        ? ArtifactStructType.fromPartial(object.element)
        : undefined;
    return message;
  },
};

function createBaseNoneArtifactStructType(): NoneArtifactStructType {
  return {};
}

export const NoneArtifactStructType = {
  encode(_: NoneArtifactStructType, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NoneArtifactStructType {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoneArtifactStructType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NoneArtifactStructType {
    return {};
  },

  toJSON(_: NoneArtifactStructType): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NoneArtifactStructType>, I>>(
    base?: I,
  ): NoneArtifactStructType {
    return NoneArtifactStructType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NoneArtifactStructType>, I>>(
    _: I,
  ): NoneArtifactStructType {
    const message = createBaseNoneArtifactStructType();
    return message;
  },
};

function createBaseAnyArtifactStructType(): AnyArtifactStructType {
  return {};
}

export const AnyArtifactStructType = {
  encode(_: AnyArtifactStructType, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnyArtifactStructType {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnyArtifactStructType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AnyArtifactStructType {
    return {};
  },

  toJSON(_: AnyArtifactStructType): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AnyArtifactStructType>, I>>(base?: I): AnyArtifactStructType {
    return AnyArtifactStructType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnyArtifactStructType>, I>>(_: I): AnyArtifactStructType {
    const message = createBaseAnyArtifactStructType();
    return message;
  },
};

function createBaseTupleArtifactStructType(): TupleArtifactStructType {
  return { elements: [] };
}

export const TupleArtifactStructType = {
  encode(message: TupleArtifactStructType, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.elements) {
      ArtifactStructType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TupleArtifactStructType {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTupleArtifactStructType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.elements.push(ArtifactStructType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TupleArtifactStructType {
    return {
      elements: globalThis.Array.isArray(object?.elements)
        ? object.elements.map((e: any) => ArtifactStructType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TupleArtifactStructType): unknown {
    const obj: any = {};
    if (message.elements?.length) {
      obj.elements = message.elements.map((e) => ArtifactStructType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TupleArtifactStructType>, I>>(
    base?: I,
  ): TupleArtifactStructType {
    return TupleArtifactStructType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TupleArtifactStructType>, I>>(
    object: I,
  ): TupleArtifactStructType {
    const message = createBaseTupleArtifactStructType();
    message.elements = object.elements?.map((e) => ArtifactStructType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDictArtifactStructType(): DictArtifactStructType {
  return { properties: {}, noneTypeNotRequired: false, extraPropertiesType: undefined };
}

export const DictArtifactStructType = {
  encode(message: DictArtifactStructType, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.properties).forEach(([key, value]) => {
      DictArtifactStructType_PropertiesEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).ldelim();
    });
    if (message.noneTypeNotRequired !== undefined && message.noneTypeNotRequired !== false) {
      writer.uint32(16).bool(message.noneTypeNotRequired);
    }
    if (message.extraPropertiesType !== undefined) {
      ArtifactStructType.encode(message.extraPropertiesType, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DictArtifactStructType {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDictArtifactStructType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = DictArtifactStructType_PropertiesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.properties[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.noneTypeNotRequired = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.extraPropertiesType = ArtifactStructType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DictArtifactStructType {
    return {
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: ArtifactStructType }>(
            (acc, [key, value]) => {
              acc[key] = ArtifactStructType.fromJSON(value);
              return acc;
            },
            {},
          )
        : {},
      noneTypeNotRequired: isSet(object.noneTypeNotRequired)
        ? globalThis.Boolean(object.noneTypeNotRequired)
        : false,
      extraPropertiesType: isSet(object.extraPropertiesType)
        ? ArtifactStructType.fromJSON(object.extraPropertiesType)
        : undefined,
    };
  },

  toJSON(message: DictArtifactStructType): unknown {
    const obj: any = {};
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = ArtifactStructType.toJSON(v);
        });
      }
    }
    if (message.noneTypeNotRequired !== undefined && message.noneTypeNotRequired !== false) {
      obj.noneTypeNotRequired = message.noneTypeNotRequired;
    }
    if (message.extraPropertiesType !== undefined) {
      obj.extraPropertiesType = ArtifactStructType.toJSON(message.extraPropertiesType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DictArtifactStructType>, I>>(
    base?: I,
  ): DictArtifactStructType {
    return DictArtifactStructType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DictArtifactStructType>, I>>(
    object: I,
  ): DictArtifactStructType {
    const message = createBaseDictArtifactStructType();
    message.properties = Object.entries(object.properties ?? {}).reduce<{
      [key: string]: ArtifactStructType;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = ArtifactStructType.fromPartial(value);
      }
      return acc;
    }, {});
    message.noneTypeNotRequired = object.noneTypeNotRequired ?? false;
    message.extraPropertiesType =
      object.extraPropertiesType !== undefined && object.extraPropertiesType !== null
        ? ArtifactStructType.fromPartial(object.extraPropertiesType)
        : undefined;
    return message;
  },
};

function createBaseDictArtifactStructType_PropertiesEntry(): DictArtifactStructType_PropertiesEntry {
  return { key: '', value: undefined };
}

export const DictArtifactStructType_PropertiesEntry = {
  encode(
    message: DictArtifactStructType_PropertiesEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ArtifactStructType.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DictArtifactStructType_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDictArtifactStructType_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ArtifactStructType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DictArtifactStructType_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : '',
      value: isSet(object.value) ? ArtifactStructType.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: DictArtifactStructType_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== '') {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ArtifactStructType.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DictArtifactStructType_PropertiesEntry>, I>>(
    base?: I,
  ): DictArtifactStructType_PropertiesEntry {
    return DictArtifactStructType_PropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DictArtifactStructType_PropertiesEntry>, I>>(
    object: I,
  ): DictArtifactStructType_PropertiesEntry {
    const message = createBaseDictArtifactStructType_PropertiesEntry();
    message.key = object.key ?? '';
    message.value =
      object.value !== undefined && object.value !== null
        ? ArtifactStructType.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseFakeDatabaseConfig(): FakeDatabaseConfig {
  return {};
}

export const FakeDatabaseConfig = {
  encode(_: FakeDatabaseConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FakeDatabaseConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFakeDatabaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FakeDatabaseConfig {
    return {};
  },

  toJSON(_: FakeDatabaseConfig): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<FakeDatabaseConfig>, I>>(base?: I): FakeDatabaseConfig {
    return FakeDatabaseConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FakeDatabaseConfig>, I>>(_: I): FakeDatabaseConfig {
    const message = createBaseFakeDatabaseConfig();
    return message;
  },
};

function createBaseMySQLDatabaseConfig(): MySQLDatabaseConfig {
  return {
    host: '',
    port: 0,
    database: '',
    user: '',
    password: '',
    socket: '',
    sslOptions: undefined,
    skipDbCreation: false,
  };
}

export const MySQLDatabaseConfig = {
  encode(message: MySQLDatabaseConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.host !== undefined && message.host !== '') {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== undefined && message.port !== 0) {
      writer.uint32(16).int64(message.port);
    }
    if (message.database !== undefined && message.database !== '') {
      writer.uint32(26).string(message.database);
    }
    if (message.user !== undefined && message.user !== '') {
      writer.uint32(34).string(message.user);
    }
    if (message.password !== undefined && message.password !== '') {
      writer.uint32(42).string(message.password);
    }
    if (message.socket !== undefined && message.socket !== '') {
      writer.uint32(50).string(message.socket);
    }
    if (message.sslOptions !== undefined) {
      MySQLDatabaseConfig_SSLOptions.encode(message.sslOptions, writer.uint32(58).fork()).ldelim();
    }
    if (message.skipDbCreation !== undefined && message.skipDbCreation !== false) {
      writer.uint32(64).bool(message.skipDbCreation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MySQLDatabaseConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMySQLDatabaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.database = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.user = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.password = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.socket = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.sslOptions = MySQLDatabaseConfig_SSLOptions.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.skipDbCreation = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MySQLDatabaseConfig {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : '',
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      database: isSet(object.database) ? globalThis.String(object.database) : '',
      user: isSet(object.user) ? globalThis.String(object.user) : '',
      password: isSet(object.password) ? globalThis.String(object.password) : '',
      socket: isSet(object.socket) ? globalThis.String(object.socket) : '',
      sslOptions: isSet(object.sslOptions)
        ? MySQLDatabaseConfig_SSLOptions.fromJSON(object.sslOptions)
        : undefined,
      skipDbCreation: isSet(object.skipDbCreation)
        ? globalThis.Boolean(object.skipDbCreation)
        : false,
    };
  },

  toJSON(message: MySQLDatabaseConfig): unknown {
    const obj: any = {};
    if (message.host !== undefined && message.host !== '') {
      obj.host = message.host;
    }
    if (message.port !== undefined && message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.database !== undefined && message.database !== '') {
      obj.database = message.database;
    }
    if (message.user !== undefined && message.user !== '') {
      obj.user = message.user;
    }
    if (message.password !== undefined && message.password !== '') {
      obj.password = message.password;
    }
    if (message.socket !== undefined && message.socket !== '') {
      obj.socket = message.socket;
    }
    if (message.sslOptions !== undefined) {
      obj.sslOptions = MySQLDatabaseConfig_SSLOptions.toJSON(message.sslOptions);
    }
    if (message.skipDbCreation !== undefined && message.skipDbCreation !== false) {
      obj.skipDbCreation = message.skipDbCreation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MySQLDatabaseConfig>, I>>(base?: I): MySQLDatabaseConfig {
    return MySQLDatabaseConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MySQLDatabaseConfig>, I>>(
    object: I,
  ): MySQLDatabaseConfig {
    const message = createBaseMySQLDatabaseConfig();
    message.host = object.host ?? '';
    message.port = object.port ?? 0;
    message.database = object.database ?? '';
    message.user = object.user ?? '';
    message.password = object.password ?? '';
    message.socket = object.socket ?? '';
    message.sslOptions =
      object.sslOptions !== undefined && object.sslOptions !== null
        ? MySQLDatabaseConfig_SSLOptions.fromPartial(object.sslOptions)
        : undefined;
    message.skipDbCreation = object.skipDbCreation ?? false;
    return message;
  },
};

function createBaseMySQLDatabaseConfig_SSLOptions(): MySQLDatabaseConfig_SSLOptions {
  return { key: '', cert: '', ca: '', capath: '', cipher: '', verifyServerCert: false };
}

export const MySQLDatabaseConfig_SSLOptions = {
  encode(
    message: MySQLDatabaseConfig_SSLOptions,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== undefined && message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.cert !== undefined && message.cert !== '') {
      writer.uint32(18).string(message.cert);
    }
    if (message.ca !== undefined && message.ca !== '') {
      writer.uint32(26).string(message.ca);
    }
    if (message.capath !== undefined && message.capath !== '') {
      writer.uint32(34).string(message.capath);
    }
    if (message.cipher !== undefined && message.cipher !== '') {
      writer.uint32(42).string(message.cipher);
    }
    if (message.verifyServerCert !== undefined && message.verifyServerCert !== false) {
      writer.uint32(48).bool(message.verifyServerCert);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MySQLDatabaseConfig_SSLOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMySQLDatabaseConfig_SSLOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cert = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ca = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.capath = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cipher = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.verifyServerCert = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MySQLDatabaseConfig_SSLOptions {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : '',
      cert: isSet(object.cert) ? globalThis.String(object.cert) : '',
      ca: isSet(object.ca) ? globalThis.String(object.ca) : '',
      capath: isSet(object.capath) ? globalThis.String(object.capath) : '',
      cipher: isSet(object.cipher) ? globalThis.String(object.cipher) : '',
      verifyServerCert: isSet(object.verifyServerCert)
        ? globalThis.Boolean(object.verifyServerCert)
        : false,
    };
  },

  toJSON(message: MySQLDatabaseConfig_SSLOptions): unknown {
    const obj: any = {};
    if (message.key !== undefined && message.key !== '') {
      obj.key = message.key;
    }
    if (message.cert !== undefined && message.cert !== '') {
      obj.cert = message.cert;
    }
    if (message.ca !== undefined && message.ca !== '') {
      obj.ca = message.ca;
    }
    if (message.capath !== undefined && message.capath !== '') {
      obj.capath = message.capath;
    }
    if (message.cipher !== undefined && message.cipher !== '') {
      obj.cipher = message.cipher;
    }
    if (message.verifyServerCert !== undefined && message.verifyServerCert !== false) {
      obj.verifyServerCert = message.verifyServerCert;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MySQLDatabaseConfig_SSLOptions>, I>>(
    base?: I,
  ): MySQLDatabaseConfig_SSLOptions {
    return MySQLDatabaseConfig_SSLOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MySQLDatabaseConfig_SSLOptions>, I>>(
    object: I,
  ): MySQLDatabaseConfig_SSLOptions {
    const message = createBaseMySQLDatabaseConfig_SSLOptions();
    message.key = object.key ?? '';
    message.cert = object.cert ?? '';
    message.ca = object.ca ?? '';
    message.capath = object.capath ?? '';
    message.cipher = object.cipher ?? '';
    message.verifyServerCert = object.verifyServerCert ?? false;
    return message;
  },
};

function createBaseSqliteMetadataSourceConfig(): SqliteMetadataSourceConfig {
  return { filenameUri: '', connectionMode: 0 };
}

export const SqliteMetadataSourceConfig = {
  encode(
    message: SqliteMetadataSourceConfig,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.filenameUri !== undefined && message.filenameUri !== '') {
      writer.uint32(10).string(message.filenameUri);
    }
    if (message.connectionMode !== undefined && message.connectionMode !== 0) {
      writer.uint32(16).int32(message.connectionMode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SqliteMetadataSourceConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSqliteMetadataSourceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filenameUri = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.connectionMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SqliteMetadataSourceConfig {
    return {
      filenameUri: isSet(object.filenameUri) ? globalThis.String(object.filenameUri) : '',
      connectionMode: isSet(object.connectionMode)
        ? sqliteMetadataSourceConfig_ConnectionModeFromJSON(object.connectionMode)
        : 0,
    };
  },

  toJSON(message: SqliteMetadataSourceConfig): unknown {
    const obj: any = {};
    if (message.filenameUri !== undefined && message.filenameUri !== '') {
      obj.filenameUri = message.filenameUri;
    }
    if (message.connectionMode !== undefined && message.connectionMode !== 0) {
      obj.connectionMode = sqliteMetadataSourceConfig_ConnectionModeToJSON(message.connectionMode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SqliteMetadataSourceConfig>, I>>(
    base?: I,
  ): SqliteMetadataSourceConfig {
    return SqliteMetadataSourceConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SqliteMetadataSourceConfig>, I>>(
    object: I,
  ): SqliteMetadataSourceConfig {
    const message = createBaseSqliteMetadataSourceConfig();
    message.filenameUri = object.filenameUri ?? '';
    message.connectionMode = object.connectionMode ?? 0;
    return message;
  },
};

function createBasePostgreSQLDatabaseConfig(): PostgreSQLDatabaseConfig {
  return {
    host: '',
    hostaddr: '',
    port: '',
    user: '',
    password: '',
    passfile: '',
    dbname: '',
    skipDbCreation: false,
    ssloption: undefined,
  };
}

export const PostgreSQLDatabaseConfig = {
  encode(message: PostgreSQLDatabaseConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.host !== undefined && message.host !== '') {
      writer.uint32(10).string(message.host);
    }
    if (message.hostaddr !== undefined && message.hostaddr !== '') {
      writer.uint32(18).string(message.hostaddr);
    }
    if (message.port !== undefined && message.port !== '') {
      writer.uint32(26).string(message.port);
    }
    if (message.user !== undefined && message.user !== '') {
      writer.uint32(34).string(message.user);
    }
    if (message.password !== undefined && message.password !== '') {
      writer.uint32(42).string(message.password);
    }
    if (message.passfile !== undefined && message.passfile !== '') {
      writer.uint32(50).string(message.passfile);
    }
    if (message.dbname !== undefined && message.dbname !== '') {
      writer.uint32(58).string(message.dbname);
    }
    if (message.skipDbCreation !== undefined && message.skipDbCreation !== false) {
      writer.uint32(64).bool(message.skipDbCreation);
    }
    if (message.ssloption !== undefined) {
      PostgreSQLDatabaseConfig_SSLOptions.encode(
        message.ssloption,
        writer.uint32(74).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PostgreSQLDatabaseConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostgreSQLDatabaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hostaddr = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.port = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.user = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.password = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.passfile = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dbname = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.skipDbCreation = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.ssloption = PostgreSQLDatabaseConfig_SSLOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostgreSQLDatabaseConfig {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : '',
      hostaddr: isSet(object.hostaddr) ? globalThis.String(object.hostaddr) : '',
      port: isSet(object.port) ? globalThis.String(object.port) : '',
      user: isSet(object.user) ? globalThis.String(object.user) : '',
      password: isSet(object.password) ? globalThis.String(object.password) : '',
      passfile: isSet(object.passfile) ? globalThis.String(object.passfile) : '',
      dbname: isSet(object.dbname) ? globalThis.String(object.dbname) : '',
      skipDbCreation: isSet(object.skipDbCreation)
        ? globalThis.Boolean(object.skipDbCreation)
        : false,
      ssloption: isSet(object.ssloption)
        ? PostgreSQLDatabaseConfig_SSLOptions.fromJSON(object.ssloption)
        : undefined,
    };
  },

  toJSON(message: PostgreSQLDatabaseConfig): unknown {
    const obj: any = {};
    if (message.host !== undefined && message.host !== '') {
      obj.host = message.host;
    }
    if (message.hostaddr !== undefined && message.hostaddr !== '') {
      obj.hostaddr = message.hostaddr;
    }
    if (message.port !== undefined && message.port !== '') {
      obj.port = message.port;
    }
    if (message.user !== undefined && message.user !== '') {
      obj.user = message.user;
    }
    if (message.password !== undefined && message.password !== '') {
      obj.password = message.password;
    }
    if (message.passfile !== undefined && message.passfile !== '') {
      obj.passfile = message.passfile;
    }
    if (message.dbname !== undefined && message.dbname !== '') {
      obj.dbname = message.dbname;
    }
    if (message.skipDbCreation !== undefined && message.skipDbCreation !== false) {
      obj.skipDbCreation = message.skipDbCreation;
    }
    if (message.ssloption !== undefined) {
      obj.ssloption = PostgreSQLDatabaseConfig_SSLOptions.toJSON(message.ssloption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostgreSQLDatabaseConfig>, I>>(
    base?: I,
  ): PostgreSQLDatabaseConfig {
    return PostgreSQLDatabaseConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostgreSQLDatabaseConfig>, I>>(
    object: I,
  ): PostgreSQLDatabaseConfig {
    const message = createBasePostgreSQLDatabaseConfig();
    message.host = object.host ?? '';
    message.hostaddr = object.hostaddr ?? '';
    message.port = object.port ?? '';
    message.user = object.user ?? '';
    message.password = object.password ?? '';
    message.passfile = object.passfile ?? '';
    message.dbname = object.dbname ?? '';
    message.skipDbCreation = object.skipDbCreation ?? false;
    message.ssloption =
      object.ssloption !== undefined && object.ssloption !== null
        ? PostgreSQLDatabaseConfig_SSLOptions.fromPartial(object.ssloption)
        : undefined;
    return message;
  },
};

function createBasePostgreSQLDatabaseConfig_SSLOptions(): PostgreSQLDatabaseConfig_SSLOptions {
  return { sslmode: '', sslcert: '', sslkey: '', sslpassword: '', sslrootcert: '' };
}

export const PostgreSQLDatabaseConfig_SSLOptions = {
  encode(
    message: PostgreSQLDatabaseConfig_SSLOptions,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sslmode !== undefined && message.sslmode !== '') {
      writer.uint32(10).string(message.sslmode);
    }
    if (message.sslcert !== undefined && message.sslcert !== '') {
      writer.uint32(18).string(message.sslcert);
    }
    if (message.sslkey !== undefined && message.sslkey !== '') {
      writer.uint32(26).string(message.sslkey);
    }
    if (message.sslpassword !== undefined && message.sslpassword !== '') {
      writer.uint32(34).string(message.sslpassword);
    }
    if (message.sslrootcert !== undefined && message.sslrootcert !== '') {
      writer.uint32(42).string(message.sslrootcert);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PostgreSQLDatabaseConfig_SSLOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostgreSQLDatabaseConfig_SSLOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sslmode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sslcert = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sslkey = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sslpassword = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sslrootcert = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostgreSQLDatabaseConfig_SSLOptions {
    return {
      sslmode: isSet(object.sslmode) ? globalThis.String(object.sslmode) : '',
      sslcert: isSet(object.sslcert) ? globalThis.String(object.sslcert) : '',
      sslkey: isSet(object.sslkey) ? globalThis.String(object.sslkey) : '',
      sslpassword: isSet(object.sslpassword) ? globalThis.String(object.sslpassword) : '',
      sslrootcert: isSet(object.sslrootcert) ? globalThis.String(object.sslrootcert) : '',
    };
  },

  toJSON(message: PostgreSQLDatabaseConfig_SSLOptions): unknown {
    const obj: any = {};
    if (message.sslmode !== undefined && message.sslmode !== '') {
      obj.sslmode = message.sslmode;
    }
    if (message.sslcert !== undefined && message.sslcert !== '') {
      obj.sslcert = message.sslcert;
    }
    if (message.sslkey !== undefined && message.sslkey !== '') {
      obj.sslkey = message.sslkey;
    }
    if (message.sslpassword !== undefined && message.sslpassword !== '') {
      obj.sslpassword = message.sslpassword;
    }
    if (message.sslrootcert !== undefined && message.sslrootcert !== '') {
      obj.sslrootcert = message.sslrootcert;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostgreSQLDatabaseConfig_SSLOptions>, I>>(
    base?: I,
  ): PostgreSQLDatabaseConfig_SSLOptions {
    return PostgreSQLDatabaseConfig_SSLOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostgreSQLDatabaseConfig_SSLOptions>, I>>(
    object: I,
  ): PostgreSQLDatabaseConfig_SSLOptions {
    const message = createBasePostgreSQLDatabaseConfig_SSLOptions();
    message.sslmode = object.sslmode ?? '';
    message.sslcert = object.sslcert ?? '';
    message.sslkey = object.sslkey ?? '';
    message.sslpassword = object.sslpassword ?? '';
    message.sslrootcert = object.sslrootcert ?? '';
    return message;
  },
};

function createBaseMigrationOptions(): MigrationOptions {
  return { enableUpgradeMigration: false, downgradeToSchemaVersion: -1 };
}

export const MigrationOptions = {
  encode(message: MigrationOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enableUpgradeMigration !== undefined && message.enableUpgradeMigration !== false) {
      writer.uint32(24).bool(message.enableUpgradeMigration);
    }
    if (message.downgradeToSchemaVersion !== undefined && message.downgradeToSchemaVersion !== -1) {
      writer.uint32(16).int64(message.downgradeToSchemaVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MigrationOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enableUpgradeMigration = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.downgradeToSchemaVersion = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrationOptions {
    return {
      enableUpgradeMigration: isSet(object.enableUpgradeMigration)
        ? globalThis.Boolean(object.enableUpgradeMigration)
        : false,
      downgradeToSchemaVersion: isSet(object.downgradeToSchemaVersion)
        ? globalThis.Number(object.downgradeToSchemaVersion)
        : -1,
    };
  },

  toJSON(message: MigrationOptions): unknown {
    const obj: any = {};
    if (message.enableUpgradeMigration !== undefined && message.enableUpgradeMigration !== false) {
      obj.enableUpgradeMigration = message.enableUpgradeMigration;
    }
    if (message.downgradeToSchemaVersion !== undefined && message.downgradeToSchemaVersion !== -1) {
      obj.downgradeToSchemaVersion = Math.round(message.downgradeToSchemaVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MigrationOptions>, I>>(base?: I): MigrationOptions {
    return MigrationOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MigrationOptions>, I>>(object: I): MigrationOptions {
    const message = createBaseMigrationOptions();
    message.enableUpgradeMigration = object.enableUpgradeMigration ?? false;
    message.downgradeToSchemaVersion = object.downgradeToSchemaVersion ?? -1;
    return message;
  },
};

function createBaseRetryOptions(): RetryOptions {
  return { maxNumRetries: 0 };
}

export const RetryOptions = {
  encode(message: RetryOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.maxNumRetries !== undefined && message.maxNumRetries !== 0) {
      writer.uint32(8).int64(message.maxNumRetries);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxNumRetries = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryOptions {
    return {
      maxNumRetries: isSet(object.maxNumRetries) ? globalThis.Number(object.maxNumRetries) : 0,
    };
  },

  toJSON(message: RetryOptions): unknown {
    const obj: any = {};
    if (message.maxNumRetries !== undefined && message.maxNumRetries !== 0) {
      obj.maxNumRetries = Math.round(message.maxNumRetries);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryOptions>, I>>(base?: I): RetryOptions {
    return RetryOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryOptions>, I>>(object: I): RetryOptions {
    const message = createBaseRetryOptions();
    message.maxNumRetries = object.maxNumRetries ?? 0;
    return message;
  },
};

function createBaseConnectionConfig(): ConnectionConfig {
  return {
    fakeDatabase: undefined,
    mysql: undefined,
    sqlite: undefined,
    postgresql: undefined,
    retryOptions: undefined,
  };
}

export const ConnectionConfig = {
  encode(message: ConnectionConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fakeDatabase !== undefined) {
      FakeDatabaseConfig.encode(message.fakeDatabase, writer.uint32(10).fork()).ldelim();
    }
    if (message.mysql !== undefined) {
      MySQLDatabaseConfig.encode(message.mysql, writer.uint32(18).fork()).ldelim();
    }
    if (message.sqlite !== undefined) {
      SqliteMetadataSourceConfig.encode(message.sqlite, writer.uint32(26).fork()).ldelim();
    }
    if (message.postgresql !== undefined) {
      PostgreSQLDatabaseConfig.encode(message.postgresql, writer.uint32(42).fork()).ldelim();
    }
    if (message.retryOptions !== undefined) {
      RetryOptions.encode(message.retryOptions, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConnectionConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fakeDatabase = FakeDatabaseConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mysql = MySQLDatabaseConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sqlite = SqliteMetadataSourceConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.postgresql = PostgreSQLDatabaseConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.retryOptions = RetryOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionConfig {
    return {
      fakeDatabase: isSet(object.fakeDatabase)
        ? FakeDatabaseConfig.fromJSON(object.fakeDatabase)
        : undefined,
      mysql: isSet(object.mysql) ? MySQLDatabaseConfig.fromJSON(object.mysql) : undefined,
      sqlite: isSet(object.sqlite) ? SqliteMetadataSourceConfig.fromJSON(object.sqlite) : undefined,
      postgresql: isSet(object.postgresql)
        ? PostgreSQLDatabaseConfig.fromJSON(object.postgresql)
        : undefined,
      retryOptions: isSet(object.retryOptions)
        ? RetryOptions.fromJSON(object.retryOptions)
        : undefined,
    };
  },

  toJSON(message: ConnectionConfig): unknown {
    const obj: any = {};
    if (message.fakeDatabase !== undefined) {
      obj.fakeDatabase = FakeDatabaseConfig.toJSON(message.fakeDatabase);
    }
    if (message.mysql !== undefined) {
      obj.mysql = MySQLDatabaseConfig.toJSON(message.mysql);
    }
    if (message.sqlite !== undefined) {
      obj.sqlite = SqliteMetadataSourceConfig.toJSON(message.sqlite);
    }
    if (message.postgresql !== undefined) {
      obj.postgresql = PostgreSQLDatabaseConfig.toJSON(message.postgresql);
    }
    if (message.retryOptions !== undefined) {
      obj.retryOptions = RetryOptions.toJSON(message.retryOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectionConfig>, I>>(base?: I): ConnectionConfig {
    return ConnectionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectionConfig>, I>>(object: I): ConnectionConfig {
    const message = createBaseConnectionConfig();
    message.fakeDatabase =
      object.fakeDatabase !== undefined && object.fakeDatabase !== null
        ? FakeDatabaseConfig.fromPartial(object.fakeDatabase)
        : undefined;
    message.mysql =
      object.mysql !== undefined && object.mysql !== null
        ? MySQLDatabaseConfig.fromPartial(object.mysql)
        : undefined;
    message.sqlite =
      object.sqlite !== undefined && object.sqlite !== null
        ? SqliteMetadataSourceConfig.fromPartial(object.sqlite)
        : undefined;
    message.postgresql =
      object.postgresql !== undefined && object.postgresql !== null
        ? PostgreSQLDatabaseConfig.fromPartial(object.postgresql)
        : undefined;
    message.retryOptions =
      object.retryOptions !== undefined && object.retryOptions !== null
        ? RetryOptions.fromPartial(object.retryOptions)
        : undefined;
    return message;
  },
};

function createBaseGrpcChannelArguments(): GrpcChannelArguments {
  return { maxReceiveMessageLength: 0, http2MaxPingStrikes: 0 };
}

export const GrpcChannelArguments = {
  encode(message: GrpcChannelArguments, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.maxReceiveMessageLength !== undefined && message.maxReceiveMessageLength !== 0) {
      writer.uint32(8).int64(message.maxReceiveMessageLength);
    }
    if (message.http2MaxPingStrikes !== undefined && message.http2MaxPingStrikes !== 0) {
      writer.uint32(16).int64(message.http2MaxPingStrikes);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GrpcChannelArguments {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcChannelArguments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxReceiveMessageLength = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.http2MaxPingStrikes = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcChannelArguments {
    return {
      maxReceiveMessageLength: isSet(object.maxReceiveMessageLength)
        ? globalThis.Number(object.maxReceiveMessageLength)
        : 0,
      http2MaxPingStrikes: isSet(object.http2MaxPingStrikes)
        ? globalThis.Number(object.http2MaxPingStrikes)
        : 0,
    };
  },

  toJSON(message: GrpcChannelArguments): unknown {
    const obj: any = {};
    if (message.maxReceiveMessageLength !== undefined && message.maxReceiveMessageLength !== 0) {
      obj.maxReceiveMessageLength = Math.round(message.maxReceiveMessageLength);
    }
    if (message.http2MaxPingStrikes !== undefined && message.http2MaxPingStrikes !== 0) {
      obj.http2MaxPingStrikes = Math.round(message.http2MaxPingStrikes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcChannelArguments>, I>>(base?: I): GrpcChannelArguments {
    return GrpcChannelArguments.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcChannelArguments>, I>>(
    object: I,
  ): GrpcChannelArguments {
    const message = createBaseGrpcChannelArguments();
    message.maxReceiveMessageLength = object.maxReceiveMessageLength ?? 0;
    message.http2MaxPingStrikes = object.http2MaxPingStrikes ?? 0;
    return message;
  },
};

function createBaseMetadataStoreClientConfig(): MetadataStoreClientConfig {
  return {
    host: '',
    port: 0,
    sslConfig: undefined,
    channelArguments: undefined,
    clientTimeoutSec: 0,
  };
}

export const MetadataStoreClientConfig = {
  encode(message: MetadataStoreClientConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.host !== undefined && message.host !== '') {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== undefined && message.port !== 0) {
      writer.uint32(16).int64(message.port);
    }
    if (message.sslConfig !== undefined) {
      MetadataStoreClientConfig_SSLConfig.encode(
        message.sslConfig,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    if (message.channelArguments !== undefined) {
      GrpcChannelArguments.encode(message.channelArguments, writer.uint32(34).fork()).ldelim();
    }
    if (message.clientTimeoutSec !== undefined && message.clientTimeoutSec !== 0) {
      writer.uint32(41).double(message.clientTimeoutSec);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetadataStoreClientConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataStoreClientConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sslConfig = MetadataStoreClientConfig_SSLConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.channelArguments = GrpcChannelArguments.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.clientTimeoutSec = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataStoreClientConfig {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : '',
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      sslConfig: isSet(object.sslConfig)
        ? MetadataStoreClientConfig_SSLConfig.fromJSON(object.sslConfig)
        : undefined,
      channelArguments: isSet(object.channelArguments)
        ? GrpcChannelArguments.fromJSON(object.channelArguments)
        : undefined,
      clientTimeoutSec: isSet(object.clientTimeoutSec)
        ? globalThis.Number(object.clientTimeoutSec)
        : 0,
    };
  },

  toJSON(message: MetadataStoreClientConfig): unknown {
    const obj: any = {};
    if (message.host !== undefined && message.host !== '') {
      obj.host = message.host;
    }
    if (message.port !== undefined && message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.sslConfig !== undefined) {
      obj.sslConfig = MetadataStoreClientConfig_SSLConfig.toJSON(message.sslConfig);
    }
    if (message.channelArguments !== undefined) {
      obj.channelArguments = GrpcChannelArguments.toJSON(message.channelArguments);
    }
    if (message.clientTimeoutSec !== undefined && message.clientTimeoutSec !== 0) {
      obj.clientTimeoutSec = message.clientTimeoutSec;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetadataStoreClientConfig>, I>>(
    base?: I,
  ): MetadataStoreClientConfig {
    return MetadataStoreClientConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetadataStoreClientConfig>, I>>(
    object: I,
  ): MetadataStoreClientConfig {
    const message = createBaseMetadataStoreClientConfig();
    message.host = object.host ?? '';
    message.port = object.port ?? 0;
    message.sslConfig =
      object.sslConfig !== undefined && object.sslConfig !== null
        ? MetadataStoreClientConfig_SSLConfig.fromPartial(object.sslConfig)
        : undefined;
    message.channelArguments =
      object.channelArguments !== undefined && object.channelArguments !== null
        ? GrpcChannelArguments.fromPartial(object.channelArguments)
        : undefined;
    message.clientTimeoutSec = object.clientTimeoutSec ?? 0;
    return message;
  },
};

function createBaseMetadataStoreClientConfig_SSLConfig(): MetadataStoreClientConfig_SSLConfig {
  return { clientKey: '', serverCert: '', customCa: '' };
}

export const MetadataStoreClientConfig_SSLConfig = {
  encode(
    message: MetadataStoreClientConfig_SSLConfig,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.clientKey !== undefined && message.clientKey !== '') {
      writer.uint32(10).string(message.clientKey);
    }
    if (message.serverCert !== undefined && message.serverCert !== '') {
      writer.uint32(18).string(message.serverCert);
    }
    if (message.customCa !== undefined && message.customCa !== '') {
      writer.uint32(26).string(message.customCa);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetadataStoreClientConfig_SSLConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataStoreClientConfig_SSLConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serverCert = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customCa = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataStoreClientConfig_SSLConfig {
    return {
      clientKey: isSet(object.clientKey) ? globalThis.String(object.clientKey) : '',
      serverCert: isSet(object.serverCert) ? globalThis.String(object.serverCert) : '',
      customCa: isSet(object.customCa) ? globalThis.String(object.customCa) : '',
    };
  },

  toJSON(message: MetadataStoreClientConfig_SSLConfig): unknown {
    const obj: any = {};
    if (message.clientKey !== undefined && message.clientKey !== '') {
      obj.clientKey = message.clientKey;
    }
    if (message.serverCert !== undefined && message.serverCert !== '') {
      obj.serverCert = message.serverCert;
    }
    if (message.customCa !== undefined && message.customCa !== '') {
      obj.customCa = message.customCa;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetadataStoreClientConfig_SSLConfig>, I>>(
    base?: I,
  ): MetadataStoreClientConfig_SSLConfig {
    return MetadataStoreClientConfig_SSLConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetadataStoreClientConfig_SSLConfig>, I>>(
    object: I,
  ): MetadataStoreClientConfig_SSLConfig {
    const message = createBaseMetadataStoreClientConfig_SSLConfig();
    message.clientKey = object.clientKey ?? '';
    message.serverCert = object.serverCert ?? '';
    message.customCa = object.customCa ?? '';
    return message;
  },
};

function createBaseMetadataStoreServerConfig(): MetadataStoreServerConfig {
  return { connectionConfig: undefined, migrationOptions: undefined, sslConfig: undefined };
}

export const MetadataStoreServerConfig = {
  encode(message: MetadataStoreServerConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.connectionConfig !== undefined) {
      ConnectionConfig.encode(message.connectionConfig, writer.uint32(10).fork()).ldelim();
    }
    if (message.migrationOptions !== undefined) {
      MigrationOptions.encode(message.migrationOptions, writer.uint32(26).fork()).ldelim();
    }
    if (message.sslConfig !== undefined) {
      MetadataStoreServerConfig_SSLConfig.encode(
        message.sslConfig,
        writer.uint32(18).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetadataStoreServerConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataStoreServerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.connectionConfig = ConnectionConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.migrationOptions = MigrationOptions.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sslConfig = MetadataStoreServerConfig_SSLConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataStoreServerConfig {
    return {
      connectionConfig: isSet(object.connectionConfig)
        ? ConnectionConfig.fromJSON(object.connectionConfig)
        : undefined,
      migrationOptions: isSet(object.migrationOptions)
        ? MigrationOptions.fromJSON(object.migrationOptions)
        : undefined,
      sslConfig: isSet(object.sslConfig)
        ? MetadataStoreServerConfig_SSLConfig.fromJSON(object.sslConfig)
        : undefined,
    };
  },

  toJSON(message: MetadataStoreServerConfig): unknown {
    const obj: any = {};
    if (message.connectionConfig !== undefined) {
      obj.connectionConfig = ConnectionConfig.toJSON(message.connectionConfig);
    }
    if (message.migrationOptions !== undefined) {
      obj.migrationOptions = MigrationOptions.toJSON(message.migrationOptions);
    }
    if (message.sslConfig !== undefined) {
      obj.sslConfig = MetadataStoreServerConfig_SSLConfig.toJSON(message.sslConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetadataStoreServerConfig>, I>>(
    base?: I,
  ): MetadataStoreServerConfig {
    return MetadataStoreServerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetadataStoreServerConfig>, I>>(
    object: I,
  ): MetadataStoreServerConfig {
    const message = createBaseMetadataStoreServerConfig();
    message.connectionConfig =
      object.connectionConfig !== undefined && object.connectionConfig !== null
        ? ConnectionConfig.fromPartial(object.connectionConfig)
        : undefined;
    message.migrationOptions =
      object.migrationOptions !== undefined && object.migrationOptions !== null
        ? MigrationOptions.fromPartial(object.migrationOptions)
        : undefined;
    message.sslConfig =
      object.sslConfig !== undefined && object.sslConfig !== null
        ? MetadataStoreServerConfig_SSLConfig.fromPartial(object.sslConfig)
        : undefined;
    return message;
  },
};

function createBaseMetadataStoreServerConfig_SSLConfig(): MetadataStoreServerConfig_SSLConfig {
  return { serverKey: '', serverCert: '', customCa: '', clientVerify: false };
}

export const MetadataStoreServerConfig_SSLConfig = {
  encode(
    message: MetadataStoreServerConfig_SSLConfig,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.serverKey !== undefined && message.serverKey !== '') {
      writer.uint32(10).string(message.serverKey);
    }
    if (message.serverCert !== undefined && message.serverCert !== '') {
      writer.uint32(18).string(message.serverCert);
    }
    if (message.customCa !== undefined && message.customCa !== '') {
      writer.uint32(26).string(message.customCa);
    }
    if (message.clientVerify !== undefined && message.clientVerify !== false) {
      writer.uint32(32).bool(message.clientVerify);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetadataStoreServerConfig_SSLConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataStoreServerConfig_SSLConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serverKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serverCert = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customCa = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.clientVerify = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataStoreServerConfig_SSLConfig {
    return {
      serverKey: isSet(object.serverKey) ? globalThis.String(object.serverKey) : '',
      serverCert: isSet(object.serverCert) ? globalThis.String(object.serverCert) : '',
      customCa: isSet(object.customCa) ? globalThis.String(object.customCa) : '',
      clientVerify: isSet(object.clientVerify) ? globalThis.Boolean(object.clientVerify) : false,
    };
  },

  toJSON(message: MetadataStoreServerConfig_SSLConfig): unknown {
    const obj: any = {};
    if (message.serverKey !== undefined && message.serverKey !== '') {
      obj.serverKey = message.serverKey;
    }
    if (message.serverCert !== undefined && message.serverCert !== '') {
      obj.serverCert = message.serverCert;
    }
    if (message.customCa !== undefined && message.customCa !== '') {
      obj.customCa = message.customCa;
    }
    if (message.clientVerify !== undefined && message.clientVerify !== false) {
      obj.clientVerify = message.clientVerify;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetadataStoreServerConfig_SSLConfig>, I>>(
    base?: I,
  ): MetadataStoreServerConfig_SSLConfig {
    return MetadataStoreServerConfig_SSLConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetadataStoreServerConfig_SSLConfig>, I>>(
    object: I,
  ): MetadataStoreServerConfig_SSLConfig {
    const message = createBaseMetadataStoreServerConfig_SSLConfig();
    message.serverKey = object.serverKey ?? '';
    message.serverCert = object.serverCert ?? '';
    message.customCa = object.customCa ?? '';
    message.clientVerify = object.clientVerify ?? false;
    return message;
  },
};

function createBaseListOperationOptions(): ListOperationOptions {
  return { maxResultSize: 20, orderByField: undefined, nextPageToken: '', filterQuery: '' };
}

export const ListOperationOptions = {
  encode(message: ListOperationOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.maxResultSize !== undefined && message.maxResultSize !== 20) {
      writer.uint32(8).int32(message.maxResultSize);
    }
    if (message.orderByField !== undefined) {
      ListOperationOptions_OrderByField.encode(
        message.orderByField,
        writer.uint32(18).fork(),
      ).ldelim();
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      writer.uint32(26).string(message.nextPageToken);
    }
    if (message.filterQuery !== undefined && message.filterQuery !== '') {
      writer.uint32(34).string(message.filterQuery);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListOperationOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOperationOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxResultSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orderByField = ListOperationOptions_OrderByField.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filterQuery = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOperationOptions {
    return {
      maxResultSize: isSet(object.maxResultSize) ? globalThis.Number(object.maxResultSize) : 20,
      orderByField: isSet(object.orderByField)
        ? ListOperationOptions_OrderByField.fromJSON(object.orderByField)
        : undefined,
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : '',
      filterQuery: isSet(object.filterQuery) ? globalThis.String(object.filterQuery) : '',
    };
  },

  toJSON(message: ListOperationOptions): unknown {
    const obj: any = {};
    if (message.maxResultSize !== undefined && message.maxResultSize !== 20) {
      obj.maxResultSize = Math.round(message.maxResultSize);
    }
    if (message.orderByField !== undefined) {
      obj.orderByField = ListOperationOptions_OrderByField.toJSON(message.orderByField);
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.filterQuery !== undefined && message.filterQuery !== '') {
      obj.filterQuery = message.filterQuery;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOperationOptions>, I>>(base?: I): ListOperationOptions {
    return ListOperationOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOperationOptions>, I>>(
    object: I,
  ): ListOperationOptions {
    const message = createBaseListOperationOptions();
    message.maxResultSize = object.maxResultSize ?? 20;
    message.orderByField =
      object.orderByField !== undefined && object.orderByField !== null
        ? ListOperationOptions_OrderByField.fromPartial(object.orderByField)
        : undefined;
    message.nextPageToken = object.nextPageToken ?? '';
    message.filterQuery = object.filterQuery ?? '';
    return message;
  },
};

function createBaseListOperationOptions_OrderByField(): ListOperationOptions_OrderByField {
  return { field: 3, isAsc: true };
}

export const ListOperationOptions_OrderByField = {
  encode(
    message: ListOperationOptions_OrderByField,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.field !== undefined && message.field !== 3) {
      writer.uint32(8).int32(message.field);
    }
    if (message.isAsc !== undefined && message.isAsc !== true) {
      writer.uint32(16).bool(message.isAsc);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListOperationOptions_OrderByField {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOperationOptions_OrderByField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.field = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isAsc = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOperationOptions_OrderByField {
    return {
      field: isSet(object.field)
        ? listOperationOptions_OrderByField_FieldFromJSON(object.field)
        : 3,
      isAsc: isSet(object.isAsc) ? globalThis.Boolean(object.isAsc) : true,
    };
  },

  toJSON(message: ListOperationOptions_OrderByField): unknown {
    const obj: any = {};
    if (message.field !== undefined && message.field !== 3) {
      obj.field = listOperationOptions_OrderByField_FieldToJSON(message.field);
    }
    if (message.isAsc !== undefined && message.isAsc !== true) {
      obj.isAsc = message.isAsc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOperationOptions_OrderByField>, I>>(
    base?: I,
  ): ListOperationOptions_OrderByField {
    return ListOperationOptions_OrderByField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOperationOptions_OrderByField>, I>>(
    object: I,
  ): ListOperationOptions_OrderByField {
    const message = createBaseListOperationOptions_OrderByField();
    message.field = object.field ?? 3;
    message.isAsc = object.isAsc ?? true;
    return message;
  },
};

function createBaseListOperationNextPageToken(): ListOperationNextPageToken {
  return { idOffset: 0, fieldOffset: 0, setOptions: undefined, listedIds: [] };
}

export const ListOperationNextPageToken = {
  encode(
    message: ListOperationNextPageToken,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.idOffset !== undefined && message.idOffset !== 0) {
      writer.uint32(8).int64(message.idOffset);
    }
    if (message.fieldOffset !== undefined && message.fieldOffset !== 0) {
      writer.uint32(16).int64(message.fieldOffset);
    }
    if (message.setOptions !== undefined) {
      ListOperationOptions.encode(message.setOptions, writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(34).fork();
    for (const v of message.listedIds) {
      writer.int64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListOperationNextPageToken {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOperationNextPageToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.idOffset = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fieldOffset = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.setOptions = ListOperationOptions.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag === 32) {
            message.listedIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.listedIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOperationNextPageToken {
    return {
      idOffset: isSet(object.idOffset) ? globalThis.Number(object.idOffset) : 0,
      fieldOffset: isSet(object.fieldOffset) ? globalThis.Number(object.fieldOffset) : 0,
      setOptions: isSet(object.setOptions)
        ? ListOperationOptions.fromJSON(object.setOptions)
        : undefined,
      listedIds: globalThis.Array.isArray(object?.listedIds)
        ? object.listedIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: ListOperationNextPageToken): unknown {
    const obj: any = {};
    if (message.idOffset !== undefined && message.idOffset !== 0) {
      obj.idOffset = Math.round(message.idOffset);
    }
    if (message.fieldOffset !== undefined && message.fieldOffset !== 0) {
      obj.fieldOffset = Math.round(message.fieldOffset);
    }
    if (message.setOptions !== undefined) {
      obj.setOptions = ListOperationOptions.toJSON(message.setOptions);
    }
    if (message.listedIds?.length) {
      obj.listedIds = message.listedIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOperationNextPageToken>, I>>(
    base?: I,
  ): ListOperationNextPageToken {
    return ListOperationNextPageToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOperationNextPageToken>, I>>(
    object: I,
  ): ListOperationNextPageToken {
    const message = createBaseListOperationNextPageToken();
    message.idOffset = object.idOffset ?? 0;
    message.fieldOffset = object.fieldOffset ?? 0;
    message.setOptions =
      object.setOptions !== undefined && object.setOptions !== null
        ? ListOperationOptions.fromPartial(object.setOptions)
        : undefined;
    message.listedIds = object.listedIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseTransactionOptions(): TransactionOptions {
  return { tag: '' };
}

export const TransactionOptions = {
  encode(message: TransactionOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tag !== undefined && message.tag !== '') {
      writer.uint32(10).string(message.tag);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionOptions {
    return { tag: isSet(object.tag) ? globalThis.String(object.tag) : '' };
  },

  toJSON(message: TransactionOptions): unknown {
    const obj: any = {};
    if (message.tag !== undefined && message.tag !== '') {
      obj.tag = message.tag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionOptions>, I>>(base?: I): TransactionOptions {
    return TransactionOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionOptions>, I>>(object: I): TransactionOptions {
    const message = createBaseTransactionOptions();
    message.tag = object.tag ?? '';
    return message;
  },
};

function createBaseLineageGraphQueryOptions(): LineageGraphQueryOptions {
  return { artifactsOptions: undefined, stopConditions: undefined, maxNodeSize: 20 };
}

export const LineageGraphQueryOptions = {
  encode(message: LineageGraphQueryOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.artifactsOptions !== undefined) {
      ListOperationOptions.encode(message.artifactsOptions, writer.uint32(10).fork()).ldelim();
    }
    if (message.stopConditions !== undefined) {
      LineageGraphQueryOptions_BoundaryConstraint.encode(
        message.stopConditions,
        writer.uint32(18).fork(),
      ).ldelim();
    }
    if (message.maxNodeSize !== undefined && message.maxNodeSize !== 20) {
      writer.uint32(24).int64(message.maxNodeSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LineageGraphQueryOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineageGraphQueryOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactsOptions = ListOperationOptions.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stopConditions = LineageGraphQueryOptions_BoundaryConstraint.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxNodeSize = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LineageGraphQueryOptions {
    return {
      artifactsOptions: isSet(object.artifactsOptions)
        ? ListOperationOptions.fromJSON(object.artifactsOptions)
        : undefined,
      stopConditions: isSet(object.stopConditions)
        ? LineageGraphQueryOptions_BoundaryConstraint.fromJSON(object.stopConditions)
        : undefined,
      maxNodeSize: isSet(object.maxNodeSize) ? globalThis.Number(object.maxNodeSize) : 20,
    };
  },

  toJSON(message: LineageGraphQueryOptions): unknown {
    const obj: any = {};
    if (message.artifactsOptions !== undefined) {
      obj.artifactsOptions = ListOperationOptions.toJSON(message.artifactsOptions);
    }
    if (message.stopConditions !== undefined) {
      obj.stopConditions = LineageGraphQueryOptions_BoundaryConstraint.toJSON(
        message.stopConditions,
      );
    }
    if (message.maxNodeSize !== undefined && message.maxNodeSize !== 20) {
      obj.maxNodeSize = Math.round(message.maxNodeSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LineageGraphQueryOptions>, I>>(
    base?: I,
  ): LineageGraphQueryOptions {
    return LineageGraphQueryOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LineageGraphQueryOptions>, I>>(
    object: I,
  ): LineageGraphQueryOptions {
    const message = createBaseLineageGraphQueryOptions();
    message.artifactsOptions =
      object.artifactsOptions !== undefined && object.artifactsOptions !== null
        ? ListOperationOptions.fromPartial(object.artifactsOptions)
        : undefined;
    message.stopConditions =
      object.stopConditions !== undefined && object.stopConditions !== null
        ? LineageGraphQueryOptions_BoundaryConstraint.fromPartial(object.stopConditions)
        : undefined;
    message.maxNodeSize = object.maxNodeSize ?? 20;
    return message;
  },
};

function createBaseLineageGraphQueryOptions_BoundaryConstraint(): LineageGraphQueryOptions_BoundaryConstraint {
  return { maxNumHops: 0, boundaryArtifacts: '', boundaryExecutions: '' };
}

export const LineageGraphQueryOptions_BoundaryConstraint = {
  encode(
    message: LineageGraphQueryOptions_BoundaryConstraint,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.maxNumHops !== undefined && message.maxNumHops !== 0) {
      writer.uint32(8).int64(message.maxNumHops);
    }
    if (message.boundaryArtifacts !== undefined && message.boundaryArtifacts !== '') {
      writer.uint32(18).string(message.boundaryArtifacts);
    }
    if (message.boundaryExecutions !== undefined && message.boundaryExecutions !== '') {
      writer.uint32(26).string(message.boundaryExecutions);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): LineageGraphQueryOptions_BoundaryConstraint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineageGraphQueryOptions_BoundaryConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxNumHops = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.boundaryArtifacts = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.boundaryExecutions = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LineageGraphQueryOptions_BoundaryConstraint {
    return {
      maxNumHops: isSet(object.maxNumHops) ? globalThis.Number(object.maxNumHops) : 0,
      boundaryArtifacts: isSet(object.boundaryArtifacts)
        ? globalThis.String(object.boundaryArtifacts)
        : '',
      boundaryExecutions: isSet(object.boundaryExecutions)
        ? globalThis.String(object.boundaryExecutions)
        : '',
    };
  },

  toJSON(message: LineageGraphQueryOptions_BoundaryConstraint): unknown {
    const obj: any = {};
    if (message.maxNumHops !== undefined && message.maxNumHops !== 0) {
      obj.maxNumHops = Math.round(message.maxNumHops);
    }
    if (message.boundaryArtifacts !== undefined && message.boundaryArtifacts !== '') {
      obj.boundaryArtifacts = message.boundaryArtifacts;
    }
    if (message.boundaryExecutions !== undefined && message.boundaryExecutions !== '') {
      obj.boundaryExecutions = message.boundaryExecutions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LineageGraphQueryOptions_BoundaryConstraint>, I>>(
    base?: I,
  ): LineageGraphQueryOptions_BoundaryConstraint {
    return LineageGraphQueryOptions_BoundaryConstraint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LineageGraphQueryOptions_BoundaryConstraint>, I>>(
    object: I,
  ): LineageGraphQueryOptions_BoundaryConstraint {
    const message = createBaseLineageGraphQueryOptions_BoundaryConstraint();
    message.maxNumHops = object.maxNumHops ?? 0;
    message.boundaryArtifacts = object.boundaryArtifacts ?? '';
    message.boundaryExecutions = object.boundaryExecutions ?? '';
    return message;
  },
};

function createBaseLineageSubgraphQueryOptions(): LineageSubgraphQueryOptions {
  return {
    startingArtifacts: undefined,
    startingExecutions: undefined,
    maxNumHops: 0,
    direction: 0,
  };
}

export const LineageSubgraphQueryOptions = {
  encode(
    message: LineageSubgraphQueryOptions,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.startingArtifacts !== undefined) {
      LineageSubgraphQueryOptions_StartingNodes.encode(
        message.startingArtifacts,
        writer.uint32(10).fork(),
      ).ldelim();
    }
    if (message.startingExecutions !== undefined) {
      LineageSubgraphQueryOptions_StartingNodes.encode(
        message.startingExecutions,
        writer.uint32(18).fork(),
      ).ldelim();
    }
    if (message.maxNumHops !== undefined && message.maxNumHops !== 0) {
      writer.uint32(24).int64(message.maxNumHops);
    }
    if (message.direction !== undefined && message.direction !== 0) {
      writer.uint32(32).int32(message.direction);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LineageSubgraphQueryOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineageSubgraphQueryOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startingArtifacts = LineageSubgraphQueryOptions_StartingNodes.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startingExecutions = LineageSubgraphQueryOptions_StartingNodes.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxNumHops = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LineageSubgraphQueryOptions {
    return {
      startingArtifacts: isSet(object.startingArtifacts)
        ? LineageSubgraphQueryOptions_StartingNodes.fromJSON(object.startingArtifacts)
        : undefined,
      startingExecutions: isSet(object.startingExecutions)
        ? LineageSubgraphQueryOptions_StartingNodes.fromJSON(object.startingExecutions)
        : undefined,
      maxNumHops: isSet(object.maxNumHops) ? globalThis.Number(object.maxNumHops) : 0,
      direction: isSet(object.direction)
        ? lineageSubgraphQueryOptions_DirectionFromJSON(object.direction)
        : 0,
    };
  },

  toJSON(message: LineageSubgraphQueryOptions): unknown {
    const obj: any = {};
    if (message.startingArtifacts !== undefined) {
      obj.startingArtifacts = LineageSubgraphQueryOptions_StartingNodes.toJSON(
        message.startingArtifacts,
      );
    }
    if (message.startingExecutions !== undefined) {
      obj.startingExecutions = LineageSubgraphQueryOptions_StartingNodes.toJSON(
        message.startingExecutions,
      );
    }
    if (message.maxNumHops !== undefined && message.maxNumHops !== 0) {
      obj.maxNumHops = Math.round(message.maxNumHops);
    }
    if (message.direction !== undefined && message.direction !== 0) {
      obj.direction = lineageSubgraphQueryOptions_DirectionToJSON(message.direction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LineageSubgraphQueryOptions>, I>>(
    base?: I,
  ): LineageSubgraphQueryOptions {
    return LineageSubgraphQueryOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LineageSubgraphQueryOptions>, I>>(
    object: I,
  ): LineageSubgraphQueryOptions {
    const message = createBaseLineageSubgraphQueryOptions();
    message.startingArtifacts =
      object.startingArtifacts !== undefined && object.startingArtifacts !== null
        ? LineageSubgraphQueryOptions_StartingNodes.fromPartial(object.startingArtifacts)
        : undefined;
    message.startingExecutions =
      object.startingExecutions !== undefined && object.startingExecutions !== null
        ? LineageSubgraphQueryOptions_StartingNodes.fromPartial(object.startingExecutions)
        : undefined;
    message.maxNumHops = object.maxNumHops ?? 0;
    message.direction = object.direction ?? 0;
    return message;
  },
};

function createBaseLineageSubgraphQueryOptions_StartingNodes(): LineageSubgraphQueryOptions_StartingNodes {
  return { filterQuery: '' };
}

export const LineageSubgraphQueryOptions_StartingNodes = {
  encode(
    message: LineageSubgraphQueryOptions_StartingNodes,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.filterQuery !== undefined && message.filterQuery !== '') {
      writer.uint32(10).string(message.filterQuery);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): LineageSubgraphQueryOptions_StartingNodes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineageSubgraphQueryOptions_StartingNodes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filterQuery = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LineageSubgraphQueryOptions_StartingNodes {
    return { filterQuery: isSet(object.filterQuery) ? globalThis.String(object.filterQuery) : '' };
  },

  toJSON(message: LineageSubgraphQueryOptions_StartingNodes): unknown {
    const obj: any = {};
    if (message.filterQuery !== undefined && message.filterQuery !== '') {
      obj.filterQuery = message.filterQuery;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LineageSubgraphQueryOptions_StartingNodes>, I>>(
    base?: I,
  ): LineageSubgraphQueryOptions_StartingNodes {
    return LineageSubgraphQueryOptions_StartingNodes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LineageSubgraphQueryOptions_StartingNodes>, I>>(
    object: I,
  ): LineageSubgraphQueryOptions_StartingNodes {
    const message = createBaseLineageSubgraphQueryOptions_StartingNodes();
    message.filterQuery = object.filterQuery ?? '';
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER');
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === 'object' && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
