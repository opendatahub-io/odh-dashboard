// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v5.27.1
// source: ml_metadata/proto/metadata_store_service.proto

/* eslint-disable */
import Long from 'long';
import _m0 from 'protobufjs/minimal';
import { FieldMask } from '../../google/protobuf/field_mask';
import {
  Artifact,
  ArtifactType,
  Association,
  Attribution,
  Context,
  ContextType,
  Event,
  Execution,
  ExecutionType,
  LineageGraph,
  LineageGraphQueryOptions,
  LineageSubgraphQueryOptions,
  ListOperationOptions,
  ParentContext,
  TransactionOptions,
} from './metadata_store';

export const protobufPackage = 'ml_metadata';

/** An artifact and type pair. Part of an artifact struct. */
export interface ArtifactAndType {
  artifact?: Artifact | undefined;
  type?: ArtifactType | undefined;
}

/** A dictionary of artifact structs. Can represent a dictionary. */
export interface ArtifactStructMap {
  /**
   * An artifact struct that is a dictionary.
   * Can be represented as a JSON dictionary of artifact structs.
   */
  properties: { [key: string]: ArtifactStruct };
}

export interface ArtifactStructMap_PropertiesEntry {
  key: string;
  value: ArtifactStruct | undefined;
}

/** An artifact struct that is a list. */
export interface ArtifactStructList {
  /** Can be represented as a JSON list of artifact structs. */
  elements: ArtifactStruct[];
}

/**
 * An artifact struct represents the input or output of an Execution.
 * See the more specific types referenced in the message for more details.
 */
export interface ArtifactStruct {
  artifact?: ArtifactAndType | undefined;
  map?: ArtifactStructMap | undefined;
  list?: ArtifactStructList | undefined;
}

export interface PutArtifactsRequest {
  artifacts: Artifact[];
  /** Additional options to change the behavior of the method. */
  options?: PutArtifactsRequest_Options | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
  /**
   * FieldMask for artifacts in the PUT update
   * If `artifact.id` is not specified, it means a new artifact will be created
   * and `update_mask` will not be applied to the creation.
   * If `update_mask` is empty, update the artifacts as a whole.
   * If `update_mask` is not empty, only update fields or properties specified
   * in `update_mask`.
   * Example request protos:
   * 1. Examples that update `properties` / `custom_properties`:
   *   1.1 Add a <'key', 'val'> pair into `custom_properties`:
   *      {
   *        artifacts {
   *          id: 1234
   *          type_id: 5678
   *          custom_properties {
   *            key: "key"
   *            value: {
   *              string_value: "val"
   *            }
   *          }
   *        }
   *        update_mask {
   *          paths: "custom_properties.key"
   *        }
   *      }
   *   1.2 Set `custom_properties['key'].bool_value` to true:
   *      {
   *        artifacts {
   *          id: 1234
   *          type_id: 5678
   *          custom_properties {
   *            key: "key"
   *            value: {
   *              bool_value: true
   *            }
   *          }
   *        }
   *        update_mask {
   *          paths: "custom_properties.key"
   *        }
   *      }
   *   1.3 Delete the complete <'key', 'val'> pair from `custom_properties`:
   *      {
   *        artifacts {
   *          id: 1234
   *          type_id: 5678
   *          custom_properties {}
   *        }
   *        update_mask {
   *          paths: "custom_properties.key"
   *        }
   *      }
   * 2. Examples that update fields such as `uri`, `external_id`, etc:
   *   2.1 Update `external_id` field:
   *      {
   *        artifacts {
   *          id: 1234
   *          type_id: 5678
   *          external_id: "new_value"
   *        }
   *        update_mask {
   *          paths: "external_id"
   *        }
   *      }
   *   2.2 Set `uri` field:
   *      {
   *        artifacts {
   *          id: 1234
   *          type_id: 5678
   *          uri: "set_value"
   *        }
   *        update_mask {
   *          paths: "uri"
   *        }
   *      }
   * If `paths: "properties"` or `paths: "custom_properties"` are added to
   * `update_mask`, the key-level updates will be ignored and we only perform
   * field-level updates on the all `properties`/`custom_properties`.
   * For example:
   *   If the mask is: {"properties", "properties.key1"}, the field path
   *   "properties.key1" will be ignored and all `properties` will be updated.
   *   (Do not suggest)
   *   If the mask is {"properties", "external_id"}, all
   *   `properties` and field `external_id` will be updated. (Do not suggest)
   */
  updateMask?: string[] | undefined;
}

export interface PutArtifactsRequest_Options {
  /**
   * When there are multiple writers to update an existing node to
   * different states, there may be a race and the end result of the
   * concurrent update is nondeterministic. If the field is set, then an
   * optimistic concurrency control (OCC) scheme is used during update:
   * it compares the `artifact`.`last_update_time_since_epoch` in the request
   * with the stored `last_update_time_since_epoch` having the same
   * `artifact`.`id`. If they are different, the request fails, and the user
   * can read the stored node and retry node update.
   * When the option is set, the timestamp after update is guaranteed to be
   * increased and different from the input artifact.
   * When set the option, the caller should set it for all concurrent writers.
   */
  abortIfLatestUpdatedTimeChanged?: boolean | undefined;
}

export interface PutArtifactsResponse {
  /** A list of artifact ids index-aligned with PutArtifactsRequest. */
  artifactIds: number[];
}

export interface PutArtifactTypeRequest {
  /**
   * The field is required in any request. Stored types in MLMD can be updated
   * by introducing new properties and remain backward compatible. If a type
   * with the same name exists in the database, it updates the existing type,
   * otherwise it creates a new type.
   */
  artifactType?: ArtifactType | undefined;
  /**
   * If true then allows adding properties to an existing stored type.
   * If false, then type update is not allowed and it raises AlreadyExists
   * error if the given type has any new property that is not defined in the
   * stored type.
   */
  canAddFields?: boolean | undefined;
  /**
   * If true then allows omitting properties of an existing stored type.
   * If false, then no properties of the stored type can be omitted in the
   * given type, otherwise it raises AlreadyExists error.
   */
  canOmitFields?: boolean | undefined;
  /**
   * Deprecated fields.
   *
   * @deprecated
   */
  canDeleteFields?: boolean | undefined;
  /** @deprecated */
  allFieldsMatch?: boolean | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface PutArtifactTypeResponse {
  /** The type ID of the artifact type. */
  typeId?: number | undefined;
}

export interface PutExecutionsRequest {
  executions: Execution[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
  /**
   * FieldMask for executions in the PUT update
   * If `execution.id` is not specified, it means a new execution will be
   * created and `update_mask` will not be applied to the creation.
   * If `update_mask` is empty, update the executions as a whole.
   * If `update_mask` is not empty, only update fields or properties specified
   * in `update_mask`.
   * Example request protos:
   *   1. Add a <'key', 'val'> pair into `custom_properties`:
   *      {
   *        executions {
   *          id: 1234
   *          type_id: 5678
   *          custom_properties {
   *            key: "key"
   *            value: {
   *              string_value: "val"
   *            }
   *          }
   *        }
   *        update_mask {
   *          paths: "custom_properties.key"
   *        }
   *      }
   *   2. Set `last_known_state` field:
   *      {
   *        executions {
   *          id: 1234
   *          type_id: 5678
   *          last_known_state: CACHED
   *        }
   *        update_mask {
   *          paths: "last_known_state"
   *        }
   *      }
   * Please refer to `PutArtifactsRequest` for more details.
   */
  updateMask?: string[] | undefined;
}

export interface PutExecutionsResponse {
  /** A list of execution ids index-aligned with PutExecutionsRequest. */
  executionIds: number[];
}

export interface PutExecutionTypeRequest {
  /**
   * The field is required in any request. Stored types in MLMD can be updated
   * by introducing new properties and remain backward compatible. If a type
   * with the same name exists in the database, it updates the existing type,
   * otherwise it creates a new type.
   */
  executionType?: ExecutionType | undefined;
  /**
   * If true then allows adding properties to an existing stored type.
   * If false, then type update is not allowed and it raises AlreadyExists
   * error if the given type has any new property that is not defined in the
   * stored type.
   */
  canAddFields?: boolean | undefined;
  /**
   * If true then allows omitting properties of an existing stored type.
   * If false, then no properties of the stored type can be omitted in the
   * given type, otherwise it raises AlreadyExists error.
   */
  canOmitFields?: boolean | undefined;
  /**
   * Deprecated fields.
   *
   * @deprecated
   */
  canDeleteFields?: boolean | undefined;
  /** @deprecated */
  allFieldsMatch?: boolean | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface PutExecutionTypeResponse {
  /** The type ID of the execution type. */
  typeId?: number | undefined;
}

export interface PutEventsRequest {
  events: Event[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface PutEventsResponse {}

export interface PutExecutionRequest {
  /** The execution that produces many artifact and event pairs. */
  execution?: Execution | undefined;
  /** The list of artifact and event pairs. */
  artifactEventPairs: PutExecutionRequest_ArtifactAndEvent[];
  /**
   * A list of contexts associated with the execution and artifacts. For each
   * given context without a context.id, it inserts the context, otherwise it
   * updates the stored context with the same id.
   * Associations between each pair of contexts and the execution, and
   * attributions between each pair of contexts and artifacts are created if
   * they do not already exist.
   */
  contexts: Context[];
  /** Additional options to change the behavior of the method. */
  options?: PutExecutionRequest_Options | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

/**
 * A pair of an artifact and an event used or generated by an execution, e.g.,
 * during the execution run, it uses none or many artifacts as input, and
 * generate none or many artifacts as output.
 */
export interface PutExecutionRequest_ArtifactAndEvent {
  /**
   * The pair may have an artifact. If present and no artifact.id is given,
   * then it inserts the artifact, otherwise it updates the artifact.
   */
  artifact?: Artifact | undefined;
  /**
   * The pair may have an event. Providing event.artifact_id or
   * event.execution_id is optional. If the ids are given, it must align with
   * the `artifact`.id / `execution`.id respectively. If artifact is not
   * given and event.artifact_id is set, it must exist in the backend.
   */
  event?: Event | undefined;
}

export interface PutExecutionRequest_Options {
  /**
   * When there's a race to publish executions with a new context with the
   * same context.name, by default there'll be one writer succeeds and
   * the rest of the writers returning AlreadyExists errors. If set to true,
   * the API will reuse the stored context in the transaction and perform
   * an update.
   */
  reuseContextIfAlreadyExist?: boolean | undefined;
  /**
   * When there's a race to publish executions with a new artifact with the
   * same artifact.external_id, by default there'll be one writer succeeds and
   * the rest of the writers returning AlreadyExists errors.
   * If set to true and an Artifact has non-empty external_id,
   * the API will reuse the stored artifact in the transaction and
   * perform an update. Otherwise, it will fall back to relying on `id` field
   * to decide if it's update (if `id` exists) or insert (if `id` is empty).
   */
  reuseArtifactIfAlreadyExistByExternalId?: boolean | undefined;
}

export interface PutExecutionResponse {
  /** An execution id of the `execution` in PutExecutionRequest. */
  executionId?: number | undefined;
  /**
   * A list of artifact ids index-aligned with `artifact_event_pairs` in the
   * PutExecutionRequest.
   */
  artifactIds: number[];
  /**
   * A list of context ids index-aligned with `contexts` in the
   * PutExecutionRequest.
   */
  contextIds: number[];
}

export interface PutLineageSubgraphRequest {
  executions: Execution[];
  artifacts: Artifact[];
  contexts: Context[];
  eventEdges: PutLineageSubgraphRequest_EventEdge[];
  options?: PutLineageSubgraphRequest_Options | undefined;
  transactionOptions?: TransactionOptions | undefined;
}

export interface PutLineageSubgraphRequest_EventEdge {
  /** Index in the array of executions. */
  executionIndex?: number | undefined;
  /** Index in the array of artifacts. */
  artifactIndex?: number | undefined;
  event?: Event | undefined;
}

export interface PutLineageSubgraphRequest_Options {
  /**
   * When there's a race to publish executions with a new context with the
   * same context.name, by default there'll be one writer succeeds and
   * the rest of the writers returning AlreadyExists errors. If set to true,
   * the API will reuse the stored context in the transaction and perform
   * an update.
   */
  reuseContextIfAlreadyExist?: boolean | undefined;
  /**
   * When there's a race to publish executions with a new artifact with the
   * same artifact.external_id, by default there'll be one writer succeeds and
   * the rest of the writers returning AlreadyExists errors.
   * If set to true and an Artifact has non-empty external_id,
   * the API will reuse the stored artifact in the transaction and
   * perform an update. Otherwise, it will fall back to relying on `id` field
   * to decide if it's update (if `id` exists) or insert (if `id` is empty).
   */
  reuseArtifactIfAlreadyExistByExternalId?: boolean | undefined;
}

export interface PutLineageSubgraphResponse {
  /** A list of execution ids index-aligned with `executions` in the request */
  executionIds: number[];
  /** A list of artifact ids index-aligned with `artifacts` in the request */
  artifactIds: number[];
  /** A list of context ids index-aligned with `contexts` in the request */
  contextIds: number[];
}

export interface PutTypesRequest {
  artifactTypes: ArtifactType[];
  executionTypes: ExecutionType[];
  contextTypes: ContextType[];
  /**
   * If true then allows adding properties to an existing stored type.
   * If false, then type update is not allowed and it raises AlreadyExists
   * error if the given type has any new property that is not defined in the
   * stored type.
   */
  canAddFields?: boolean | undefined;
  /**
   * If true then allows omitting properties of an existing stored type.
   * If false, then no properties of the stored type can be omitted in the
   * given type, otherwise it raises AlreadyExists error.
   */
  canOmitFields?: boolean | undefined;
  /**
   * Deprecated fields.
   *
   * @deprecated
   */
  canDeleteFields?: boolean | undefined;
  /** @deprecated */
  allFieldsMatch?: boolean | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface PutTypesResponse {
  /** The type ids of the artifact type. */
  artifactTypeIds: number[];
  /** The type ids of the execution type. */
  executionTypeIds: number[];
  /** The type ids of the context type. */
  contextTypeIds: number[];
}

export interface PutContextTypeRequest {
  /**
   * The field is required in any request. Stored types in MLMD can be updated
   * by introducing new properties and remain backward compatible. If a type
   * with the same name exists in the database, it updates the existing type,
   * otherwise it creates a new type.
   */
  contextType?: ContextType | undefined;
  /**
   * If true then allows adding properties to an existing stored type.
   * If false, then type update is not allowed and it raises AlreadyExists
   * error if the given type has any new property that is not defined in the
   * stored type.
   */
  canAddFields?: boolean | undefined;
  /**
   * If true then allows omitting properties of an existing stored type.
   * If false, then no properties of the stored type can be omitted in the
   * given type, otherwise it raises AlreadyExists error.
   */
  canOmitFields?: boolean | undefined;
  /**
   * Deprecated fields.
   *
   * @deprecated
   */
  canDeleteFields?: boolean | undefined;
  /** @deprecated */
  allFieldsMatch?: boolean | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface PutContextTypeResponse {
  /** The type ID of the context type. */
  typeId?: number | undefined;
}

export interface PutContextsRequest {
  contexts: Context[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
  /**
   * FieldMask for contexts in the PUT update
   * If `context.id` is not specified, it means a new context will be
   * created and `update_mask` will not be applied to the creation.
   * If `update_mask` is empty, update the contexts as a whole.
   * If `update_mask` is not empty, only update fields or properties specified
   * in `update_mask`.
   * Example request protos:
   *   1. Add a <'key', 'val'> pair into `custom_properties`:
   *      {
   *        contexts {
   *          id: 1234
   *          type_id: 5678
   *          custom_properties {
   *            key: "key"
   *            value: {
   *              string_value: "val"
   *            }
   *          }
   *        }
   *        update_mask {
   *          paths: "custom_properties.key"
   *        }
   *      }
   *   2. Set `name` field:
   *      {
   *        contexts {
   *          id: 1234
   *          type_id: 5678
   *          name: "set_name"
   *        }
   *        update_mask {
   *          paths: "name"
   *        }
   *      }
   * Please refer to `PutArtifactsRequest` for more details.
   */
  updateMask?: string[] | undefined;
}

export interface PutContextsResponse {
  /** A list of context ids index-aligned with PutContextsRequest. */
  contextIds: number[];
}

export interface PutAttributionsAndAssociationsRequest {
  attributions: Attribution[];
  associations: Association[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface PutAttributionsAndAssociationsResponse {}

export interface PutParentContextsRequest {
  parentContexts: ParentContext[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface PutParentContextsResponse {}

export interface GetArtifactsByTypeRequest {
  typeName?: string | undefined;
  /** If not set, it looks for the type with type_name with default type_version. */
  typeVersion?: string | undefined;
  /**
   * Specify List options.
   * Currently supports:
   *   1. Field to order the results.
   *   2. Page size.
   * If set, the request will
   *   first fetch all artifacts with specified `type_name` and `type_version`,
   *   then order by a specifield field
   *   finally find the correct page and return #Artifacts of the page size.
   * Higher-level APIs may only use the functionalies partially.
   * Please reference the API documentation for the API behaviors.
   */
  options?: ListOperationOptions | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetArtifactsByTypeResponse {
  artifacts: Artifact[];
  /**
   * Token to use to retrieve next page of results if list options are used in
   * the request.
   */
  nextPageToken?: string | undefined;
}

export interface GetArtifactByTypeAndNameRequest {
  typeName?: string | undefined;
  /**
   * If not set, it looks for the type with type_name and artifact_name with
   * default type_version.
   */
  typeVersion?: string | undefined;
  artifactName?: string | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetArtifactByTypeAndNameResponse {
  artifact?: Artifact | undefined;
}

export interface GetArtifactsByIDRequest {
  /** A list of artifact ids to retrieve. */
  artifactIds: number[];
  /**
   * An option to populate all the ArtifactTypes in the response.
   * If true, returns retrieved Artifacts and their artifact types, which can be
   * matched by type_ids.
   * If false, returns only the retrieved Artifacts.
   * Example request proto:
   *   {
   *     artifact_ids: 101,
   *     populate_artifact_types: true,
   *   }
   *   The response will contain an artifact with id = 101 and an artifact type
   *   with id = artifact.type_id().
   */
  populateArtifactTypes?: boolean | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetArtifactsByIDResponse {
  /**
   * Artifacts with matching ids.
   * This is not index-aligned: if an id is not found, it is not returned.
   */
  artifacts: Artifact[];
  /**
   * ArtifactTypes populated with matching type_ids owned by `artifacts`.
   * This is not index-aligned: if a type_id is not found, it is not returned.
   */
  artifactTypes: ArtifactType[];
}

/**
 * Request to retrieve Artifacts using List options.
 * If option is not specified then all Artifacts are returned.
 */
export interface GetArtifactsRequest {
  /**
   * Specify options.
   * Please refer to the documentation of ListOperationOptions for the supported
   * functionalities.
   */
  options?: ListOperationOptions | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetArtifactsResponse {
  /** Returned artifacts. */
  artifacts: Artifact[];
  /**
   * Token to use to retrieve next page of results if list options are used in
   * the request.
   */
  nextPageToken?: string | undefined;
}

export interface GetArtifactsByURIRequest {
  /** A list of artifact uris to retrieve. */
  uris: string[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetArtifactsByURIResponse {
  artifacts: Artifact[];
}

/**
 * Request to retrieve Executions using List options.
 * If option is not specified then all Executions are returned.
 */
export interface GetExecutionsRequest {
  /**
   * Specify options.
   * Please refer to the documentation of ListOperationOptions for the supported
   * functionalities.
   */
  options?: ListOperationOptions | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetExecutionsResponse {
  /** Returned executions. */
  executions: Execution[];
  /**
   * Token to use to retrieve next page of results if list options are used in
   * the request.
   */
  nextPageToken?: string | undefined;
}

export interface GetArtifactTypeRequest {
  typeName?: string | undefined;
  /** If not set, it looks for the type with type_name with default type_version. */
  typeVersion?: string | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetArtifactTypeResponse {
  /** Gets an artifact type, or clear if it does not exist. */
  artifactType?: ArtifactType | undefined;
}

export interface GetArtifactTypesRequest {
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetArtifactTypesResponse {
  artifactTypes: ArtifactType[];
}

export interface GetExecutionTypesRequest {
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetExecutionTypesResponse {
  executionTypes: ExecutionType[];
}

export interface GetContextTypesRequest {
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetContextTypesResponse {
  contextTypes: ContextType[];
}

export interface GetArtifactsByExternalIdsRequest {
  externalIds: string[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetArtifactsByExternalIdsResponse {
  artifacts: Artifact[];
}

export interface GetExecutionsByExternalIdsRequest {
  externalIds: string[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetExecutionsByExternalIdsResponse {
  executions: Execution[];
}

export interface GetContextsByExternalIdsRequest {
  externalIds: string[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetContextsByExternalIdsResponse {
  contexts: Context[];
}

export interface GetArtifactTypesByExternalIdsRequest {
  externalIds: string[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetArtifactTypesByExternalIdsResponse {
  artifactTypes: ArtifactType[];
}

export interface GetExecutionTypesByExternalIdsRequest {
  externalIds: string[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetExecutionTypesByExternalIdsResponse {
  executionTypes: ExecutionType[];
}

export interface GetContextTypesByExternalIdsRequest {
  externalIds: string[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetContextTypesByExternalIdsResponse {
  contextTypes: ContextType[];
}

export interface GetExecutionsByTypeRequest {
  typeName?: string | undefined;
  /** If not set, it looks for the type with type_name with default type_version. */
  typeVersion?: string | undefined;
  /**
   * Specify List options.
   * Currently supports:
   *   1. Field to order the results.
   *   2. Page size.
   * If set, the request will
   *   first fetch all executions with specified `type_name` and `type_version`,
   *   then order by a specifield field
   *   finally find the correct page and return #Executions of the page size.
   * Higher-level APIs may only use the functionalies partially.
   * Please reference the API documentation for the API behaviors.
   */
  options?: ListOperationOptions | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetExecutionsByTypeResponse {
  executions: Execution[];
  /**
   * Token to use to retrieve next page of results if list options are used in
   * the request.
   */
  nextPageToken?: string | undefined;
}

export interface GetExecutionByTypeAndNameRequest {
  typeName?: string | undefined;
  /**
   * If not set, it looks for the type with type_name and execution_name with
   * default type_version.
   */
  typeVersion?: string | undefined;
  executionName?: string | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetExecutionByTypeAndNameResponse {
  execution?: Execution | undefined;
}

export interface GetExecutionsByIDRequest {
  /** A list of execution ids to retrieve. */
  executionIds: number[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetExecutionsByIDResponse {
  /**
   * The result is not index-aligned: if an id is not found, it is not
   * returned.
   */
  executions: Execution[];
}

export interface GetExecutionTypeRequest {
  typeName?: string | undefined;
  /** If not set, it looks for the type with type_name with default type_version. */
  typeVersion?: string | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetExecutionTypeResponse {
  /** Gets an execution type, or clear if it does not exist. */
  executionType?: ExecutionType | undefined;
}

/** Gets all events with matching execution ids. */
export interface GetEventsByExecutionIDsRequest {
  executionIds: number[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetEventsByExecutionIDsResponse {
  events: Event[];
}

export interface GetEventsByArtifactIDsRequest {
  artifactIds: number[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetEventsByArtifactIDsResponse {
  events: Event[];
}

export interface GetArtifactTypesByIDRequest {
  typeIds: number[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetArtifactTypesByIDResponse {
  /**
   * The result is not index-aligned: if an id is not found, it is not
   * returned.
   */
  artifactTypes: ArtifactType[];
}

export interface GetExecutionTypesByIDRequest {
  typeIds: number[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetExecutionTypesByIDResponse {
  /**
   * The result is not index-aligned: if an id is not found, it is not
   * returned.
   */
  executionTypes: ExecutionType[];
}

export interface GetContextTypeRequest {
  typeName?: string | undefined;
  /** If not set, it looks for the type with type_name with default type_version. */
  typeVersion?: string | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetContextTypeResponse {
  /** Gets a context type, or clear if it does not exist. */
  contextType?: ContextType | undefined;
}

export interface GetContextTypesByIDRequest {
  typeIds: number[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetContextTypesByIDResponse {
  /**
   * The result is not index-aligned: if an id is not found, it is not
   * returned.
   */
  contextTypes: ContextType[];
}

/**
 * Request to retrieve Contexts using List options.
 * If option is not specified then all Contexts are returned.
 */
export interface GetContextsRequest {
  /**
   * Specify options.
   * Please refer to the documentation of ListOperationOptions for the supported
   * functionalities.
   */
  options?: ListOperationOptions | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetContextsResponse {
  /** Returned contexts. */
  contexts: Context[];
  /**
   * Token to use to retrieve next page of results if list options are used in
   * the request.
   */
  nextPageToken?: string | undefined;
}

export interface GetContextsByTypeRequest {
  typeName?: string | undefined;
  /**
   * Specify options.
   * Currently supports:
   *   1. Field to order the results.
   *   2. Page size.
   * If set, the request will
   *   first fetch all contexts with specified `type_name` and `type_version`,
   *   then order by a specifield field
   *   finally find the correct page and return #Contexts of the page size.
   * Higher-level APIs may only use the functionalies partially.
   * Please reference the API documentation for the API behaviors.
   */
  options?: ListOperationOptions | undefined;
  /**
   * If not set, it looks for the type with type_name and options with default
   * type_version.
   */
  typeVersion?: string | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetContextsByTypeResponse {
  contexts: Context[];
  /**
   * Token to use to retrieve next page of results if list options are used in
   * the request.
   */
  nextPageToken?: string | undefined;
}

export interface GetContextByTypeAndNameRequest {
  typeName?: string | undefined;
  /**
   * If not set, it looks for the type with type_name and context_name with
   * default type_version.
   */
  typeVersion?: string | undefined;
  contextName?: string | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetContextByTypeAndNameResponse {
  context?: Context | undefined;
}

export interface GetContextsByIDRequest {
  /** A list of context ids to retrieve. */
  contextIds: number[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetContextsByIDResponse {
  /**
   * The result is not index-aligned: if an id is not found, it is not
   * returned.
   */
  contexts: Context[];
}

export interface GetContextsByArtifactRequest {
  artifactId?: number | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetContextsByArtifactResponse {
  contexts: Context[];
}

export interface GetContextsByExecutionRequest {
  executionId?: number | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetContextsByExecutionResponse {
  contexts: Context[];
}

export interface GetParentContextsByContextRequest {
  contextId?: number | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetParentContextsByContextResponse {
  contexts: Context[];
}

export interface GetChildrenContextsByContextRequest {
  contextId?: number | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetChildrenContextsByContextResponse {
  contexts: Context[];
}

export interface GetParentContextsByContextsRequest {
  contextIds: number[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetParentContextsByContextsResponse {
  contexts: { [key: number]: GetParentContextsByContextsResponse_ParentContextsPerChild };
}

export interface GetParentContextsByContextsResponse_ParentContextsPerChild {
  parentContexts: Context[];
}

export interface GetParentContextsByContextsResponse_ContextsEntry {
  key: number;
  value: GetParentContextsByContextsResponse_ParentContextsPerChild | undefined;
}

export interface GetChildrenContextsByContextsRequest {
  contextIds: number[];
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetChildrenContextsByContextsResponse {
  contexts: { [key: number]: GetChildrenContextsByContextsResponse_ChildrenContextsPerParent };
}

export interface GetChildrenContextsByContextsResponse_ChildrenContextsPerParent {
  childrenContexts: Context[];
}

export interface GetChildrenContextsByContextsResponse_ContextsEntry {
  key: number;
  value: GetChildrenContextsByContextsResponse_ChildrenContextsPerParent | undefined;
}

export interface GetArtifactsByContextRequest {
  contextId?: number | undefined;
  /**
   * Specify List options.
   * Currently supports:
   *   1. Field to order the results.
   *   2. Page size.
   */
  options?: ListOperationOptions | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetArtifactsByContextResponse {
  artifacts: Artifact[];
  /**
   * Token to use to retrieve next page of results if list options are used in
   * the request.
   */
  nextPageToken?: string | undefined;
}

export interface GetExecutionsByContextRequest {
  contextId?: number | undefined;
  /**
   * Specify List options.
   * Currently supports:
   *   1. Field to order the results.
   *   2. Page size.
   */
  options?: ListOperationOptions | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetExecutionsByContextResponse {
  executions: Execution[];
  /**
   * Token to use to retrieve next page of results if list options are used in
   * the request.
   */
  nextPageToken?: string | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

/**
 * TODO(b/283852485): Deprecate GetLineageGraph API after migration to
 * GetLineageSubgraph API.
 * A lineage query request to specify the query nodes of interest and the
 * boundary conditions for pruning the returned graph.
 */
export interface GetLineageGraphRequest {
  options?: LineageGraphQueryOptions | undefined;
  /** Options regarding transactions. */
  transactionOptions?: TransactionOptions | undefined;
}

/**
 * A connected lineage `subgraph` about the MLMD nodes derived from
 * LineageGraphRequest.query_conditions.
 */
export interface GetLineageGraphResponse {
  subgraph?: LineageGraph | undefined;
}

export interface GetLineageSubgraphRequest {
  /**
   * Query options for lineage graph tracing from a list of interested
   * nodes.
   * A lineage subgraph without node details (e.g., external_id, properties)
   * will be returned. Please refer to `LineageSubgraphQueryOptions` for more
   * details.
   */
  lineageSubgraphQueryOptions?: LineageSubgraphQueryOptions | undefined;
  /**
   * `read_mask` contains user specified paths of fields that should be included
   * in the returned lineage subgraph.
   *   Supported field paths are: 'artifacts', 'executions', 'contexts',
   *   'artifact_types', 'execution_types', 'context_types', and 'events'.
   *   TODO(b/283852485): Include 'associations' or 'attributions' in the
   *     returned graph.
   *   If 'artifacts', 'executions', or 'contexts' is specified in `read_mask`,
   *     the dehydrated nodes will be included.
   *     Note: A dehydrated node means a node containing only its id and no
   *     other information. User should call GetNodesByID or other APIs to get
   *     node details later on.
   *   If 'artifact_types', 'execution_types', or 'context_types' is specified
   *     in `read_mask`, all the node types will be included.
   *   If 'events' is specified in `read_mask`, the events will be included.
   *   If `read_mask` is not set, the API will return all the fields in
   *     the returned graph.
   *   Note: Only paths of fields in LineageGraph message are supported. Paths
   *   of fields in the submessage, such as "artifacts.id", "contexts.name" are
   *   not acknowledged.
   */
  readMask?: string[] | undefined;
  transactionOptions?: TransactionOptions | undefined;
}

export interface GetLineageSubgraphResponse {
  /**
   * A lineage subgraph of MLMD nodes and relations retrieved from lineage
   * graph tracing.
   */
  lineageSubgraph?: LineageGraph | undefined;
}

function createBaseArtifactAndType(): ArtifactAndType {
  return { artifact: undefined, type: undefined };
}

export const ArtifactAndType = {
  encode(message: ArtifactAndType, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.artifact !== undefined) {
      Artifact.encode(message.artifact, writer.uint32(10).fork()).ldelim();
    }
    if (message.type !== undefined) {
      ArtifactType.encode(message.type, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ArtifactAndType {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactAndType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifact = Artifact.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = ArtifactType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactAndType {
    return {
      artifact: isSet(object.artifact) ? Artifact.fromJSON(object.artifact) : undefined,
      type: isSet(object.type) ? ArtifactType.fromJSON(object.type) : undefined,
    };
  },

  toJSON(message: ArtifactAndType): unknown {
    const obj: any = {};
    if (message.artifact !== undefined) {
      obj.artifact = Artifact.toJSON(message.artifact);
    }
    if (message.type !== undefined) {
      obj.type = ArtifactType.toJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArtifactAndType>, I>>(base?: I): ArtifactAndType {
    return ArtifactAndType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArtifactAndType>, I>>(object: I): ArtifactAndType {
    const message = createBaseArtifactAndType();
    message.artifact =
      object.artifact !== undefined && object.artifact !== null
        ? Artifact.fromPartial(object.artifact)
        : undefined;
    message.type =
      object.type !== undefined && object.type !== null
        ? ArtifactType.fromPartial(object.type)
        : undefined;
    return message;
  },
};

function createBaseArtifactStructMap(): ArtifactStructMap {
  return { properties: {} };
}

export const ArtifactStructMap = {
  encode(message: ArtifactStructMap, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.properties).forEach(([key, value]) => {
      ArtifactStructMap_PropertiesEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ArtifactStructMap {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactStructMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ArtifactStructMap_PropertiesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.properties[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactStructMap {
    return {
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: ArtifactStruct }>(
            (acc, [key, value]) => {
              acc[key] = ArtifactStruct.fromJSON(value);
              return acc;
            },
            {},
          )
        : {},
    };
  },

  toJSON(message: ArtifactStructMap): unknown {
    const obj: any = {};
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = ArtifactStruct.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArtifactStructMap>, I>>(base?: I): ArtifactStructMap {
    return ArtifactStructMap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArtifactStructMap>, I>>(object: I): ArtifactStructMap {
    const message = createBaseArtifactStructMap();
    message.properties = Object.entries(object.properties ?? {}).reduce<{
      [key: string]: ArtifactStruct;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = ArtifactStruct.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseArtifactStructMap_PropertiesEntry(): ArtifactStructMap_PropertiesEntry {
  return { key: '', value: undefined };
}

export const ArtifactStructMap_PropertiesEntry = {
  encode(
    message: ArtifactStructMap_PropertiesEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ArtifactStruct.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ArtifactStructMap_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactStructMap_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ArtifactStruct.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactStructMap_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : '',
      value: isSet(object.value) ? ArtifactStruct.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ArtifactStructMap_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== '') {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ArtifactStruct.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArtifactStructMap_PropertiesEntry>, I>>(
    base?: I,
  ): ArtifactStructMap_PropertiesEntry {
    return ArtifactStructMap_PropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArtifactStructMap_PropertiesEntry>, I>>(
    object: I,
  ): ArtifactStructMap_PropertiesEntry {
    const message = createBaseArtifactStructMap_PropertiesEntry();
    message.key = object.key ?? '';
    message.value =
      object.value !== undefined && object.value !== null
        ? ArtifactStruct.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseArtifactStructList(): ArtifactStructList {
  return { elements: [] };
}

export const ArtifactStructList = {
  encode(message: ArtifactStructList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.elements) {
      ArtifactStruct.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ArtifactStructList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactStructList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.elements.push(ArtifactStruct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactStructList {
    return {
      elements: globalThis.Array.isArray(object?.elements)
        ? object.elements.map((e: any) => ArtifactStruct.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ArtifactStructList): unknown {
    const obj: any = {};
    if (message.elements?.length) {
      obj.elements = message.elements.map((e) => ArtifactStruct.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArtifactStructList>, I>>(base?: I): ArtifactStructList {
    return ArtifactStructList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArtifactStructList>, I>>(object: I): ArtifactStructList {
    const message = createBaseArtifactStructList();
    message.elements = object.elements?.map((e) => ArtifactStruct.fromPartial(e)) || [];
    return message;
  },
};

function createBaseArtifactStruct(): ArtifactStruct {
  return { artifact: undefined, map: undefined, list: undefined };
}

export const ArtifactStruct = {
  encode(message: ArtifactStruct, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.artifact !== undefined) {
      ArtifactAndType.encode(message.artifact, writer.uint32(10).fork()).ldelim();
    }
    if (message.map !== undefined) {
      ArtifactStructMap.encode(message.map, writer.uint32(18).fork()).ldelim();
    }
    if (message.list !== undefined) {
      ArtifactStructList.encode(message.list, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ArtifactStruct {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactStruct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifact = ArtifactAndType.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.map = ArtifactStructMap.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.list = ArtifactStructList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactStruct {
    return {
      artifact: isSet(object.artifact) ? ArtifactAndType.fromJSON(object.artifact) : undefined,
      map: isSet(object.map) ? ArtifactStructMap.fromJSON(object.map) : undefined,
      list: isSet(object.list) ? ArtifactStructList.fromJSON(object.list) : undefined,
    };
  },

  toJSON(message: ArtifactStruct): unknown {
    const obj: any = {};
    if (message.artifact !== undefined) {
      obj.artifact = ArtifactAndType.toJSON(message.artifact);
    }
    if (message.map !== undefined) {
      obj.map = ArtifactStructMap.toJSON(message.map);
    }
    if (message.list !== undefined) {
      obj.list = ArtifactStructList.toJSON(message.list);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArtifactStruct>, I>>(base?: I): ArtifactStruct {
    return ArtifactStruct.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArtifactStruct>, I>>(object: I): ArtifactStruct {
    const message = createBaseArtifactStruct();
    message.artifact =
      object.artifact !== undefined && object.artifact !== null
        ? ArtifactAndType.fromPartial(object.artifact)
        : undefined;
    message.map =
      object.map !== undefined && object.map !== null
        ? ArtifactStructMap.fromPartial(object.map)
        : undefined;
    message.list =
      object.list !== undefined && object.list !== null
        ? ArtifactStructList.fromPartial(object.list)
        : undefined;
    return message;
  },
};

function createBasePutArtifactsRequest(): PutArtifactsRequest {
  return {
    artifacts: [],
    options: undefined,
    transactionOptions: undefined,
    updateMask: undefined,
  };
}

export const PutArtifactsRequest = {
  encode(message: PutArtifactsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.artifacts) {
      Artifact.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.options !== undefined) {
      PutArtifactsRequest_Options.encode(message.options, writer.uint32(18).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(26).fork()).ldelim();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutArtifactsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutArtifactsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifacts.push(Artifact.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.options = PutArtifactsRequest_Options.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutArtifactsRequest {
    return {
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => Artifact.fromJSON(e))
        : [],
      options: isSet(object.options)
        ? PutArtifactsRequest_Options.fromJSON(object.options)
        : undefined,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
      updateMask: isSet(object.updateMask)
        ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask))
        : undefined,
    };
  },

  toJSON(message: PutArtifactsRequest): unknown {
    const obj: any = {};
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => Artifact.toJSON(e));
    }
    if (message.options !== undefined) {
      obj.options = PutArtifactsRequest_Options.toJSON(message.options);
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutArtifactsRequest>, I>>(base?: I): PutArtifactsRequest {
    return PutArtifactsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutArtifactsRequest>, I>>(
    object: I,
  ): PutArtifactsRequest {
    const message = createBasePutArtifactsRequest();
    message.artifacts = object.artifacts?.map((e) => Artifact.fromPartial(e)) || [];
    message.options =
      object.options !== undefined && object.options !== null
        ? PutArtifactsRequest_Options.fromPartial(object.options)
        : undefined;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBasePutArtifactsRequest_Options(): PutArtifactsRequest_Options {
  return { abortIfLatestUpdatedTimeChanged: false };
}

export const PutArtifactsRequest_Options = {
  encode(
    message: PutArtifactsRequest_Options,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (
      message.abortIfLatestUpdatedTimeChanged !== undefined &&
      message.abortIfLatestUpdatedTimeChanged !== false
    ) {
      writer.uint32(8).bool(message.abortIfLatestUpdatedTimeChanged);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutArtifactsRequest_Options {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutArtifactsRequest_Options();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.abortIfLatestUpdatedTimeChanged = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutArtifactsRequest_Options {
    return {
      abortIfLatestUpdatedTimeChanged: isSet(object.abortIfLatestUpdatedTimeChanged)
        ? globalThis.Boolean(object.abortIfLatestUpdatedTimeChanged)
        : false,
    };
  },

  toJSON(message: PutArtifactsRequest_Options): unknown {
    const obj: any = {};
    if (
      message.abortIfLatestUpdatedTimeChanged !== undefined &&
      message.abortIfLatestUpdatedTimeChanged !== false
    ) {
      obj.abortIfLatestUpdatedTimeChanged = message.abortIfLatestUpdatedTimeChanged;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutArtifactsRequest_Options>, I>>(
    base?: I,
  ): PutArtifactsRequest_Options {
    return PutArtifactsRequest_Options.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutArtifactsRequest_Options>, I>>(
    object: I,
  ): PutArtifactsRequest_Options {
    const message = createBasePutArtifactsRequest_Options();
    message.abortIfLatestUpdatedTimeChanged = object.abortIfLatestUpdatedTimeChanged ?? false;
    return message;
  },
};

function createBasePutArtifactsResponse(): PutArtifactsResponse {
  return { artifactIds: [] };
}

export const PutArtifactsResponse = {
  encode(message: PutArtifactsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.artifactIds) {
      writer.int64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutArtifactsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutArtifactsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.artifactIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.artifactIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutArtifactsResponse {
    return {
      artifactIds: globalThis.Array.isArray(object?.artifactIds)
        ? object.artifactIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: PutArtifactsResponse): unknown {
    const obj: any = {};
    if (message.artifactIds?.length) {
      obj.artifactIds = message.artifactIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutArtifactsResponse>, I>>(base?: I): PutArtifactsResponse {
    return PutArtifactsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutArtifactsResponse>, I>>(
    object: I,
  ): PutArtifactsResponse {
    const message = createBasePutArtifactsResponse();
    message.artifactIds = object.artifactIds?.map((e) => e) || [];
    return message;
  },
};

function createBasePutArtifactTypeRequest(): PutArtifactTypeRequest {
  return {
    artifactType: undefined,
    canAddFields: false,
    canOmitFields: false,
    canDeleteFields: false,
    allFieldsMatch: true,
    transactionOptions: undefined,
  };
}

export const PutArtifactTypeRequest = {
  encode(message: PutArtifactTypeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.artifactType !== undefined) {
      ArtifactType.encode(message.artifactType, writer.uint32(10).fork()).ldelim();
    }
    if (message.canAddFields !== undefined && message.canAddFields !== false) {
      writer.uint32(16).bool(message.canAddFields);
    }
    if (message.canOmitFields !== undefined && message.canOmitFields !== false) {
      writer.uint32(40).bool(message.canOmitFields);
    }
    if (message.canDeleteFields !== undefined && message.canDeleteFields !== false) {
      writer.uint32(24).bool(message.canDeleteFields);
    }
    if (message.allFieldsMatch !== undefined && message.allFieldsMatch !== true) {
      writer.uint32(32).bool(message.allFieldsMatch);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutArtifactTypeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutArtifactTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactType = ArtifactType.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.canAddFields = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.canOmitFields = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.canDeleteFields = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allFieldsMatch = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutArtifactTypeRequest {
    return {
      artifactType: isSet(object.artifactType)
        ? ArtifactType.fromJSON(object.artifactType)
        : undefined,
      canAddFields: isSet(object.canAddFields) ? globalThis.Boolean(object.canAddFields) : false,
      canOmitFields: isSet(object.canOmitFields) ? globalThis.Boolean(object.canOmitFields) : false,
      canDeleteFields: isSet(object.canDeleteFields)
        ? globalThis.Boolean(object.canDeleteFields)
        : false,
      allFieldsMatch: isSet(object.allFieldsMatch)
        ? globalThis.Boolean(object.allFieldsMatch)
        : true,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: PutArtifactTypeRequest): unknown {
    const obj: any = {};
    if (message.artifactType !== undefined) {
      obj.artifactType = ArtifactType.toJSON(message.artifactType);
    }
    if (message.canAddFields !== undefined && message.canAddFields !== false) {
      obj.canAddFields = message.canAddFields;
    }
    if (message.canOmitFields !== undefined && message.canOmitFields !== false) {
      obj.canOmitFields = message.canOmitFields;
    }
    if (message.canDeleteFields !== undefined && message.canDeleteFields !== false) {
      obj.canDeleteFields = message.canDeleteFields;
    }
    if (message.allFieldsMatch !== undefined && message.allFieldsMatch !== true) {
      obj.allFieldsMatch = message.allFieldsMatch;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutArtifactTypeRequest>, I>>(
    base?: I,
  ): PutArtifactTypeRequest {
    return PutArtifactTypeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutArtifactTypeRequest>, I>>(
    object: I,
  ): PutArtifactTypeRequest {
    const message = createBasePutArtifactTypeRequest();
    message.artifactType =
      object.artifactType !== undefined && object.artifactType !== null
        ? ArtifactType.fromPartial(object.artifactType)
        : undefined;
    message.canAddFields = object.canAddFields ?? false;
    message.canOmitFields = object.canOmitFields ?? false;
    message.canDeleteFields = object.canDeleteFields ?? false;
    message.allFieldsMatch = object.allFieldsMatch ?? true;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBasePutArtifactTypeResponse(): PutArtifactTypeResponse {
  return { typeId: 0 };
}

export const PutArtifactTypeResponse = {
  encode(message: PutArtifactTypeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.typeId !== undefined && message.typeId !== 0) {
      writer.uint32(8).int64(message.typeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutArtifactTypeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutArtifactTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.typeId = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutArtifactTypeResponse {
    return { typeId: isSet(object.typeId) ? globalThis.Number(object.typeId) : 0 };
  },

  toJSON(message: PutArtifactTypeResponse): unknown {
    const obj: any = {};
    if (message.typeId !== undefined && message.typeId !== 0) {
      obj.typeId = Math.round(message.typeId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutArtifactTypeResponse>, I>>(
    base?: I,
  ): PutArtifactTypeResponse {
    return PutArtifactTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutArtifactTypeResponse>, I>>(
    object: I,
  ): PutArtifactTypeResponse {
    const message = createBasePutArtifactTypeResponse();
    message.typeId = object.typeId ?? 0;
    return message;
  },
};

function createBasePutExecutionsRequest(): PutExecutionsRequest {
  return { executions: [], transactionOptions: undefined, updateMask: undefined };
}

export const PutExecutionsRequest = {
  encode(message: PutExecutionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.executions) {
      Execution.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutExecutionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutExecutionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.executions.push(Execution.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutExecutionsRequest {
    return {
      executions: globalThis.Array.isArray(object?.executions)
        ? object.executions.map((e: any) => Execution.fromJSON(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
      updateMask: isSet(object.updateMask)
        ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask))
        : undefined,
    };
  },

  toJSON(message: PutExecutionsRequest): unknown {
    const obj: any = {};
    if (message.executions?.length) {
      obj.executions = message.executions.map((e) => Execution.toJSON(e));
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutExecutionsRequest>, I>>(base?: I): PutExecutionsRequest {
    return PutExecutionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutExecutionsRequest>, I>>(
    object: I,
  ): PutExecutionsRequest {
    const message = createBasePutExecutionsRequest();
    message.executions = object.executions?.map((e) => Execution.fromPartial(e)) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBasePutExecutionsResponse(): PutExecutionsResponse {
  return { executionIds: [] };
}

export const PutExecutionsResponse = {
  encode(message: PutExecutionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.executionIds) {
      writer.int64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutExecutionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutExecutionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.executionIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.executionIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutExecutionsResponse {
    return {
      executionIds: globalThis.Array.isArray(object?.executionIds)
        ? object.executionIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: PutExecutionsResponse): unknown {
    const obj: any = {};
    if (message.executionIds?.length) {
      obj.executionIds = message.executionIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutExecutionsResponse>, I>>(base?: I): PutExecutionsResponse {
    return PutExecutionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutExecutionsResponse>, I>>(
    object: I,
  ): PutExecutionsResponse {
    const message = createBasePutExecutionsResponse();
    message.executionIds = object.executionIds?.map((e) => e) || [];
    return message;
  },
};

function createBasePutExecutionTypeRequest(): PutExecutionTypeRequest {
  return {
    executionType: undefined,
    canAddFields: false,
    canOmitFields: false,
    canDeleteFields: false,
    allFieldsMatch: true,
    transactionOptions: undefined,
  };
}

export const PutExecutionTypeRequest = {
  encode(message: PutExecutionTypeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.executionType !== undefined) {
      ExecutionType.encode(message.executionType, writer.uint32(10).fork()).ldelim();
    }
    if (message.canAddFields !== undefined && message.canAddFields !== false) {
      writer.uint32(16).bool(message.canAddFields);
    }
    if (message.canOmitFields !== undefined && message.canOmitFields !== false) {
      writer.uint32(40).bool(message.canOmitFields);
    }
    if (message.canDeleteFields !== undefined && message.canDeleteFields !== false) {
      writer.uint32(24).bool(message.canDeleteFields);
    }
    if (message.allFieldsMatch !== undefined && message.allFieldsMatch !== true) {
      writer.uint32(32).bool(message.allFieldsMatch);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutExecutionTypeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutExecutionTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.executionType = ExecutionType.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.canAddFields = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.canOmitFields = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.canDeleteFields = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allFieldsMatch = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutExecutionTypeRequest {
    return {
      executionType: isSet(object.executionType)
        ? ExecutionType.fromJSON(object.executionType)
        : undefined,
      canAddFields: isSet(object.canAddFields) ? globalThis.Boolean(object.canAddFields) : false,
      canOmitFields: isSet(object.canOmitFields) ? globalThis.Boolean(object.canOmitFields) : false,
      canDeleteFields: isSet(object.canDeleteFields)
        ? globalThis.Boolean(object.canDeleteFields)
        : false,
      allFieldsMatch: isSet(object.allFieldsMatch)
        ? globalThis.Boolean(object.allFieldsMatch)
        : true,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: PutExecutionTypeRequest): unknown {
    const obj: any = {};
    if (message.executionType !== undefined) {
      obj.executionType = ExecutionType.toJSON(message.executionType);
    }
    if (message.canAddFields !== undefined && message.canAddFields !== false) {
      obj.canAddFields = message.canAddFields;
    }
    if (message.canOmitFields !== undefined && message.canOmitFields !== false) {
      obj.canOmitFields = message.canOmitFields;
    }
    if (message.canDeleteFields !== undefined && message.canDeleteFields !== false) {
      obj.canDeleteFields = message.canDeleteFields;
    }
    if (message.allFieldsMatch !== undefined && message.allFieldsMatch !== true) {
      obj.allFieldsMatch = message.allFieldsMatch;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutExecutionTypeRequest>, I>>(
    base?: I,
  ): PutExecutionTypeRequest {
    return PutExecutionTypeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutExecutionTypeRequest>, I>>(
    object: I,
  ): PutExecutionTypeRequest {
    const message = createBasePutExecutionTypeRequest();
    message.executionType =
      object.executionType !== undefined && object.executionType !== null
        ? ExecutionType.fromPartial(object.executionType)
        : undefined;
    message.canAddFields = object.canAddFields ?? false;
    message.canOmitFields = object.canOmitFields ?? false;
    message.canDeleteFields = object.canDeleteFields ?? false;
    message.allFieldsMatch = object.allFieldsMatch ?? true;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBasePutExecutionTypeResponse(): PutExecutionTypeResponse {
  return { typeId: 0 };
}

export const PutExecutionTypeResponse = {
  encode(message: PutExecutionTypeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.typeId !== undefined && message.typeId !== 0) {
      writer.uint32(8).int64(message.typeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutExecutionTypeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutExecutionTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.typeId = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutExecutionTypeResponse {
    return { typeId: isSet(object.typeId) ? globalThis.Number(object.typeId) : 0 };
  },

  toJSON(message: PutExecutionTypeResponse): unknown {
    const obj: any = {};
    if (message.typeId !== undefined && message.typeId !== 0) {
      obj.typeId = Math.round(message.typeId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutExecutionTypeResponse>, I>>(
    base?: I,
  ): PutExecutionTypeResponse {
    return PutExecutionTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutExecutionTypeResponse>, I>>(
    object: I,
  ): PutExecutionTypeResponse {
    const message = createBasePutExecutionTypeResponse();
    message.typeId = object.typeId ?? 0;
    return message;
  },
};

function createBasePutEventsRequest(): PutEventsRequest {
  return { events: [], transactionOptions: undefined };
}

export const PutEventsRequest = {
  encode(message: PutEventsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.events) {
      Event.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutEventsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.events.push(Event.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutEventsRequest {
    return {
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => Event.fromJSON(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: PutEventsRequest): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event.toJSON(e));
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutEventsRequest>, I>>(base?: I): PutEventsRequest {
    return PutEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutEventsRequest>, I>>(object: I): PutEventsRequest {
    const message = createBasePutEventsRequest();
    message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBasePutEventsResponse(): PutEventsResponse {
  return {};
}

export const PutEventsResponse = {
  encode(_: PutEventsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutEventsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PutEventsResponse {
    return {};
  },

  toJSON(_: PutEventsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PutEventsResponse>, I>>(base?: I): PutEventsResponse {
    return PutEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutEventsResponse>, I>>(_: I): PutEventsResponse {
    const message = createBasePutEventsResponse();
    return message;
  },
};

function createBasePutExecutionRequest(): PutExecutionRequest {
  return {
    execution: undefined,
    artifactEventPairs: [],
    contexts: [],
    options: undefined,
    transactionOptions: undefined,
  };
}

export const PutExecutionRequest = {
  encode(message: PutExecutionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.execution !== undefined) {
      Execution.encode(message.execution, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.artifactEventPairs) {
      PutExecutionRequest_ArtifactAndEvent.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.contexts) {
      Context.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.options !== undefined) {
      PutExecutionRequest_Options.encode(message.options, writer.uint32(34).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutExecutionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutExecutionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.execution = Execution.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.artifactEventPairs.push(
            PutExecutionRequest_ArtifactAndEvent.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contexts.push(Context.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.options = PutExecutionRequest_Options.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutExecutionRequest {
    return {
      execution: isSet(object.execution) ? Execution.fromJSON(object.execution) : undefined,
      artifactEventPairs: globalThis.Array.isArray(object?.artifactEventPairs)
        ? object.artifactEventPairs.map((e: any) =>
            PutExecutionRequest_ArtifactAndEvent.fromJSON(e),
          )
        : [],
      contexts: globalThis.Array.isArray(object?.contexts)
        ? object.contexts.map((e: any) => Context.fromJSON(e))
        : [],
      options: isSet(object.options)
        ? PutExecutionRequest_Options.fromJSON(object.options)
        : undefined,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: PutExecutionRequest): unknown {
    const obj: any = {};
    if (message.execution !== undefined) {
      obj.execution = Execution.toJSON(message.execution);
    }
    if (message.artifactEventPairs?.length) {
      obj.artifactEventPairs = message.artifactEventPairs.map((e) =>
        PutExecutionRequest_ArtifactAndEvent.toJSON(e),
      );
    }
    if (message.contexts?.length) {
      obj.contexts = message.contexts.map((e) => Context.toJSON(e));
    }
    if (message.options !== undefined) {
      obj.options = PutExecutionRequest_Options.toJSON(message.options);
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutExecutionRequest>, I>>(base?: I): PutExecutionRequest {
    return PutExecutionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutExecutionRequest>, I>>(
    object: I,
  ): PutExecutionRequest {
    const message = createBasePutExecutionRequest();
    message.execution =
      object.execution !== undefined && object.execution !== null
        ? Execution.fromPartial(object.execution)
        : undefined;
    message.artifactEventPairs =
      object.artifactEventPairs?.map((e) => PutExecutionRequest_ArtifactAndEvent.fromPartial(e)) ||
      [];
    message.contexts = object.contexts?.map((e) => Context.fromPartial(e)) || [];
    message.options =
      object.options !== undefined && object.options !== null
        ? PutExecutionRequest_Options.fromPartial(object.options)
        : undefined;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBasePutExecutionRequest_ArtifactAndEvent(): PutExecutionRequest_ArtifactAndEvent {
  return { artifact: undefined, event: undefined };
}

export const PutExecutionRequest_ArtifactAndEvent = {
  encode(
    message: PutExecutionRequest_ArtifactAndEvent,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.artifact !== undefined) {
      Artifact.encode(message.artifact, writer.uint32(10).fork()).ldelim();
    }
    if (message.event !== undefined) {
      Event.encode(message.event, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutExecutionRequest_ArtifactAndEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutExecutionRequest_ArtifactAndEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifact = Artifact.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.event = Event.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutExecutionRequest_ArtifactAndEvent {
    return {
      artifact: isSet(object.artifact) ? Artifact.fromJSON(object.artifact) : undefined,
      event: isSet(object.event) ? Event.fromJSON(object.event) : undefined,
    };
  },

  toJSON(message: PutExecutionRequest_ArtifactAndEvent): unknown {
    const obj: any = {};
    if (message.artifact !== undefined) {
      obj.artifact = Artifact.toJSON(message.artifact);
    }
    if (message.event !== undefined) {
      obj.event = Event.toJSON(message.event);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutExecutionRequest_ArtifactAndEvent>, I>>(
    base?: I,
  ): PutExecutionRequest_ArtifactAndEvent {
    return PutExecutionRequest_ArtifactAndEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutExecutionRequest_ArtifactAndEvent>, I>>(
    object: I,
  ): PutExecutionRequest_ArtifactAndEvent {
    const message = createBasePutExecutionRequest_ArtifactAndEvent();
    message.artifact =
      object.artifact !== undefined && object.artifact !== null
        ? Artifact.fromPartial(object.artifact)
        : undefined;
    message.event =
      object.event !== undefined && object.event !== null
        ? Event.fromPartial(object.event)
        : undefined;
    return message;
  },
};

function createBasePutExecutionRequest_Options(): PutExecutionRequest_Options {
  return { reuseContextIfAlreadyExist: false, reuseArtifactIfAlreadyExistByExternalId: false };
}

export const PutExecutionRequest_Options = {
  encode(
    message: PutExecutionRequest_Options,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (
      message.reuseContextIfAlreadyExist !== undefined &&
      message.reuseContextIfAlreadyExist !== false
    ) {
      writer.uint32(8).bool(message.reuseContextIfAlreadyExist);
    }
    if (
      message.reuseArtifactIfAlreadyExistByExternalId !== undefined &&
      message.reuseArtifactIfAlreadyExistByExternalId !== false
    ) {
      writer.uint32(16).bool(message.reuseArtifactIfAlreadyExistByExternalId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutExecutionRequest_Options {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutExecutionRequest_Options();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reuseContextIfAlreadyExist = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reuseArtifactIfAlreadyExistByExternalId = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutExecutionRequest_Options {
    return {
      reuseContextIfAlreadyExist: isSet(object.reuseContextIfAlreadyExist)
        ? globalThis.Boolean(object.reuseContextIfAlreadyExist)
        : false,
      reuseArtifactIfAlreadyExistByExternalId: isSet(object.reuseArtifactIfAlreadyExistByExternalId)
        ? globalThis.Boolean(object.reuseArtifactIfAlreadyExistByExternalId)
        : false,
    };
  },

  toJSON(message: PutExecutionRequest_Options): unknown {
    const obj: any = {};
    if (
      message.reuseContextIfAlreadyExist !== undefined &&
      message.reuseContextIfAlreadyExist !== false
    ) {
      obj.reuseContextIfAlreadyExist = message.reuseContextIfAlreadyExist;
    }
    if (
      message.reuseArtifactIfAlreadyExistByExternalId !== undefined &&
      message.reuseArtifactIfAlreadyExistByExternalId !== false
    ) {
      obj.reuseArtifactIfAlreadyExistByExternalId = message.reuseArtifactIfAlreadyExistByExternalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutExecutionRequest_Options>, I>>(
    base?: I,
  ): PutExecutionRequest_Options {
    return PutExecutionRequest_Options.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutExecutionRequest_Options>, I>>(
    object: I,
  ): PutExecutionRequest_Options {
    const message = createBasePutExecutionRequest_Options();
    message.reuseContextIfAlreadyExist = object.reuseContextIfAlreadyExist ?? false;
    message.reuseArtifactIfAlreadyExistByExternalId =
      object.reuseArtifactIfAlreadyExistByExternalId ?? false;
    return message;
  },
};

function createBasePutExecutionResponse(): PutExecutionResponse {
  return { executionId: 0, artifactIds: [], contextIds: [] };
}

export const PutExecutionResponse = {
  encode(message: PutExecutionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.executionId !== undefined && message.executionId !== 0) {
      writer.uint32(8).int64(message.executionId);
    }
    writer.uint32(18).fork();
    for (const v of message.artifactIds) {
      writer.int64(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.contextIds) {
      writer.int64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutExecutionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutExecutionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.executionId = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag === 16) {
            message.artifactIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.artifactIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag === 24) {
            message.contextIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.contextIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutExecutionResponse {
    return {
      executionId: isSet(object.executionId) ? globalThis.Number(object.executionId) : 0,
      artifactIds: globalThis.Array.isArray(object?.artifactIds)
        ? object.artifactIds.map((e: any) => globalThis.Number(e))
        : [],
      contextIds: globalThis.Array.isArray(object?.contextIds)
        ? object.contextIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: PutExecutionResponse): unknown {
    const obj: any = {};
    if (message.executionId !== undefined && message.executionId !== 0) {
      obj.executionId = Math.round(message.executionId);
    }
    if (message.artifactIds?.length) {
      obj.artifactIds = message.artifactIds.map((e) => Math.round(e));
    }
    if (message.contextIds?.length) {
      obj.contextIds = message.contextIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutExecutionResponse>, I>>(base?: I): PutExecutionResponse {
    return PutExecutionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutExecutionResponse>, I>>(
    object: I,
  ): PutExecutionResponse {
    const message = createBasePutExecutionResponse();
    message.executionId = object.executionId ?? 0;
    message.artifactIds = object.artifactIds?.map((e) => e) || [];
    message.contextIds = object.contextIds?.map((e) => e) || [];
    return message;
  },
};

function createBasePutLineageSubgraphRequest(): PutLineageSubgraphRequest {
  return {
    executions: [],
    artifacts: [],
    contexts: [],
    eventEdges: [],
    options: undefined,
    transactionOptions: undefined,
  };
}

export const PutLineageSubgraphRequest = {
  encode(message: PutLineageSubgraphRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.executions) {
      Execution.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.artifacts) {
      Artifact.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.contexts) {
      Context.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.eventEdges) {
      PutLineageSubgraphRequest_EventEdge.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.options !== undefined) {
      PutLineageSubgraphRequest_Options.encode(message.options, writer.uint32(42).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutLineageSubgraphRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutLineageSubgraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.executions.push(Execution.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.artifacts.push(Artifact.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contexts.push(Context.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.eventEdges.push(
            PutLineageSubgraphRequest_EventEdge.decode(reader, reader.uint32()),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.options = PutLineageSubgraphRequest_Options.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutLineageSubgraphRequest {
    return {
      executions: globalThis.Array.isArray(object?.executions)
        ? object.executions.map((e: any) => Execution.fromJSON(e))
        : [],
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => Artifact.fromJSON(e))
        : [],
      contexts: globalThis.Array.isArray(object?.contexts)
        ? object.contexts.map((e: any) => Context.fromJSON(e))
        : [],
      eventEdges: globalThis.Array.isArray(object?.eventEdges)
        ? object.eventEdges.map((e: any) => PutLineageSubgraphRequest_EventEdge.fromJSON(e))
        : [],
      options: isSet(object.options)
        ? PutLineageSubgraphRequest_Options.fromJSON(object.options)
        : undefined,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: PutLineageSubgraphRequest): unknown {
    const obj: any = {};
    if (message.executions?.length) {
      obj.executions = message.executions.map((e) => Execution.toJSON(e));
    }
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => Artifact.toJSON(e));
    }
    if (message.contexts?.length) {
      obj.contexts = message.contexts.map((e) => Context.toJSON(e));
    }
    if (message.eventEdges?.length) {
      obj.eventEdges = message.eventEdges.map((e) => PutLineageSubgraphRequest_EventEdge.toJSON(e));
    }
    if (message.options !== undefined) {
      obj.options = PutLineageSubgraphRequest_Options.toJSON(message.options);
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutLineageSubgraphRequest>, I>>(
    base?: I,
  ): PutLineageSubgraphRequest {
    return PutLineageSubgraphRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutLineageSubgraphRequest>, I>>(
    object: I,
  ): PutLineageSubgraphRequest {
    const message = createBasePutLineageSubgraphRequest();
    message.executions = object.executions?.map((e) => Execution.fromPartial(e)) || [];
    message.artifacts = object.artifacts?.map((e) => Artifact.fromPartial(e)) || [];
    message.contexts = object.contexts?.map((e) => Context.fromPartial(e)) || [];
    message.eventEdges =
      object.eventEdges?.map((e) => PutLineageSubgraphRequest_EventEdge.fromPartial(e)) || [];
    message.options =
      object.options !== undefined && object.options !== null
        ? PutLineageSubgraphRequest_Options.fromPartial(object.options)
        : undefined;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBasePutLineageSubgraphRequest_EventEdge(): PutLineageSubgraphRequest_EventEdge {
  return { executionIndex: 0, artifactIndex: 0, event: undefined };
}

export const PutLineageSubgraphRequest_EventEdge = {
  encode(
    message: PutLineageSubgraphRequest_EventEdge,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.executionIndex !== undefined && message.executionIndex !== 0) {
      writer.uint32(8).int32(message.executionIndex);
    }
    if (message.artifactIndex !== undefined && message.artifactIndex !== 0) {
      writer.uint32(16).int32(message.artifactIndex);
    }
    if (message.event !== undefined) {
      Event.encode(message.event, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutLineageSubgraphRequest_EventEdge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutLineageSubgraphRequest_EventEdge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.executionIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.artifactIndex = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.event = Event.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutLineageSubgraphRequest_EventEdge {
    return {
      executionIndex: isSet(object.executionIndex) ? globalThis.Number(object.executionIndex) : 0,
      artifactIndex: isSet(object.artifactIndex) ? globalThis.Number(object.artifactIndex) : 0,
      event: isSet(object.event) ? Event.fromJSON(object.event) : undefined,
    };
  },

  toJSON(message: PutLineageSubgraphRequest_EventEdge): unknown {
    const obj: any = {};
    if (message.executionIndex !== undefined && message.executionIndex !== 0) {
      obj.executionIndex = Math.round(message.executionIndex);
    }
    if (message.artifactIndex !== undefined && message.artifactIndex !== 0) {
      obj.artifactIndex = Math.round(message.artifactIndex);
    }
    if (message.event !== undefined) {
      obj.event = Event.toJSON(message.event);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutLineageSubgraphRequest_EventEdge>, I>>(
    base?: I,
  ): PutLineageSubgraphRequest_EventEdge {
    return PutLineageSubgraphRequest_EventEdge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutLineageSubgraphRequest_EventEdge>, I>>(
    object: I,
  ): PutLineageSubgraphRequest_EventEdge {
    const message = createBasePutLineageSubgraphRequest_EventEdge();
    message.executionIndex = object.executionIndex ?? 0;
    message.artifactIndex = object.artifactIndex ?? 0;
    message.event =
      object.event !== undefined && object.event !== null
        ? Event.fromPartial(object.event)
        : undefined;
    return message;
  },
};

function createBasePutLineageSubgraphRequest_Options(): PutLineageSubgraphRequest_Options {
  return { reuseContextIfAlreadyExist: false, reuseArtifactIfAlreadyExistByExternalId: false };
}

export const PutLineageSubgraphRequest_Options = {
  encode(
    message: PutLineageSubgraphRequest_Options,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (
      message.reuseContextIfAlreadyExist !== undefined &&
      message.reuseContextIfAlreadyExist !== false
    ) {
      writer.uint32(8).bool(message.reuseContextIfAlreadyExist);
    }
    if (
      message.reuseArtifactIfAlreadyExistByExternalId !== undefined &&
      message.reuseArtifactIfAlreadyExistByExternalId !== false
    ) {
      writer.uint32(16).bool(message.reuseArtifactIfAlreadyExistByExternalId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutLineageSubgraphRequest_Options {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutLineageSubgraphRequest_Options();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reuseContextIfAlreadyExist = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reuseArtifactIfAlreadyExistByExternalId = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutLineageSubgraphRequest_Options {
    return {
      reuseContextIfAlreadyExist: isSet(object.reuseContextIfAlreadyExist)
        ? globalThis.Boolean(object.reuseContextIfAlreadyExist)
        : false,
      reuseArtifactIfAlreadyExistByExternalId: isSet(object.reuseArtifactIfAlreadyExistByExternalId)
        ? globalThis.Boolean(object.reuseArtifactIfAlreadyExistByExternalId)
        : false,
    };
  },

  toJSON(message: PutLineageSubgraphRequest_Options): unknown {
    const obj: any = {};
    if (
      message.reuseContextIfAlreadyExist !== undefined &&
      message.reuseContextIfAlreadyExist !== false
    ) {
      obj.reuseContextIfAlreadyExist = message.reuseContextIfAlreadyExist;
    }
    if (
      message.reuseArtifactIfAlreadyExistByExternalId !== undefined &&
      message.reuseArtifactIfAlreadyExistByExternalId !== false
    ) {
      obj.reuseArtifactIfAlreadyExistByExternalId = message.reuseArtifactIfAlreadyExistByExternalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutLineageSubgraphRequest_Options>, I>>(
    base?: I,
  ): PutLineageSubgraphRequest_Options {
    return PutLineageSubgraphRequest_Options.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutLineageSubgraphRequest_Options>, I>>(
    object: I,
  ): PutLineageSubgraphRequest_Options {
    const message = createBasePutLineageSubgraphRequest_Options();
    message.reuseContextIfAlreadyExist = object.reuseContextIfAlreadyExist ?? false;
    message.reuseArtifactIfAlreadyExistByExternalId =
      object.reuseArtifactIfAlreadyExistByExternalId ?? false;
    return message;
  },
};

function createBasePutLineageSubgraphResponse(): PutLineageSubgraphResponse {
  return { executionIds: [], artifactIds: [], contextIds: [] };
}

export const PutLineageSubgraphResponse = {
  encode(
    message: PutLineageSubgraphResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.executionIds) {
      writer.int64(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.artifactIds) {
      writer.int64(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.contextIds) {
      writer.int64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutLineageSubgraphResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutLineageSubgraphResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.executionIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.executionIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.artifactIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.artifactIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag === 24) {
            message.contextIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.contextIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutLineageSubgraphResponse {
    return {
      executionIds: globalThis.Array.isArray(object?.executionIds)
        ? object.executionIds.map((e: any) => globalThis.Number(e))
        : [],
      artifactIds: globalThis.Array.isArray(object?.artifactIds)
        ? object.artifactIds.map((e: any) => globalThis.Number(e))
        : [],
      contextIds: globalThis.Array.isArray(object?.contextIds)
        ? object.contextIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: PutLineageSubgraphResponse): unknown {
    const obj: any = {};
    if (message.executionIds?.length) {
      obj.executionIds = message.executionIds.map((e) => Math.round(e));
    }
    if (message.artifactIds?.length) {
      obj.artifactIds = message.artifactIds.map((e) => Math.round(e));
    }
    if (message.contextIds?.length) {
      obj.contextIds = message.contextIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutLineageSubgraphResponse>, I>>(
    base?: I,
  ): PutLineageSubgraphResponse {
    return PutLineageSubgraphResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutLineageSubgraphResponse>, I>>(
    object: I,
  ): PutLineageSubgraphResponse {
    const message = createBasePutLineageSubgraphResponse();
    message.executionIds = object.executionIds?.map((e) => e) || [];
    message.artifactIds = object.artifactIds?.map((e) => e) || [];
    message.contextIds = object.contextIds?.map((e) => e) || [];
    return message;
  },
};

function createBasePutTypesRequest(): PutTypesRequest {
  return {
    artifactTypes: [],
    executionTypes: [],
    contextTypes: [],
    canAddFields: false,
    canOmitFields: false,
    canDeleteFields: false,
    allFieldsMatch: true,
    transactionOptions: undefined,
  };
}

export const PutTypesRequest = {
  encode(message: PutTypesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.artifactTypes) {
      ArtifactType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.executionTypes) {
      ExecutionType.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.contextTypes) {
      ContextType.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.canAddFields !== undefined && message.canAddFields !== false) {
      writer.uint32(32).bool(message.canAddFields);
    }
    if (message.canOmitFields !== undefined && message.canOmitFields !== false) {
      writer.uint32(56).bool(message.canOmitFields);
    }
    if (message.canDeleteFields !== undefined && message.canDeleteFields !== false) {
      writer.uint32(40).bool(message.canDeleteFields);
    }
    if (message.allFieldsMatch !== undefined && message.allFieldsMatch !== true) {
      writer.uint32(48).bool(message.allFieldsMatch);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutTypesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactTypes.push(ArtifactType.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.executionTypes.push(ExecutionType.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contextTypes.push(ContextType.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.canAddFields = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.canOmitFields = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.canDeleteFields = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.allFieldsMatch = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutTypesRequest {
    return {
      artifactTypes: globalThis.Array.isArray(object?.artifactTypes)
        ? object.artifactTypes.map((e: any) => ArtifactType.fromJSON(e))
        : [],
      executionTypes: globalThis.Array.isArray(object?.executionTypes)
        ? object.executionTypes.map((e: any) => ExecutionType.fromJSON(e))
        : [],
      contextTypes: globalThis.Array.isArray(object?.contextTypes)
        ? object.contextTypes.map((e: any) => ContextType.fromJSON(e))
        : [],
      canAddFields: isSet(object.canAddFields) ? globalThis.Boolean(object.canAddFields) : false,
      canOmitFields: isSet(object.canOmitFields) ? globalThis.Boolean(object.canOmitFields) : false,
      canDeleteFields: isSet(object.canDeleteFields)
        ? globalThis.Boolean(object.canDeleteFields)
        : false,
      allFieldsMatch: isSet(object.allFieldsMatch)
        ? globalThis.Boolean(object.allFieldsMatch)
        : true,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: PutTypesRequest): unknown {
    const obj: any = {};
    if (message.artifactTypes?.length) {
      obj.artifactTypes = message.artifactTypes.map((e) => ArtifactType.toJSON(e));
    }
    if (message.executionTypes?.length) {
      obj.executionTypes = message.executionTypes.map((e) => ExecutionType.toJSON(e));
    }
    if (message.contextTypes?.length) {
      obj.contextTypes = message.contextTypes.map((e) => ContextType.toJSON(e));
    }
    if (message.canAddFields !== undefined && message.canAddFields !== false) {
      obj.canAddFields = message.canAddFields;
    }
    if (message.canOmitFields !== undefined && message.canOmitFields !== false) {
      obj.canOmitFields = message.canOmitFields;
    }
    if (message.canDeleteFields !== undefined && message.canDeleteFields !== false) {
      obj.canDeleteFields = message.canDeleteFields;
    }
    if (message.allFieldsMatch !== undefined && message.allFieldsMatch !== true) {
      obj.allFieldsMatch = message.allFieldsMatch;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutTypesRequest>, I>>(base?: I): PutTypesRequest {
    return PutTypesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutTypesRequest>, I>>(object: I): PutTypesRequest {
    const message = createBasePutTypesRequest();
    message.artifactTypes = object.artifactTypes?.map((e) => ArtifactType.fromPartial(e)) || [];
    message.executionTypes = object.executionTypes?.map((e) => ExecutionType.fromPartial(e)) || [];
    message.contextTypes = object.contextTypes?.map((e) => ContextType.fromPartial(e)) || [];
    message.canAddFields = object.canAddFields ?? false;
    message.canOmitFields = object.canOmitFields ?? false;
    message.canDeleteFields = object.canDeleteFields ?? false;
    message.allFieldsMatch = object.allFieldsMatch ?? true;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBasePutTypesResponse(): PutTypesResponse {
  return { artifactTypeIds: [], executionTypeIds: [], contextTypeIds: [] };
}

export const PutTypesResponse = {
  encode(message: PutTypesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.artifactTypeIds) {
      writer.int64(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.executionTypeIds) {
      writer.int64(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.contextTypeIds) {
      writer.int64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutTypesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.artifactTypeIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.artifactTypeIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.executionTypeIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.executionTypeIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag === 24) {
            message.contextTypeIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.contextTypeIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutTypesResponse {
    return {
      artifactTypeIds: globalThis.Array.isArray(object?.artifactTypeIds)
        ? object.artifactTypeIds.map((e: any) => globalThis.Number(e))
        : [],
      executionTypeIds: globalThis.Array.isArray(object?.executionTypeIds)
        ? object.executionTypeIds.map((e: any) => globalThis.Number(e))
        : [],
      contextTypeIds: globalThis.Array.isArray(object?.contextTypeIds)
        ? object.contextTypeIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: PutTypesResponse): unknown {
    const obj: any = {};
    if (message.artifactTypeIds?.length) {
      obj.artifactTypeIds = message.artifactTypeIds.map((e) => Math.round(e));
    }
    if (message.executionTypeIds?.length) {
      obj.executionTypeIds = message.executionTypeIds.map((e) => Math.round(e));
    }
    if (message.contextTypeIds?.length) {
      obj.contextTypeIds = message.contextTypeIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutTypesResponse>, I>>(base?: I): PutTypesResponse {
    return PutTypesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutTypesResponse>, I>>(object: I): PutTypesResponse {
    const message = createBasePutTypesResponse();
    message.artifactTypeIds = object.artifactTypeIds?.map((e) => e) || [];
    message.executionTypeIds = object.executionTypeIds?.map((e) => e) || [];
    message.contextTypeIds = object.contextTypeIds?.map((e) => e) || [];
    return message;
  },
};

function createBasePutContextTypeRequest(): PutContextTypeRequest {
  return {
    contextType: undefined,
    canAddFields: false,
    canOmitFields: false,
    canDeleteFields: false,
    allFieldsMatch: true,
    transactionOptions: undefined,
  };
}

export const PutContextTypeRequest = {
  encode(message: PutContextTypeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contextType !== undefined) {
      ContextType.encode(message.contextType, writer.uint32(10).fork()).ldelim();
    }
    if (message.canAddFields !== undefined && message.canAddFields !== false) {
      writer.uint32(16).bool(message.canAddFields);
    }
    if (message.canOmitFields !== undefined && message.canOmitFields !== false) {
      writer.uint32(40).bool(message.canOmitFields);
    }
    if (message.canDeleteFields !== undefined && message.canDeleteFields !== false) {
      writer.uint32(24).bool(message.canDeleteFields);
    }
    if (message.allFieldsMatch !== undefined && message.allFieldsMatch !== true) {
      writer.uint32(32).bool(message.allFieldsMatch);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutContextTypeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutContextTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contextType = ContextType.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.canAddFields = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.canOmitFields = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.canDeleteFields = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allFieldsMatch = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutContextTypeRequest {
    return {
      contextType: isSet(object.contextType) ? ContextType.fromJSON(object.contextType) : undefined,
      canAddFields: isSet(object.canAddFields) ? globalThis.Boolean(object.canAddFields) : false,
      canOmitFields: isSet(object.canOmitFields) ? globalThis.Boolean(object.canOmitFields) : false,
      canDeleteFields: isSet(object.canDeleteFields)
        ? globalThis.Boolean(object.canDeleteFields)
        : false,
      allFieldsMatch: isSet(object.allFieldsMatch)
        ? globalThis.Boolean(object.allFieldsMatch)
        : true,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: PutContextTypeRequest): unknown {
    const obj: any = {};
    if (message.contextType !== undefined) {
      obj.contextType = ContextType.toJSON(message.contextType);
    }
    if (message.canAddFields !== undefined && message.canAddFields !== false) {
      obj.canAddFields = message.canAddFields;
    }
    if (message.canOmitFields !== undefined && message.canOmitFields !== false) {
      obj.canOmitFields = message.canOmitFields;
    }
    if (message.canDeleteFields !== undefined && message.canDeleteFields !== false) {
      obj.canDeleteFields = message.canDeleteFields;
    }
    if (message.allFieldsMatch !== undefined && message.allFieldsMatch !== true) {
      obj.allFieldsMatch = message.allFieldsMatch;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutContextTypeRequest>, I>>(base?: I): PutContextTypeRequest {
    return PutContextTypeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutContextTypeRequest>, I>>(
    object: I,
  ): PutContextTypeRequest {
    const message = createBasePutContextTypeRequest();
    message.contextType =
      object.contextType !== undefined && object.contextType !== null
        ? ContextType.fromPartial(object.contextType)
        : undefined;
    message.canAddFields = object.canAddFields ?? false;
    message.canOmitFields = object.canOmitFields ?? false;
    message.canDeleteFields = object.canDeleteFields ?? false;
    message.allFieldsMatch = object.allFieldsMatch ?? true;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBasePutContextTypeResponse(): PutContextTypeResponse {
  return { typeId: 0 };
}

export const PutContextTypeResponse = {
  encode(message: PutContextTypeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.typeId !== undefined && message.typeId !== 0) {
      writer.uint32(8).int64(message.typeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutContextTypeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutContextTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.typeId = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutContextTypeResponse {
    return { typeId: isSet(object.typeId) ? globalThis.Number(object.typeId) : 0 };
  },

  toJSON(message: PutContextTypeResponse): unknown {
    const obj: any = {};
    if (message.typeId !== undefined && message.typeId !== 0) {
      obj.typeId = Math.round(message.typeId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutContextTypeResponse>, I>>(
    base?: I,
  ): PutContextTypeResponse {
    return PutContextTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutContextTypeResponse>, I>>(
    object: I,
  ): PutContextTypeResponse {
    const message = createBasePutContextTypeResponse();
    message.typeId = object.typeId ?? 0;
    return message;
  },
};

function createBasePutContextsRequest(): PutContextsRequest {
  return { contexts: [], transactionOptions: undefined, updateMask: undefined };
}

export const PutContextsRequest = {
  encode(message: PutContextsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.contexts) {
      Context.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutContextsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutContextsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contexts.push(Context.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutContextsRequest {
    return {
      contexts: globalThis.Array.isArray(object?.contexts)
        ? object.contexts.map((e: any) => Context.fromJSON(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
      updateMask: isSet(object.updateMask)
        ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask))
        : undefined,
    };
  },

  toJSON(message: PutContextsRequest): unknown {
    const obj: any = {};
    if (message.contexts?.length) {
      obj.contexts = message.contexts.map((e) => Context.toJSON(e));
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutContextsRequest>, I>>(base?: I): PutContextsRequest {
    return PutContextsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutContextsRequest>, I>>(object: I): PutContextsRequest {
    const message = createBasePutContextsRequest();
    message.contexts = object.contexts?.map((e) => Context.fromPartial(e)) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBasePutContextsResponse(): PutContextsResponse {
  return { contextIds: [] };
}

export const PutContextsResponse = {
  encode(message: PutContextsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.contextIds) {
      writer.int64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutContextsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutContextsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.contextIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.contextIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutContextsResponse {
    return {
      contextIds: globalThis.Array.isArray(object?.contextIds)
        ? object.contextIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: PutContextsResponse): unknown {
    const obj: any = {};
    if (message.contextIds?.length) {
      obj.contextIds = message.contextIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutContextsResponse>, I>>(base?: I): PutContextsResponse {
    return PutContextsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutContextsResponse>, I>>(
    object: I,
  ): PutContextsResponse {
    const message = createBasePutContextsResponse();
    message.contextIds = object.contextIds?.map((e) => e) || [];
    return message;
  },
};

function createBasePutAttributionsAndAssociationsRequest(): PutAttributionsAndAssociationsRequest {
  return { attributions: [], associations: [], transactionOptions: undefined };
}

export const PutAttributionsAndAssociationsRequest = {
  encode(
    message: PutAttributionsAndAssociationsRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.attributions) {
      Attribution.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.associations) {
      Association.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutAttributionsAndAssociationsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutAttributionsAndAssociationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributions.push(Attribution.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.associations.push(Association.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutAttributionsAndAssociationsRequest {
    return {
      attributions: globalThis.Array.isArray(object?.attributions)
        ? object.attributions.map((e: any) => Attribution.fromJSON(e))
        : [],
      associations: globalThis.Array.isArray(object?.associations)
        ? object.associations.map((e: any) => Association.fromJSON(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: PutAttributionsAndAssociationsRequest): unknown {
    const obj: any = {};
    if (message.attributions?.length) {
      obj.attributions = message.attributions.map((e) => Attribution.toJSON(e));
    }
    if (message.associations?.length) {
      obj.associations = message.associations.map((e) => Association.toJSON(e));
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutAttributionsAndAssociationsRequest>, I>>(
    base?: I,
  ): PutAttributionsAndAssociationsRequest {
    return PutAttributionsAndAssociationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutAttributionsAndAssociationsRequest>, I>>(
    object: I,
  ): PutAttributionsAndAssociationsRequest {
    const message = createBasePutAttributionsAndAssociationsRequest();
    message.attributions = object.attributions?.map((e) => Attribution.fromPartial(e)) || [];
    message.associations = object.associations?.map((e) => Association.fromPartial(e)) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBasePutAttributionsAndAssociationsResponse(): PutAttributionsAndAssociationsResponse {
  return {};
}

export const PutAttributionsAndAssociationsResponse = {
  encode(
    _: PutAttributionsAndAssociationsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutAttributionsAndAssociationsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutAttributionsAndAssociationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PutAttributionsAndAssociationsResponse {
    return {};
  },

  toJSON(_: PutAttributionsAndAssociationsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PutAttributionsAndAssociationsResponse>, I>>(
    base?: I,
  ): PutAttributionsAndAssociationsResponse {
    return PutAttributionsAndAssociationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutAttributionsAndAssociationsResponse>, I>>(
    _: I,
  ): PutAttributionsAndAssociationsResponse {
    const message = createBasePutAttributionsAndAssociationsResponse();
    return message;
  },
};

function createBasePutParentContextsRequest(): PutParentContextsRequest {
  return { parentContexts: [], transactionOptions: undefined };
}

export const PutParentContextsRequest = {
  encode(message: PutParentContextsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.parentContexts) {
      ParentContext.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutParentContextsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutParentContextsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parentContexts.push(ParentContext.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutParentContextsRequest {
    return {
      parentContexts: globalThis.Array.isArray(object?.parentContexts)
        ? object.parentContexts.map((e: any) => ParentContext.fromJSON(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: PutParentContextsRequest): unknown {
    const obj: any = {};
    if (message.parentContexts?.length) {
      obj.parentContexts = message.parentContexts.map((e) => ParentContext.toJSON(e));
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutParentContextsRequest>, I>>(
    base?: I,
  ): PutParentContextsRequest {
    return PutParentContextsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutParentContextsRequest>, I>>(
    object: I,
  ): PutParentContextsRequest {
    const message = createBasePutParentContextsRequest();
    message.parentContexts = object.parentContexts?.map((e) => ParentContext.fromPartial(e)) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBasePutParentContextsResponse(): PutParentContextsResponse {
  return {};
}

export const PutParentContextsResponse = {
  encode(_: PutParentContextsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutParentContextsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutParentContextsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PutParentContextsResponse {
    return {};
  },

  toJSON(_: PutParentContextsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PutParentContextsResponse>, I>>(
    base?: I,
  ): PutParentContextsResponse {
    return PutParentContextsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutParentContextsResponse>, I>>(
    _: I,
  ): PutParentContextsResponse {
    const message = createBasePutParentContextsResponse();
    return message;
  },
};

function createBaseGetArtifactsByTypeRequest(): GetArtifactsByTypeRequest {
  return { typeName: '', typeVersion: '', options: undefined, transactionOptions: undefined };
}

export const GetArtifactsByTypeRequest = {
  encode(message: GetArtifactsByTypeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.typeName !== undefined && message.typeName !== '') {
      writer.uint32(10).string(message.typeName);
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      writer.uint32(18).string(message.typeVersion);
    }
    if (message.options !== undefined) {
      ListOperationOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactsByTypeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactsByTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.typeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.typeVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.options = ListOperationOptions.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactsByTypeRequest {
    return {
      typeName: isSet(object.typeName) ? globalThis.String(object.typeName) : '',
      typeVersion: isSet(object.typeVersion) ? globalThis.String(object.typeVersion) : '',
      options: isSet(object.options) ? ListOperationOptions.fromJSON(object.options) : undefined,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetArtifactsByTypeRequest): unknown {
    const obj: any = {};
    if (message.typeName !== undefined && message.typeName !== '') {
      obj.typeName = message.typeName;
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      obj.typeVersion = message.typeVersion;
    }
    if (message.options !== undefined) {
      obj.options = ListOperationOptions.toJSON(message.options);
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactsByTypeRequest>, I>>(
    base?: I,
  ): GetArtifactsByTypeRequest {
    return GetArtifactsByTypeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactsByTypeRequest>, I>>(
    object: I,
  ): GetArtifactsByTypeRequest {
    const message = createBaseGetArtifactsByTypeRequest();
    message.typeName = object.typeName ?? '';
    message.typeVersion = object.typeVersion ?? '';
    message.options =
      object.options !== undefined && object.options !== null
        ? ListOperationOptions.fromPartial(object.options)
        : undefined;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetArtifactsByTypeResponse(): GetArtifactsByTypeResponse {
  return { artifacts: [], nextPageToken: '' };
}

export const GetArtifactsByTypeResponse = {
  encode(
    message: GetArtifactsByTypeResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.artifacts) {
      Artifact.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactsByTypeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactsByTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifacts.push(Artifact.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactsByTypeResponse {
    return {
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => Artifact.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : '',
    };
  },

  toJSON(message: GetArtifactsByTypeResponse): unknown {
    const obj: any = {};
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => Artifact.toJSON(e));
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactsByTypeResponse>, I>>(
    base?: I,
  ): GetArtifactsByTypeResponse {
    return GetArtifactsByTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactsByTypeResponse>, I>>(
    object: I,
  ): GetArtifactsByTypeResponse {
    const message = createBaseGetArtifactsByTypeResponse();
    message.artifacts = object.artifacts?.map((e) => Artifact.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? '';
    return message;
  },
};

function createBaseGetArtifactByTypeAndNameRequest(): GetArtifactByTypeAndNameRequest {
  return { typeName: '', typeVersion: '', artifactName: '', transactionOptions: undefined };
}

export const GetArtifactByTypeAndNameRequest = {
  encode(
    message: GetArtifactByTypeAndNameRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.typeName !== undefined && message.typeName !== '') {
      writer.uint32(10).string(message.typeName);
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      writer.uint32(26).string(message.typeVersion);
    }
    if (message.artifactName !== undefined && message.artifactName !== '') {
      writer.uint32(18).string(message.artifactName);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactByTypeAndNameRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactByTypeAndNameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.typeName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.typeVersion = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.artifactName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactByTypeAndNameRequest {
    return {
      typeName: isSet(object.typeName) ? globalThis.String(object.typeName) : '',
      typeVersion: isSet(object.typeVersion) ? globalThis.String(object.typeVersion) : '',
      artifactName: isSet(object.artifactName) ? globalThis.String(object.artifactName) : '',
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetArtifactByTypeAndNameRequest): unknown {
    const obj: any = {};
    if (message.typeName !== undefined && message.typeName !== '') {
      obj.typeName = message.typeName;
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      obj.typeVersion = message.typeVersion;
    }
    if (message.artifactName !== undefined && message.artifactName !== '') {
      obj.artifactName = message.artifactName;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactByTypeAndNameRequest>, I>>(
    base?: I,
  ): GetArtifactByTypeAndNameRequest {
    return GetArtifactByTypeAndNameRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactByTypeAndNameRequest>, I>>(
    object: I,
  ): GetArtifactByTypeAndNameRequest {
    const message = createBaseGetArtifactByTypeAndNameRequest();
    message.typeName = object.typeName ?? '';
    message.typeVersion = object.typeVersion ?? '';
    message.artifactName = object.artifactName ?? '';
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetArtifactByTypeAndNameResponse(): GetArtifactByTypeAndNameResponse {
  return { artifact: undefined };
}

export const GetArtifactByTypeAndNameResponse = {
  encode(
    message: GetArtifactByTypeAndNameResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.artifact !== undefined) {
      Artifact.encode(message.artifact, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactByTypeAndNameResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactByTypeAndNameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifact = Artifact.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactByTypeAndNameResponse {
    return { artifact: isSet(object.artifact) ? Artifact.fromJSON(object.artifact) : undefined };
  },

  toJSON(message: GetArtifactByTypeAndNameResponse): unknown {
    const obj: any = {};
    if (message.artifact !== undefined) {
      obj.artifact = Artifact.toJSON(message.artifact);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactByTypeAndNameResponse>, I>>(
    base?: I,
  ): GetArtifactByTypeAndNameResponse {
    return GetArtifactByTypeAndNameResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactByTypeAndNameResponse>, I>>(
    object: I,
  ): GetArtifactByTypeAndNameResponse {
    const message = createBaseGetArtifactByTypeAndNameResponse();
    message.artifact =
      object.artifact !== undefined && object.artifact !== null
        ? Artifact.fromPartial(object.artifact)
        : undefined;
    return message;
  },
};

function createBaseGetArtifactsByIDRequest(): GetArtifactsByIDRequest {
  return { artifactIds: [], populateArtifactTypes: false, transactionOptions: undefined };
}

export const GetArtifactsByIDRequest = {
  encode(message: GetArtifactsByIDRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.artifactIds) {
      writer.int64(v);
    }
    writer.ldelim();
    if (message.populateArtifactTypes !== undefined && message.populateArtifactTypes !== false) {
      writer.uint32(24).bool(message.populateArtifactTypes);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactsByIDRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactsByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.artifactIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.artifactIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.populateArtifactTypes = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactsByIDRequest {
    return {
      artifactIds: globalThis.Array.isArray(object?.artifactIds)
        ? object.artifactIds.map((e: any) => globalThis.Number(e))
        : [],
      populateArtifactTypes: isSet(object.populateArtifactTypes)
        ? globalThis.Boolean(object.populateArtifactTypes)
        : false,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetArtifactsByIDRequest): unknown {
    const obj: any = {};
    if (message.artifactIds?.length) {
      obj.artifactIds = message.artifactIds.map((e) => Math.round(e));
    }
    if (message.populateArtifactTypes !== undefined && message.populateArtifactTypes !== false) {
      obj.populateArtifactTypes = message.populateArtifactTypes;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactsByIDRequest>, I>>(
    base?: I,
  ): GetArtifactsByIDRequest {
    return GetArtifactsByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactsByIDRequest>, I>>(
    object: I,
  ): GetArtifactsByIDRequest {
    const message = createBaseGetArtifactsByIDRequest();
    message.artifactIds = object.artifactIds?.map((e) => e) || [];
    message.populateArtifactTypes = object.populateArtifactTypes ?? false;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetArtifactsByIDResponse(): GetArtifactsByIDResponse {
  return { artifacts: [], artifactTypes: [] };
}

export const GetArtifactsByIDResponse = {
  encode(message: GetArtifactsByIDResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.artifacts) {
      Artifact.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.artifactTypes) {
      ArtifactType.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactsByIDResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactsByIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifacts.push(Artifact.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.artifactTypes.push(ArtifactType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactsByIDResponse {
    return {
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => Artifact.fromJSON(e))
        : [],
      artifactTypes: globalThis.Array.isArray(object?.artifactTypes)
        ? object.artifactTypes.map((e: any) => ArtifactType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetArtifactsByIDResponse): unknown {
    const obj: any = {};
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => Artifact.toJSON(e));
    }
    if (message.artifactTypes?.length) {
      obj.artifactTypes = message.artifactTypes.map((e) => ArtifactType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactsByIDResponse>, I>>(
    base?: I,
  ): GetArtifactsByIDResponse {
    return GetArtifactsByIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactsByIDResponse>, I>>(
    object: I,
  ): GetArtifactsByIDResponse {
    const message = createBaseGetArtifactsByIDResponse();
    message.artifacts = object.artifacts?.map((e) => Artifact.fromPartial(e)) || [];
    message.artifactTypes = object.artifactTypes?.map((e) => ArtifactType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetArtifactsRequest(): GetArtifactsRequest {
  return { options: undefined, transactionOptions: undefined };
}

export const GetArtifactsRequest = {
  encode(message: GetArtifactsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.options !== undefined) {
      ListOperationOptions.encode(message.options, writer.uint32(10).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.options = ListOperationOptions.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactsRequest {
    return {
      options: isSet(object.options) ? ListOperationOptions.fromJSON(object.options) : undefined,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetArtifactsRequest): unknown {
    const obj: any = {};
    if (message.options !== undefined) {
      obj.options = ListOperationOptions.toJSON(message.options);
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactsRequest>, I>>(base?: I): GetArtifactsRequest {
    return GetArtifactsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactsRequest>, I>>(
    object: I,
  ): GetArtifactsRequest {
    const message = createBaseGetArtifactsRequest();
    message.options =
      object.options !== undefined && object.options !== null
        ? ListOperationOptions.fromPartial(object.options)
        : undefined;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetArtifactsResponse(): GetArtifactsResponse {
  return { artifacts: [], nextPageToken: '' };
}

export const GetArtifactsResponse = {
  encode(message: GetArtifactsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.artifacts) {
      Artifact.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifacts.push(Artifact.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactsResponse {
    return {
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => Artifact.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : '',
    };
  },

  toJSON(message: GetArtifactsResponse): unknown {
    const obj: any = {};
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => Artifact.toJSON(e));
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactsResponse>, I>>(base?: I): GetArtifactsResponse {
    return GetArtifactsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactsResponse>, I>>(
    object: I,
  ): GetArtifactsResponse {
    const message = createBaseGetArtifactsResponse();
    message.artifacts = object.artifacts?.map((e) => Artifact.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? '';
    return message;
  },
};

function createBaseGetArtifactsByURIRequest(): GetArtifactsByURIRequest {
  return { uris: [], transactionOptions: undefined };
}

export const GetArtifactsByURIRequest = {
  encode(message: GetArtifactsByURIRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.uris) {
      writer.uint32(18).string(v!);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactsByURIRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactsByURIRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uris.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactsByURIRequest {
    return {
      uris: globalThis.Array.isArray(object?.uris)
        ? object.uris.map((e: any) => globalThis.String(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetArtifactsByURIRequest): unknown {
    const obj: any = {};
    if (message.uris?.length) {
      obj.uris = message.uris;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactsByURIRequest>, I>>(
    base?: I,
  ): GetArtifactsByURIRequest {
    return GetArtifactsByURIRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactsByURIRequest>, I>>(
    object: I,
  ): GetArtifactsByURIRequest {
    const message = createBaseGetArtifactsByURIRequest();
    message.uris = object.uris?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetArtifactsByURIResponse(): GetArtifactsByURIResponse {
  return { artifacts: [] };
}

export const GetArtifactsByURIResponse = {
  encode(message: GetArtifactsByURIResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.artifacts) {
      Artifact.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactsByURIResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactsByURIResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifacts.push(Artifact.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactsByURIResponse {
    return {
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => Artifact.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetArtifactsByURIResponse): unknown {
    const obj: any = {};
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => Artifact.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactsByURIResponse>, I>>(
    base?: I,
  ): GetArtifactsByURIResponse {
    return GetArtifactsByURIResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactsByURIResponse>, I>>(
    object: I,
  ): GetArtifactsByURIResponse {
    const message = createBaseGetArtifactsByURIResponse();
    message.artifacts = object.artifacts?.map((e) => Artifact.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetExecutionsRequest(): GetExecutionsRequest {
  return { options: undefined, transactionOptions: undefined };
}

export const GetExecutionsRequest = {
  encode(message: GetExecutionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.options !== undefined) {
      ListOperationOptions.encode(message.options, writer.uint32(10).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.options = ListOperationOptions.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionsRequest {
    return {
      options: isSet(object.options) ? ListOperationOptions.fromJSON(object.options) : undefined,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetExecutionsRequest): unknown {
    const obj: any = {};
    if (message.options !== undefined) {
      obj.options = ListOperationOptions.toJSON(message.options);
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionsRequest>, I>>(base?: I): GetExecutionsRequest {
    return GetExecutionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionsRequest>, I>>(
    object: I,
  ): GetExecutionsRequest {
    const message = createBaseGetExecutionsRequest();
    message.options =
      object.options !== undefined && object.options !== null
        ? ListOperationOptions.fromPartial(object.options)
        : undefined;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetExecutionsResponse(): GetExecutionsResponse {
  return { executions: [], nextPageToken: '' };
}

export const GetExecutionsResponse = {
  encode(message: GetExecutionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.executions) {
      Execution.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.executions.push(Execution.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionsResponse {
    return {
      executions: globalThis.Array.isArray(object?.executions)
        ? object.executions.map((e: any) => Execution.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : '',
    };
  },

  toJSON(message: GetExecutionsResponse): unknown {
    const obj: any = {};
    if (message.executions?.length) {
      obj.executions = message.executions.map((e) => Execution.toJSON(e));
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionsResponse>, I>>(base?: I): GetExecutionsResponse {
    return GetExecutionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionsResponse>, I>>(
    object: I,
  ): GetExecutionsResponse {
    const message = createBaseGetExecutionsResponse();
    message.executions = object.executions?.map((e) => Execution.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? '';
    return message;
  },
};

function createBaseGetArtifactTypeRequest(): GetArtifactTypeRequest {
  return { typeName: '', typeVersion: '', transactionOptions: undefined };
}

export const GetArtifactTypeRequest = {
  encode(message: GetArtifactTypeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.typeName !== undefined && message.typeName !== '') {
      writer.uint32(10).string(message.typeName);
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      writer.uint32(18).string(message.typeVersion);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactTypeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.typeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.typeVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactTypeRequest {
    return {
      typeName: isSet(object.typeName) ? globalThis.String(object.typeName) : '',
      typeVersion: isSet(object.typeVersion) ? globalThis.String(object.typeVersion) : '',
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetArtifactTypeRequest): unknown {
    const obj: any = {};
    if (message.typeName !== undefined && message.typeName !== '') {
      obj.typeName = message.typeName;
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      obj.typeVersion = message.typeVersion;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactTypeRequest>, I>>(
    base?: I,
  ): GetArtifactTypeRequest {
    return GetArtifactTypeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactTypeRequest>, I>>(
    object: I,
  ): GetArtifactTypeRequest {
    const message = createBaseGetArtifactTypeRequest();
    message.typeName = object.typeName ?? '';
    message.typeVersion = object.typeVersion ?? '';
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetArtifactTypeResponse(): GetArtifactTypeResponse {
  return { artifactType: undefined };
}

export const GetArtifactTypeResponse = {
  encode(message: GetArtifactTypeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.artifactType !== undefined) {
      ArtifactType.encode(message.artifactType, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactTypeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactType = ArtifactType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactTypeResponse {
    return {
      artifactType: isSet(object.artifactType)
        ? ArtifactType.fromJSON(object.artifactType)
        : undefined,
    };
  },

  toJSON(message: GetArtifactTypeResponse): unknown {
    const obj: any = {};
    if (message.artifactType !== undefined) {
      obj.artifactType = ArtifactType.toJSON(message.artifactType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactTypeResponse>, I>>(
    base?: I,
  ): GetArtifactTypeResponse {
    return GetArtifactTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactTypeResponse>, I>>(
    object: I,
  ): GetArtifactTypeResponse {
    const message = createBaseGetArtifactTypeResponse();
    message.artifactType =
      object.artifactType !== undefined && object.artifactType !== null
        ? ArtifactType.fromPartial(object.artifactType)
        : undefined;
    return message;
  },
};

function createBaseGetArtifactTypesRequest(): GetArtifactTypesRequest {
  return { transactionOptions: undefined };
}

export const GetArtifactTypesRequest = {
  encode(message: GetArtifactTypesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactTypesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactTypesRequest {
    return {
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetArtifactTypesRequest): unknown {
    const obj: any = {};
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactTypesRequest>, I>>(
    base?: I,
  ): GetArtifactTypesRequest {
    return GetArtifactTypesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactTypesRequest>, I>>(
    object: I,
  ): GetArtifactTypesRequest {
    const message = createBaseGetArtifactTypesRequest();
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetArtifactTypesResponse(): GetArtifactTypesResponse {
  return { artifactTypes: [] };
}

export const GetArtifactTypesResponse = {
  encode(message: GetArtifactTypesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.artifactTypes) {
      ArtifactType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactTypesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactTypes.push(ArtifactType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactTypesResponse {
    return {
      artifactTypes: globalThis.Array.isArray(object?.artifactTypes)
        ? object.artifactTypes.map((e: any) => ArtifactType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetArtifactTypesResponse): unknown {
    const obj: any = {};
    if (message.artifactTypes?.length) {
      obj.artifactTypes = message.artifactTypes.map((e) => ArtifactType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactTypesResponse>, I>>(
    base?: I,
  ): GetArtifactTypesResponse {
    return GetArtifactTypesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactTypesResponse>, I>>(
    object: I,
  ): GetArtifactTypesResponse {
    const message = createBaseGetArtifactTypesResponse();
    message.artifactTypes = object.artifactTypes?.map((e) => ArtifactType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetExecutionTypesRequest(): GetExecutionTypesRequest {
  return { transactionOptions: undefined };
}

export const GetExecutionTypesRequest = {
  encode(message: GetExecutionTypesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionTypesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionTypesRequest {
    return {
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetExecutionTypesRequest): unknown {
    const obj: any = {};
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionTypesRequest>, I>>(
    base?: I,
  ): GetExecutionTypesRequest {
    return GetExecutionTypesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionTypesRequest>, I>>(
    object: I,
  ): GetExecutionTypesRequest {
    const message = createBaseGetExecutionTypesRequest();
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetExecutionTypesResponse(): GetExecutionTypesResponse {
  return { executionTypes: [] };
}

export const GetExecutionTypesResponse = {
  encode(message: GetExecutionTypesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.executionTypes) {
      ExecutionType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionTypesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.executionTypes.push(ExecutionType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionTypesResponse {
    return {
      executionTypes: globalThis.Array.isArray(object?.executionTypes)
        ? object.executionTypes.map((e: any) => ExecutionType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetExecutionTypesResponse): unknown {
    const obj: any = {};
    if (message.executionTypes?.length) {
      obj.executionTypes = message.executionTypes.map((e) => ExecutionType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionTypesResponse>, I>>(
    base?: I,
  ): GetExecutionTypesResponse {
    return GetExecutionTypesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionTypesResponse>, I>>(
    object: I,
  ): GetExecutionTypesResponse {
    const message = createBaseGetExecutionTypesResponse();
    message.executionTypes = object.executionTypes?.map((e) => ExecutionType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetContextTypesRequest(): GetContextTypesRequest {
  return { transactionOptions: undefined };
}

export const GetContextTypesRequest = {
  encode(message: GetContextTypesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextTypesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextTypesRequest {
    return {
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetContextTypesRequest): unknown {
    const obj: any = {};
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextTypesRequest>, I>>(
    base?: I,
  ): GetContextTypesRequest {
    return GetContextTypesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextTypesRequest>, I>>(
    object: I,
  ): GetContextTypesRequest {
    const message = createBaseGetContextTypesRequest();
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetContextTypesResponse(): GetContextTypesResponse {
  return { contextTypes: [] };
}

export const GetContextTypesResponse = {
  encode(message: GetContextTypesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.contextTypes) {
      ContextType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextTypesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contextTypes.push(ContextType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextTypesResponse {
    return {
      contextTypes: globalThis.Array.isArray(object?.contextTypes)
        ? object.contextTypes.map((e: any) => ContextType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetContextTypesResponse): unknown {
    const obj: any = {};
    if (message.contextTypes?.length) {
      obj.contextTypes = message.contextTypes.map((e) => ContextType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextTypesResponse>, I>>(
    base?: I,
  ): GetContextTypesResponse {
    return GetContextTypesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextTypesResponse>, I>>(
    object: I,
  ): GetContextTypesResponse {
    const message = createBaseGetContextTypesResponse();
    message.contextTypes = object.contextTypes?.map((e) => ContextType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetArtifactsByExternalIdsRequest(): GetArtifactsByExternalIdsRequest {
  return { externalIds: [], transactionOptions: undefined };
}

export const GetArtifactsByExternalIdsRequest = {
  encode(
    message: GetArtifactsByExternalIdsRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.externalIds) {
      writer.uint32(10).string(v!);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactsByExternalIdsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactsByExternalIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactsByExternalIdsRequest {
    return {
      externalIds: globalThis.Array.isArray(object?.externalIds)
        ? object.externalIds.map((e: any) => globalThis.String(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetArtifactsByExternalIdsRequest): unknown {
    const obj: any = {};
    if (message.externalIds?.length) {
      obj.externalIds = message.externalIds;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactsByExternalIdsRequest>, I>>(
    base?: I,
  ): GetArtifactsByExternalIdsRequest {
    return GetArtifactsByExternalIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactsByExternalIdsRequest>, I>>(
    object: I,
  ): GetArtifactsByExternalIdsRequest {
    const message = createBaseGetArtifactsByExternalIdsRequest();
    message.externalIds = object.externalIds?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetArtifactsByExternalIdsResponse(): GetArtifactsByExternalIdsResponse {
  return { artifacts: [] };
}

export const GetArtifactsByExternalIdsResponse = {
  encode(
    message: GetArtifactsByExternalIdsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.artifacts) {
      Artifact.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactsByExternalIdsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactsByExternalIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifacts.push(Artifact.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactsByExternalIdsResponse {
    return {
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => Artifact.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetArtifactsByExternalIdsResponse): unknown {
    const obj: any = {};
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => Artifact.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactsByExternalIdsResponse>, I>>(
    base?: I,
  ): GetArtifactsByExternalIdsResponse {
    return GetArtifactsByExternalIdsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactsByExternalIdsResponse>, I>>(
    object: I,
  ): GetArtifactsByExternalIdsResponse {
    const message = createBaseGetArtifactsByExternalIdsResponse();
    message.artifacts = object.artifacts?.map((e) => Artifact.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetExecutionsByExternalIdsRequest(): GetExecutionsByExternalIdsRequest {
  return { externalIds: [], transactionOptions: undefined };
}

export const GetExecutionsByExternalIdsRequest = {
  encode(
    message: GetExecutionsByExternalIdsRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.externalIds) {
      writer.uint32(10).string(v!);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionsByExternalIdsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionsByExternalIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionsByExternalIdsRequest {
    return {
      externalIds: globalThis.Array.isArray(object?.externalIds)
        ? object.externalIds.map((e: any) => globalThis.String(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetExecutionsByExternalIdsRequest): unknown {
    const obj: any = {};
    if (message.externalIds?.length) {
      obj.externalIds = message.externalIds;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionsByExternalIdsRequest>, I>>(
    base?: I,
  ): GetExecutionsByExternalIdsRequest {
    return GetExecutionsByExternalIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionsByExternalIdsRequest>, I>>(
    object: I,
  ): GetExecutionsByExternalIdsRequest {
    const message = createBaseGetExecutionsByExternalIdsRequest();
    message.externalIds = object.externalIds?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetExecutionsByExternalIdsResponse(): GetExecutionsByExternalIdsResponse {
  return { executions: [] };
}

export const GetExecutionsByExternalIdsResponse = {
  encode(
    message: GetExecutionsByExternalIdsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.executions) {
      Execution.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionsByExternalIdsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionsByExternalIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.executions.push(Execution.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionsByExternalIdsResponse {
    return {
      executions: globalThis.Array.isArray(object?.executions)
        ? object.executions.map((e: any) => Execution.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetExecutionsByExternalIdsResponse): unknown {
    const obj: any = {};
    if (message.executions?.length) {
      obj.executions = message.executions.map((e) => Execution.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionsByExternalIdsResponse>, I>>(
    base?: I,
  ): GetExecutionsByExternalIdsResponse {
    return GetExecutionsByExternalIdsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionsByExternalIdsResponse>, I>>(
    object: I,
  ): GetExecutionsByExternalIdsResponse {
    const message = createBaseGetExecutionsByExternalIdsResponse();
    message.executions = object.executions?.map((e) => Execution.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetContextsByExternalIdsRequest(): GetContextsByExternalIdsRequest {
  return { externalIds: [], transactionOptions: undefined };
}

export const GetContextsByExternalIdsRequest = {
  encode(
    message: GetContextsByExternalIdsRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.externalIds) {
      writer.uint32(10).string(v!);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextsByExternalIdsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextsByExternalIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextsByExternalIdsRequest {
    return {
      externalIds: globalThis.Array.isArray(object?.externalIds)
        ? object.externalIds.map((e: any) => globalThis.String(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetContextsByExternalIdsRequest): unknown {
    const obj: any = {};
    if (message.externalIds?.length) {
      obj.externalIds = message.externalIds;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextsByExternalIdsRequest>, I>>(
    base?: I,
  ): GetContextsByExternalIdsRequest {
    return GetContextsByExternalIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextsByExternalIdsRequest>, I>>(
    object: I,
  ): GetContextsByExternalIdsRequest {
    const message = createBaseGetContextsByExternalIdsRequest();
    message.externalIds = object.externalIds?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetContextsByExternalIdsResponse(): GetContextsByExternalIdsResponse {
  return { contexts: [] };
}

export const GetContextsByExternalIdsResponse = {
  encode(
    message: GetContextsByExternalIdsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.contexts) {
      Context.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextsByExternalIdsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextsByExternalIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contexts.push(Context.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextsByExternalIdsResponse {
    return {
      contexts: globalThis.Array.isArray(object?.contexts)
        ? object.contexts.map((e: any) => Context.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetContextsByExternalIdsResponse): unknown {
    const obj: any = {};
    if (message.contexts?.length) {
      obj.contexts = message.contexts.map((e) => Context.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextsByExternalIdsResponse>, I>>(
    base?: I,
  ): GetContextsByExternalIdsResponse {
    return GetContextsByExternalIdsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextsByExternalIdsResponse>, I>>(
    object: I,
  ): GetContextsByExternalIdsResponse {
    const message = createBaseGetContextsByExternalIdsResponse();
    message.contexts = object.contexts?.map((e) => Context.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetArtifactTypesByExternalIdsRequest(): GetArtifactTypesByExternalIdsRequest {
  return { externalIds: [], transactionOptions: undefined };
}

export const GetArtifactTypesByExternalIdsRequest = {
  encode(
    message: GetArtifactTypesByExternalIdsRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.externalIds) {
      writer.uint32(10).string(v!);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactTypesByExternalIdsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactTypesByExternalIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactTypesByExternalIdsRequest {
    return {
      externalIds: globalThis.Array.isArray(object?.externalIds)
        ? object.externalIds.map((e: any) => globalThis.String(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetArtifactTypesByExternalIdsRequest): unknown {
    const obj: any = {};
    if (message.externalIds?.length) {
      obj.externalIds = message.externalIds;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactTypesByExternalIdsRequest>, I>>(
    base?: I,
  ): GetArtifactTypesByExternalIdsRequest {
    return GetArtifactTypesByExternalIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactTypesByExternalIdsRequest>, I>>(
    object: I,
  ): GetArtifactTypesByExternalIdsRequest {
    const message = createBaseGetArtifactTypesByExternalIdsRequest();
    message.externalIds = object.externalIds?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetArtifactTypesByExternalIdsResponse(): GetArtifactTypesByExternalIdsResponse {
  return { artifactTypes: [] };
}

export const GetArtifactTypesByExternalIdsResponse = {
  encode(
    message: GetArtifactTypesByExternalIdsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.artifactTypes) {
      ArtifactType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactTypesByExternalIdsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactTypesByExternalIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactTypes.push(ArtifactType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactTypesByExternalIdsResponse {
    return {
      artifactTypes: globalThis.Array.isArray(object?.artifactTypes)
        ? object.artifactTypes.map((e: any) => ArtifactType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetArtifactTypesByExternalIdsResponse): unknown {
    const obj: any = {};
    if (message.artifactTypes?.length) {
      obj.artifactTypes = message.artifactTypes.map((e) => ArtifactType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactTypesByExternalIdsResponse>, I>>(
    base?: I,
  ): GetArtifactTypesByExternalIdsResponse {
    return GetArtifactTypesByExternalIdsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactTypesByExternalIdsResponse>, I>>(
    object: I,
  ): GetArtifactTypesByExternalIdsResponse {
    const message = createBaseGetArtifactTypesByExternalIdsResponse();
    message.artifactTypes = object.artifactTypes?.map((e) => ArtifactType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetExecutionTypesByExternalIdsRequest(): GetExecutionTypesByExternalIdsRequest {
  return { externalIds: [], transactionOptions: undefined };
}

export const GetExecutionTypesByExternalIdsRequest = {
  encode(
    message: GetExecutionTypesByExternalIdsRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.externalIds) {
      writer.uint32(10).string(v!);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionTypesByExternalIdsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionTypesByExternalIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionTypesByExternalIdsRequest {
    return {
      externalIds: globalThis.Array.isArray(object?.externalIds)
        ? object.externalIds.map((e: any) => globalThis.String(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetExecutionTypesByExternalIdsRequest): unknown {
    const obj: any = {};
    if (message.externalIds?.length) {
      obj.externalIds = message.externalIds;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionTypesByExternalIdsRequest>, I>>(
    base?: I,
  ): GetExecutionTypesByExternalIdsRequest {
    return GetExecutionTypesByExternalIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionTypesByExternalIdsRequest>, I>>(
    object: I,
  ): GetExecutionTypesByExternalIdsRequest {
    const message = createBaseGetExecutionTypesByExternalIdsRequest();
    message.externalIds = object.externalIds?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetExecutionTypesByExternalIdsResponse(): GetExecutionTypesByExternalIdsResponse {
  return { executionTypes: [] };
}

export const GetExecutionTypesByExternalIdsResponse = {
  encode(
    message: GetExecutionTypesByExternalIdsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.executionTypes) {
      ExecutionType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionTypesByExternalIdsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionTypesByExternalIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.executionTypes.push(ExecutionType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionTypesByExternalIdsResponse {
    return {
      executionTypes: globalThis.Array.isArray(object?.executionTypes)
        ? object.executionTypes.map((e: any) => ExecutionType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetExecutionTypesByExternalIdsResponse): unknown {
    const obj: any = {};
    if (message.executionTypes?.length) {
      obj.executionTypes = message.executionTypes.map((e) => ExecutionType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionTypesByExternalIdsResponse>, I>>(
    base?: I,
  ): GetExecutionTypesByExternalIdsResponse {
    return GetExecutionTypesByExternalIdsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionTypesByExternalIdsResponse>, I>>(
    object: I,
  ): GetExecutionTypesByExternalIdsResponse {
    const message = createBaseGetExecutionTypesByExternalIdsResponse();
    message.executionTypes = object.executionTypes?.map((e) => ExecutionType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetContextTypesByExternalIdsRequest(): GetContextTypesByExternalIdsRequest {
  return { externalIds: [], transactionOptions: undefined };
}

export const GetContextTypesByExternalIdsRequest = {
  encode(
    message: GetContextTypesByExternalIdsRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.externalIds) {
      writer.uint32(10).string(v!);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextTypesByExternalIdsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextTypesByExternalIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextTypesByExternalIdsRequest {
    return {
      externalIds: globalThis.Array.isArray(object?.externalIds)
        ? object.externalIds.map((e: any) => globalThis.String(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetContextTypesByExternalIdsRequest): unknown {
    const obj: any = {};
    if (message.externalIds?.length) {
      obj.externalIds = message.externalIds;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextTypesByExternalIdsRequest>, I>>(
    base?: I,
  ): GetContextTypesByExternalIdsRequest {
    return GetContextTypesByExternalIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextTypesByExternalIdsRequest>, I>>(
    object: I,
  ): GetContextTypesByExternalIdsRequest {
    const message = createBaseGetContextTypesByExternalIdsRequest();
    message.externalIds = object.externalIds?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetContextTypesByExternalIdsResponse(): GetContextTypesByExternalIdsResponse {
  return { contextTypes: [] };
}

export const GetContextTypesByExternalIdsResponse = {
  encode(
    message: GetContextTypesByExternalIdsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.contextTypes) {
      ContextType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextTypesByExternalIdsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextTypesByExternalIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contextTypes.push(ContextType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextTypesByExternalIdsResponse {
    return {
      contextTypes: globalThis.Array.isArray(object?.contextTypes)
        ? object.contextTypes.map((e: any) => ContextType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetContextTypesByExternalIdsResponse): unknown {
    const obj: any = {};
    if (message.contextTypes?.length) {
      obj.contextTypes = message.contextTypes.map((e) => ContextType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextTypesByExternalIdsResponse>, I>>(
    base?: I,
  ): GetContextTypesByExternalIdsResponse {
    return GetContextTypesByExternalIdsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextTypesByExternalIdsResponse>, I>>(
    object: I,
  ): GetContextTypesByExternalIdsResponse {
    const message = createBaseGetContextTypesByExternalIdsResponse();
    message.contextTypes = object.contextTypes?.map((e) => ContextType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetExecutionsByTypeRequest(): GetExecutionsByTypeRequest {
  return { typeName: '', typeVersion: '', options: undefined, transactionOptions: undefined };
}

export const GetExecutionsByTypeRequest = {
  encode(
    message: GetExecutionsByTypeRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.typeName !== undefined && message.typeName !== '') {
      writer.uint32(10).string(message.typeName);
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      writer.uint32(18).string(message.typeVersion);
    }
    if (message.options !== undefined) {
      ListOperationOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionsByTypeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionsByTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.typeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.typeVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.options = ListOperationOptions.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionsByTypeRequest {
    return {
      typeName: isSet(object.typeName) ? globalThis.String(object.typeName) : '',
      typeVersion: isSet(object.typeVersion) ? globalThis.String(object.typeVersion) : '',
      options: isSet(object.options) ? ListOperationOptions.fromJSON(object.options) : undefined,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetExecutionsByTypeRequest): unknown {
    const obj: any = {};
    if (message.typeName !== undefined && message.typeName !== '') {
      obj.typeName = message.typeName;
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      obj.typeVersion = message.typeVersion;
    }
    if (message.options !== undefined) {
      obj.options = ListOperationOptions.toJSON(message.options);
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionsByTypeRequest>, I>>(
    base?: I,
  ): GetExecutionsByTypeRequest {
    return GetExecutionsByTypeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionsByTypeRequest>, I>>(
    object: I,
  ): GetExecutionsByTypeRequest {
    const message = createBaseGetExecutionsByTypeRequest();
    message.typeName = object.typeName ?? '';
    message.typeVersion = object.typeVersion ?? '';
    message.options =
      object.options !== undefined && object.options !== null
        ? ListOperationOptions.fromPartial(object.options)
        : undefined;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetExecutionsByTypeResponse(): GetExecutionsByTypeResponse {
  return { executions: [], nextPageToken: '' };
}

export const GetExecutionsByTypeResponse = {
  encode(
    message: GetExecutionsByTypeResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.executions) {
      Execution.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionsByTypeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionsByTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.executions.push(Execution.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionsByTypeResponse {
    return {
      executions: globalThis.Array.isArray(object?.executions)
        ? object.executions.map((e: any) => Execution.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : '',
    };
  },

  toJSON(message: GetExecutionsByTypeResponse): unknown {
    const obj: any = {};
    if (message.executions?.length) {
      obj.executions = message.executions.map((e) => Execution.toJSON(e));
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionsByTypeResponse>, I>>(
    base?: I,
  ): GetExecutionsByTypeResponse {
    return GetExecutionsByTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionsByTypeResponse>, I>>(
    object: I,
  ): GetExecutionsByTypeResponse {
    const message = createBaseGetExecutionsByTypeResponse();
    message.executions = object.executions?.map((e) => Execution.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? '';
    return message;
  },
};

function createBaseGetExecutionByTypeAndNameRequest(): GetExecutionByTypeAndNameRequest {
  return { typeName: '', typeVersion: '', executionName: '', transactionOptions: undefined };
}

export const GetExecutionByTypeAndNameRequest = {
  encode(
    message: GetExecutionByTypeAndNameRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.typeName !== undefined && message.typeName !== '') {
      writer.uint32(10).string(message.typeName);
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      writer.uint32(26).string(message.typeVersion);
    }
    if (message.executionName !== undefined && message.executionName !== '') {
      writer.uint32(18).string(message.executionName);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionByTypeAndNameRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionByTypeAndNameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.typeName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.typeVersion = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.executionName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionByTypeAndNameRequest {
    return {
      typeName: isSet(object.typeName) ? globalThis.String(object.typeName) : '',
      typeVersion: isSet(object.typeVersion) ? globalThis.String(object.typeVersion) : '',
      executionName: isSet(object.executionName) ? globalThis.String(object.executionName) : '',
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetExecutionByTypeAndNameRequest): unknown {
    const obj: any = {};
    if (message.typeName !== undefined && message.typeName !== '') {
      obj.typeName = message.typeName;
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      obj.typeVersion = message.typeVersion;
    }
    if (message.executionName !== undefined && message.executionName !== '') {
      obj.executionName = message.executionName;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionByTypeAndNameRequest>, I>>(
    base?: I,
  ): GetExecutionByTypeAndNameRequest {
    return GetExecutionByTypeAndNameRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionByTypeAndNameRequest>, I>>(
    object: I,
  ): GetExecutionByTypeAndNameRequest {
    const message = createBaseGetExecutionByTypeAndNameRequest();
    message.typeName = object.typeName ?? '';
    message.typeVersion = object.typeVersion ?? '';
    message.executionName = object.executionName ?? '';
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetExecutionByTypeAndNameResponse(): GetExecutionByTypeAndNameResponse {
  return { execution: undefined };
}

export const GetExecutionByTypeAndNameResponse = {
  encode(
    message: GetExecutionByTypeAndNameResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.execution !== undefined) {
      Execution.encode(message.execution, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionByTypeAndNameResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionByTypeAndNameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.execution = Execution.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionByTypeAndNameResponse {
    return {
      execution: isSet(object.execution) ? Execution.fromJSON(object.execution) : undefined,
    };
  },

  toJSON(message: GetExecutionByTypeAndNameResponse): unknown {
    const obj: any = {};
    if (message.execution !== undefined) {
      obj.execution = Execution.toJSON(message.execution);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionByTypeAndNameResponse>, I>>(
    base?: I,
  ): GetExecutionByTypeAndNameResponse {
    return GetExecutionByTypeAndNameResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionByTypeAndNameResponse>, I>>(
    object: I,
  ): GetExecutionByTypeAndNameResponse {
    const message = createBaseGetExecutionByTypeAndNameResponse();
    message.execution =
      object.execution !== undefined && object.execution !== null
        ? Execution.fromPartial(object.execution)
        : undefined;
    return message;
  },
};

function createBaseGetExecutionsByIDRequest(): GetExecutionsByIDRequest {
  return { executionIds: [], transactionOptions: undefined };
}

export const GetExecutionsByIDRequest = {
  encode(message: GetExecutionsByIDRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.executionIds) {
      writer.int64(v);
    }
    writer.ldelim();
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionsByIDRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionsByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.executionIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.executionIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionsByIDRequest {
    return {
      executionIds: globalThis.Array.isArray(object?.executionIds)
        ? object.executionIds.map((e: any) => globalThis.Number(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetExecutionsByIDRequest): unknown {
    const obj: any = {};
    if (message.executionIds?.length) {
      obj.executionIds = message.executionIds.map((e) => Math.round(e));
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionsByIDRequest>, I>>(
    base?: I,
  ): GetExecutionsByIDRequest {
    return GetExecutionsByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionsByIDRequest>, I>>(
    object: I,
  ): GetExecutionsByIDRequest {
    const message = createBaseGetExecutionsByIDRequest();
    message.executionIds = object.executionIds?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetExecutionsByIDResponse(): GetExecutionsByIDResponse {
  return { executions: [] };
}

export const GetExecutionsByIDResponse = {
  encode(message: GetExecutionsByIDResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.executions) {
      Execution.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionsByIDResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionsByIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.executions.push(Execution.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionsByIDResponse {
    return {
      executions: globalThis.Array.isArray(object?.executions)
        ? object.executions.map((e: any) => Execution.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetExecutionsByIDResponse): unknown {
    const obj: any = {};
    if (message.executions?.length) {
      obj.executions = message.executions.map((e) => Execution.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionsByIDResponse>, I>>(
    base?: I,
  ): GetExecutionsByIDResponse {
    return GetExecutionsByIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionsByIDResponse>, I>>(
    object: I,
  ): GetExecutionsByIDResponse {
    const message = createBaseGetExecutionsByIDResponse();
    message.executions = object.executions?.map((e) => Execution.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetExecutionTypeRequest(): GetExecutionTypeRequest {
  return { typeName: '', typeVersion: '', transactionOptions: undefined };
}

export const GetExecutionTypeRequest = {
  encode(message: GetExecutionTypeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.typeName !== undefined && message.typeName !== '') {
      writer.uint32(10).string(message.typeName);
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      writer.uint32(18).string(message.typeVersion);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionTypeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.typeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.typeVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionTypeRequest {
    return {
      typeName: isSet(object.typeName) ? globalThis.String(object.typeName) : '',
      typeVersion: isSet(object.typeVersion) ? globalThis.String(object.typeVersion) : '',
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetExecutionTypeRequest): unknown {
    const obj: any = {};
    if (message.typeName !== undefined && message.typeName !== '') {
      obj.typeName = message.typeName;
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      obj.typeVersion = message.typeVersion;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionTypeRequest>, I>>(
    base?: I,
  ): GetExecutionTypeRequest {
    return GetExecutionTypeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionTypeRequest>, I>>(
    object: I,
  ): GetExecutionTypeRequest {
    const message = createBaseGetExecutionTypeRequest();
    message.typeName = object.typeName ?? '';
    message.typeVersion = object.typeVersion ?? '';
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetExecutionTypeResponse(): GetExecutionTypeResponse {
  return { executionType: undefined };
}

export const GetExecutionTypeResponse = {
  encode(message: GetExecutionTypeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.executionType !== undefined) {
      ExecutionType.encode(message.executionType, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionTypeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.executionType = ExecutionType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionTypeResponse {
    return {
      executionType: isSet(object.executionType)
        ? ExecutionType.fromJSON(object.executionType)
        : undefined,
    };
  },

  toJSON(message: GetExecutionTypeResponse): unknown {
    const obj: any = {};
    if (message.executionType !== undefined) {
      obj.executionType = ExecutionType.toJSON(message.executionType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionTypeResponse>, I>>(
    base?: I,
  ): GetExecutionTypeResponse {
    return GetExecutionTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionTypeResponse>, I>>(
    object: I,
  ): GetExecutionTypeResponse {
    const message = createBaseGetExecutionTypeResponse();
    message.executionType =
      object.executionType !== undefined && object.executionType !== null
        ? ExecutionType.fromPartial(object.executionType)
        : undefined;
    return message;
  },
};

function createBaseGetEventsByExecutionIDsRequest(): GetEventsByExecutionIDsRequest {
  return { executionIds: [], transactionOptions: undefined };
}

export const GetEventsByExecutionIDsRequest = {
  encode(
    message: GetEventsByExecutionIDsRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.executionIds) {
      writer.int64(v);
    }
    writer.ldelim();
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetEventsByExecutionIDsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEventsByExecutionIDsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.executionIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.executionIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEventsByExecutionIDsRequest {
    return {
      executionIds: globalThis.Array.isArray(object?.executionIds)
        ? object.executionIds.map((e: any) => globalThis.Number(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetEventsByExecutionIDsRequest): unknown {
    const obj: any = {};
    if (message.executionIds?.length) {
      obj.executionIds = message.executionIds.map((e) => Math.round(e));
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEventsByExecutionIDsRequest>, I>>(
    base?: I,
  ): GetEventsByExecutionIDsRequest {
    return GetEventsByExecutionIDsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEventsByExecutionIDsRequest>, I>>(
    object: I,
  ): GetEventsByExecutionIDsRequest {
    const message = createBaseGetEventsByExecutionIDsRequest();
    message.executionIds = object.executionIds?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetEventsByExecutionIDsResponse(): GetEventsByExecutionIDsResponse {
  return { events: [] };
}

export const GetEventsByExecutionIDsResponse = {
  encode(
    message: GetEventsByExecutionIDsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.events) {
      Event.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetEventsByExecutionIDsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEventsByExecutionIDsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.events.push(Event.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEventsByExecutionIDsResponse {
    return {
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => Event.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetEventsByExecutionIDsResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEventsByExecutionIDsResponse>, I>>(
    base?: I,
  ): GetEventsByExecutionIDsResponse {
    return GetEventsByExecutionIDsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEventsByExecutionIDsResponse>, I>>(
    object: I,
  ): GetEventsByExecutionIDsResponse {
    const message = createBaseGetEventsByExecutionIDsResponse();
    message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetEventsByArtifactIDsRequest(): GetEventsByArtifactIDsRequest {
  return { artifactIds: [], transactionOptions: undefined };
}

export const GetEventsByArtifactIDsRequest = {
  encode(
    message: GetEventsByArtifactIDsRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.artifactIds) {
      writer.int64(v);
    }
    writer.ldelim();
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetEventsByArtifactIDsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEventsByArtifactIDsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.artifactIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.artifactIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEventsByArtifactIDsRequest {
    return {
      artifactIds: globalThis.Array.isArray(object?.artifactIds)
        ? object.artifactIds.map((e: any) => globalThis.Number(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetEventsByArtifactIDsRequest): unknown {
    const obj: any = {};
    if (message.artifactIds?.length) {
      obj.artifactIds = message.artifactIds.map((e) => Math.round(e));
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEventsByArtifactIDsRequest>, I>>(
    base?: I,
  ): GetEventsByArtifactIDsRequest {
    return GetEventsByArtifactIDsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEventsByArtifactIDsRequest>, I>>(
    object: I,
  ): GetEventsByArtifactIDsRequest {
    const message = createBaseGetEventsByArtifactIDsRequest();
    message.artifactIds = object.artifactIds?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetEventsByArtifactIDsResponse(): GetEventsByArtifactIDsResponse {
  return { events: [] };
}

export const GetEventsByArtifactIDsResponse = {
  encode(
    message: GetEventsByArtifactIDsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.events) {
      Event.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetEventsByArtifactIDsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEventsByArtifactIDsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.events.push(Event.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEventsByArtifactIDsResponse {
    return {
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => Event.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetEventsByArtifactIDsResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEventsByArtifactIDsResponse>, I>>(
    base?: I,
  ): GetEventsByArtifactIDsResponse {
    return GetEventsByArtifactIDsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEventsByArtifactIDsResponse>, I>>(
    object: I,
  ): GetEventsByArtifactIDsResponse {
    const message = createBaseGetEventsByArtifactIDsResponse();
    message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetArtifactTypesByIDRequest(): GetArtifactTypesByIDRequest {
  return { typeIds: [], transactionOptions: undefined };
}

export const GetArtifactTypesByIDRequest = {
  encode(
    message: GetArtifactTypesByIDRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.typeIds) {
      writer.int64(v);
    }
    writer.ldelim();
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactTypesByIDRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactTypesByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.typeIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.typeIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactTypesByIDRequest {
    return {
      typeIds: globalThis.Array.isArray(object?.typeIds)
        ? object.typeIds.map((e: any) => globalThis.Number(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetArtifactTypesByIDRequest): unknown {
    const obj: any = {};
    if (message.typeIds?.length) {
      obj.typeIds = message.typeIds.map((e) => Math.round(e));
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactTypesByIDRequest>, I>>(
    base?: I,
  ): GetArtifactTypesByIDRequest {
    return GetArtifactTypesByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactTypesByIDRequest>, I>>(
    object: I,
  ): GetArtifactTypesByIDRequest {
    const message = createBaseGetArtifactTypesByIDRequest();
    message.typeIds = object.typeIds?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetArtifactTypesByIDResponse(): GetArtifactTypesByIDResponse {
  return { artifactTypes: [] };
}

export const GetArtifactTypesByIDResponse = {
  encode(
    message: GetArtifactTypesByIDResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.artifactTypes) {
      ArtifactType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactTypesByIDResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactTypesByIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactTypes.push(ArtifactType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactTypesByIDResponse {
    return {
      artifactTypes: globalThis.Array.isArray(object?.artifactTypes)
        ? object.artifactTypes.map((e: any) => ArtifactType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetArtifactTypesByIDResponse): unknown {
    const obj: any = {};
    if (message.artifactTypes?.length) {
      obj.artifactTypes = message.artifactTypes.map((e) => ArtifactType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactTypesByIDResponse>, I>>(
    base?: I,
  ): GetArtifactTypesByIDResponse {
    return GetArtifactTypesByIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactTypesByIDResponse>, I>>(
    object: I,
  ): GetArtifactTypesByIDResponse {
    const message = createBaseGetArtifactTypesByIDResponse();
    message.artifactTypes = object.artifactTypes?.map((e) => ArtifactType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetExecutionTypesByIDRequest(): GetExecutionTypesByIDRequest {
  return { typeIds: [], transactionOptions: undefined };
}

export const GetExecutionTypesByIDRequest = {
  encode(
    message: GetExecutionTypesByIDRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.typeIds) {
      writer.int64(v);
    }
    writer.ldelim();
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionTypesByIDRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionTypesByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.typeIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.typeIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionTypesByIDRequest {
    return {
      typeIds: globalThis.Array.isArray(object?.typeIds)
        ? object.typeIds.map((e: any) => globalThis.Number(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetExecutionTypesByIDRequest): unknown {
    const obj: any = {};
    if (message.typeIds?.length) {
      obj.typeIds = message.typeIds.map((e) => Math.round(e));
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionTypesByIDRequest>, I>>(
    base?: I,
  ): GetExecutionTypesByIDRequest {
    return GetExecutionTypesByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionTypesByIDRequest>, I>>(
    object: I,
  ): GetExecutionTypesByIDRequest {
    const message = createBaseGetExecutionTypesByIDRequest();
    message.typeIds = object.typeIds?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetExecutionTypesByIDResponse(): GetExecutionTypesByIDResponse {
  return { executionTypes: [] };
}

export const GetExecutionTypesByIDResponse = {
  encode(
    message: GetExecutionTypesByIDResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.executionTypes) {
      ExecutionType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionTypesByIDResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionTypesByIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.executionTypes.push(ExecutionType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionTypesByIDResponse {
    return {
      executionTypes: globalThis.Array.isArray(object?.executionTypes)
        ? object.executionTypes.map((e: any) => ExecutionType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetExecutionTypesByIDResponse): unknown {
    const obj: any = {};
    if (message.executionTypes?.length) {
      obj.executionTypes = message.executionTypes.map((e) => ExecutionType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionTypesByIDResponse>, I>>(
    base?: I,
  ): GetExecutionTypesByIDResponse {
    return GetExecutionTypesByIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionTypesByIDResponse>, I>>(
    object: I,
  ): GetExecutionTypesByIDResponse {
    const message = createBaseGetExecutionTypesByIDResponse();
    message.executionTypes = object.executionTypes?.map((e) => ExecutionType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetContextTypeRequest(): GetContextTypeRequest {
  return { typeName: '', typeVersion: '', transactionOptions: undefined };
}

export const GetContextTypeRequest = {
  encode(message: GetContextTypeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.typeName !== undefined && message.typeName !== '') {
      writer.uint32(10).string(message.typeName);
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      writer.uint32(18).string(message.typeVersion);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextTypeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.typeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.typeVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextTypeRequest {
    return {
      typeName: isSet(object.typeName) ? globalThis.String(object.typeName) : '',
      typeVersion: isSet(object.typeVersion) ? globalThis.String(object.typeVersion) : '',
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetContextTypeRequest): unknown {
    const obj: any = {};
    if (message.typeName !== undefined && message.typeName !== '') {
      obj.typeName = message.typeName;
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      obj.typeVersion = message.typeVersion;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextTypeRequest>, I>>(base?: I): GetContextTypeRequest {
    return GetContextTypeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextTypeRequest>, I>>(
    object: I,
  ): GetContextTypeRequest {
    const message = createBaseGetContextTypeRequest();
    message.typeName = object.typeName ?? '';
    message.typeVersion = object.typeVersion ?? '';
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetContextTypeResponse(): GetContextTypeResponse {
  return { contextType: undefined };
}

export const GetContextTypeResponse = {
  encode(message: GetContextTypeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contextType !== undefined) {
      ContextType.encode(message.contextType, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextTypeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contextType = ContextType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextTypeResponse {
    return {
      contextType: isSet(object.contextType) ? ContextType.fromJSON(object.contextType) : undefined,
    };
  },

  toJSON(message: GetContextTypeResponse): unknown {
    const obj: any = {};
    if (message.contextType !== undefined) {
      obj.contextType = ContextType.toJSON(message.contextType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextTypeResponse>, I>>(
    base?: I,
  ): GetContextTypeResponse {
    return GetContextTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextTypeResponse>, I>>(
    object: I,
  ): GetContextTypeResponse {
    const message = createBaseGetContextTypeResponse();
    message.contextType =
      object.contextType !== undefined && object.contextType !== null
        ? ContextType.fromPartial(object.contextType)
        : undefined;
    return message;
  },
};

function createBaseGetContextTypesByIDRequest(): GetContextTypesByIDRequest {
  return { typeIds: [], transactionOptions: undefined };
}

export const GetContextTypesByIDRequest = {
  encode(
    message: GetContextTypesByIDRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.typeIds) {
      writer.int64(v);
    }
    writer.ldelim();
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextTypesByIDRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextTypesByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.typeIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.typeIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextTypesByIDRequest {
    return {
      typeIds: globalThis.Array.isArray(object?.typeIds)
        ? object.typeIds.map((e: any) => globalThis.Number(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetContextTypesByIDRequest): unknown {
    const obj: any = {};
    if (message.typeIds?.length) {
      obj.typeIds = message.typeIds.map((e) => Math.round(e));
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextTypesByIDRequest>, I>>(
    base?: I,
  ): GetContextTypesByIDRequest {
    return GetContextTypesByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextTypesByIDRequest>, I>>(
    object: I,
  ): GetContextTypesByIDRequest {
    const message = createBaseGetContextTypesByIDRequest();
    message.typeIds = object.typeIds?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetContextTypesByIDResponse(): GetContextTypesByIDResponse {
  return { contextTypes: [] };
}

export const GetContextTypesByIDResponse = {
  encode(
    message: GetContextTypesByIDResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.contextTypes) {
      ContextType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextTypesByIDResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextTypesByIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contextTypes.push(ContextType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextTypesByIDResponse {
    return {
      contextTypes: globalThis.Array.isArray(object?.contextTypes)
        ? object.contextTypes.map((e: any) => ContextType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetContextTypesByIDResponse): unknown {
    const obj: any = {};
    if (message.contextTypes?.length) {
      obj.contextTypes = message.contextTypes.map((e) => ContextType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextTypesByIDResponse>, I>>(
    base?: I,
  ): GetContextTypesByIDResponse {
    return GetContextTypesByIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextTypesByIDResponse>, I>>(
    object: I,
  ): GetContextTypesByIDResponse {
    const message = createBaseGetContextTypesByIDResponse();
    message.contextTypes = object.contextTypes?.map((e) => ContextType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetContextsRequest(): GetContextsRequest {
  return { options: undefined, transactionOptions: undefined };
}

export const GetContextsRequest = {
  encode(message: GetContextsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.options !== undefined) {
      ListOperationOptions.encode(message.options, writer.uint32(10).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.options = ListOperationOptions.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextsRequest {
    return {
      options: isSet(object.options) ? ListOperationOptions.fromJSON(object.options) : undefined,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetContextsRequest): unknown {
    const obj: any = {};
    if (message.options !== undefined) {
      obj.options = ListOperationOptions.toJSON(message.options);
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextsRequest>, I>>(base?: I): GetContextsRequest {
    return GetContextsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextsRequest>, I>>(object: I): GetContextsRequest {
    const message = createBaseGetContextsRequest();
    message.options =
      object.options !== undefined && object.options !== null
        ? ListOperationOptions.fromPartial(object.options)
        : undefined;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetContextsResponse(): GetContextsResponse {
  return { contexts: [], nextPageToken: '' };
}

export const GetContextsResponse = {
  encode(message: GetContextsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.contexts) {
      Context.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contexts.push(Context.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextsResponse {
    return {
      contexts: globalThis.Array.isArray(object?.contexts)
        ? object.contexts.map((e: any) => Context.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : '',
    };
  },

  toJSON(message: GetContextsResponse): unknown {
    const obj: any = {};
    if (message.contexts?.length) {
      obj.contexts = message.contexts.map((e) => Context.toJSON(e));
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextsResponse>, I>>(base?: I): GetContextsResponse {
    return GetContextsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextsResponse>, I>>(
    object: I,
  ): GetContextsResponse {
    const message = createBaseGetContextsResponse();
    message.contexts = object.contexts?.map((e) => Context.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? '';
    return message;
  },
};

function createBaseGetContextsByTypeRequest(): GetContextsByTypeRequest {
  return { typeName: '', options: undefined, typeVersion: '', transactionOptions: undefined };
}

export const GetContextsByTypeRequest = {
  encode(message: GetContextsByTypeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.typeName !== undefined && message.typeName !== '') {
      writer.uint32(10).string(message.typeName);
    }
    if (message.options !== undefined) {
      ListOperationOptions.encode(message.options, writer.uint32(18).fork()).ldelim();
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      writer.uint32(26).string(message.typeVersion);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextsByTypeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextsByTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.typeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.options = ListOperationOptions.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.typeVersion = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextsByTypeRequest {
    return {
      typeName: isSet(object.typeName) ? globalThis.String(object.typeName) : '',
      options: isSet(object.options) ? ListOperationOptions.fromJSON(object.options) : undefined,
      typeVersion: isSet(object.typeVersion) ? globalThis.String(object.typeVersion) : '',
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetContextsByTypeRequest): unknown {
    const obj: any = {};
    if (message.typeName !== undefined && message.typeName !== '') {
      obj.typeName = message.typeName;
    }
    if (message.options !== undefined) {
      obj.options = ListOperationOptions.toJSON(message.options);
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      obj.typeVersion = message.typeVersion;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextsByTypeRequest>, I>>(
    base?: I,
  ): GetContextsByTypeRequest {
    return GetContextsByTypeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextsByTypeRequest>, I>>(
    object: I,
  ): GetContextsByTypeRequest {
    const message = createBaseGetContextsByTypeRequest();
    message.typeName = object.typeName ?? '';
    message.options =
      object.options !== undefined && object.options !== null
        ? ListOperationOptions.fromPartial(object.options)
        : undefined;
    message.typeVersion = object.typeVersion ?? '';
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetContextsByTypeResponse(): GetContextsByTypeResponse {
  return { contexts: [], nextPageToken: '' };
}

export const GetContextsByTypeResponse = {
  encode(message: GetContextsByTypeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.contexts) {
      Context.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextsByTypeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextsByTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contexts.push(Context.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextsByTypeResponse {
    return {
      contexts: globalThis.Array.isArray(object?.contexts)
        ? object.contexts.map((e: any) => Context.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : '',
    };
  },

  toJSON(message: GetContextsByTypeResponse): unknown {
    const obj: any = {};
    if (message.contexts?.length) {
      obj.contexts = message.contexts.map((e) => Context.toJSON(e));
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextsByTypeResponse>, I>>(
    base?: I,
  ): GetContextsByTypeResponse {
    return GetContextsByTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextsByTypeResponse>, I>>(
    object: I,
  ): GetContextsByTypeResponse {
    const message = createBaseGetContextsByTypeResponse();
    message.contexts = object.contexts?.map((e) => Context.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? '';
    return message;
  },
};

function createBaseGetContextByTypeAndNameRequest(): GetContextByTypeAndNameRequest {
  return { typeName: '', typeVersion: '', contextName: '', transactionOptions: undefined };
}

export const GetContextByTypeAndNameRequest = {
  encode(
    message: GetContextByTypeAndNameRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.typeName !== undefined && message.typeName !== '') {
      writer.uint32(10).string(message.typeName);
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      writer.uint32(26).string(message.typeVersion);
    }
    if (message.contextName !== undefined && message.contextName !== '') {
      writer.uint32(18).string(message.contextName);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextByTypeAndNameRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextByTypeAndNameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.typeName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.typeVersion = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contextName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextByTypeAndNameRequest {
    return {
      typeName: isSet(object.typeName) ? globalThis.String(object.typeName) : '',
      typeVersion: isSet(object.typeVersion) ? globalThis.String(object.typeVersion) : '',
      contextName: isSet(object.contextName) ? globalThis.String(object.contextName) : '',
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetContextByTypeAndNameRequest): unknown {
    const obj: any = {};
    if (message.typeName !== undefined && message.typeName !== '') {
      obj.typeName = message.typeName;
    }
    if (message.typeVersion !== undefined && message.typeVersion !== '') {
      obj.typeVersion = message.typeVersion;
    }
    if (message.contextName !== undefined && message.contextName !== '') {
      obj.contextName = message.contextName;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextByTypeAndNameRequest>, I>>(
    base?: I,
  ): GetContextByTypeAndNameRequest {
    return GetContextByTypeAndNameRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextByTypeAndNameRequest>, I>>(
    object: I,
  ): GetContextByTypeAndNameRequest {
    const message = createBaseGetContextByTypeAndNameRequest();
    message.typeName = object.typeName ?? '';
    message.typeVersion = object.typeVersion ?? '';
    message.contextName = object.contextName ?? '';
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetContextByTypeAndNameResponse(): GetContextByTypeAndNameResponse {
  return { context: undefined };
}

export const GetContextByTypeAndNameResponse = {
  encode(
    message: GetContextByTypeAndNameResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.context !== undefined) {
      Context.encode(message.context, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextByTypeAndNameResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextByTypeAndNameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = Context.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextByTypeAndNameResponse {
    return { context: isSet(object.context) ? Context.fromJSON(object.context) : undefined };
  },

  toJSON(message: GetContextByTypeAndNameResponse): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = Context.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextByTypeAndNameResponse>, I>>(
    base?: I,
  ): GetContextByTypeAndNameResponse {
    return GetContextByTypeAndNameResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextByTypeAndNameResponse>, I>>(
    object: I,
  ): GetContextByTypeAndNameResponse {
    const message = createBaseGetContextByTypeAndNameResponse();
    message.context =
      object.context !== undefined && object.context !== null
        ? Context.fromPartial(object.context)
        : undefined;
    return message;
  },
};

function createBaseGetContextsByIDRequest(): GetContextsByIDRequest {
  return { contextIds: [], transactionOptions: undefined };
}

export const GetContextsByIDRequest = {
  encode(message: GetContextsByIDRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.contextIds) {
      writer.int64(v);
    }
    writer.ldelim();
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextsByIDRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextsByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.contextIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.contextIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextsByIDRequest {
    return {
      contextIds: globalThis.Array.isArray(object?.contextIds)
        ? object.contextIds.map((e: any) => globalThis.Number(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetContextsByIDRequest): unknown {
    const obj: any = {};
    if (message.contextIds?.length) {
      obj.contextIds = message.contextIds.map((e) => Math.round(e));
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextsByIDRequest>, I>>(
    base?: I,
  ): GetContextsByIDRequest {
    return GetContextsByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextsByIDRequest>, I>>(
    object: I,
  ): GetContextsByIDRequest {
    const message = createBaseGetContextsByIDRequest();
    message.contextIds = object.contextIds?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetContextsByIDResponse(): GetContextsByIDResponse {
  return { contexts: [] };
}

export const GetContextsByIDResponse = {
  encode(message: GetContextsByIDResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.contexts) {
      Context.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextsByIDResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextsByIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contexts.push(Context.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextsByIDResponse {
    return {
      contexts: globalThis.Array.isArray(object?.contexts)
        ? object.contexts.map((e: any) => Context.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetContextsByIDResponse): unknown {
    const obj: any = {};
    if (message.contexts?.length) {
      obj.contexts = message.contexts.map((e) => Context.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextsByIDResponse>, I>>(
    base?: I,
  ): GetContextsByIDResponse {
    return GetContextsByIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextsByIDResponse>, I>>(
    object: I,
  ): GetContextsByIDResponse {
    const message = createBaseGetContextsByIDResponse();
    message.contexts = object.contexts?.map((e) => Context.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetContextsByArtifactRequest(): GetContextsByArtifactRequest {
  return { artifactId: 0, transactionOptions: undefined };
}

export const GetContextsByArtifactRequest = {
  encode(
    message: GetContextsByArtifactRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.artifactId !== undefined && message.artifactId !== 0) {
      writer.uint32(8).int64(message.artifactId);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextsByArtifactRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextsByArtifactRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.artifactId = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextsByArtifactRequest {
    return {
      artifactId: isSet(object.artifactId) ? globalThis.Number(object.artifactId) : 0,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetContextsByArtifactRequest): unknown {
    const obj: any = {};
    if (message.artifactId !== undefined && message.artifactId !== 0) {
      obj.artifactId = Math.round(message.artifactId);
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextsByArtifactRequest>, I>>(
    base?: I,
  ): GetContextsByArtifactRequest {
    return GetContextsByArtifactRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextsByArtifactRequest>, I>>(
    object: I,
  ): GetContextsByArtifactRequest {
    const message = createBaseGetContextsByArtifactRequest();
    message.artifactId = object.artifactId ?? 0;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetContextsByArtifactResponse(): GetContextsByArtifactResponse {
  return { contexts: [] };
}

export const GetContextsByArtifactResponse = {
  encode(
    message: GetContextsByArtifactResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.contexts) {
      Context.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextsByArtifactResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextsByArtifactResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contexts.push(Context.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextsByArtifactResponse {
    return {
      contexts: globalThis.Array.isArray(object?.contexts)
        ? object.contexts.map((e: any) => Context.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetContextsByArtifactResponse): unknown {
    const obj: any = {};
    if (message.contexts?.length) {
      obj.contexts = message.contexts.map((e) => Context.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextsByArtifactResponse>, I>>(
    base?: I,
  ): GetContextsByArtifactResponse {
    return GetContextsByArtifactResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextsByArtifactResponse>, I>>(
    object: I,
  ): GetContextsByArtifactResponse {
    const message = createBaseGetContextsByArtifactResponse();
    message.contexts = object.contexts?.map((e) => Context.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetContextsByExecutionRequest(): GetContextsByExecutionRequest {
  return { executionId: 0, transactionOptions: undefined };
}

export const GetContextsByExecutionRequest = {
  encode(
    message: GetContextsByExecutionRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.executionId !== undefined && message.executionId !== 0) {
      writer.uint32(8).int64(message.executionId);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextsByExecutionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextsByExecutionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.executionId = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextsByExecutionRequest {
    return {
      executionId: isSet(object.executionId) ? globalThis.Number(object.executionId) : 0,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetContextsByExecutionRequest): unknown {
    const obj: any = {};
    if (message.executionId !== undefined && message.executionId !== 0) {
      obj.executionId = Math.round(message.executionId);
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextsByExecutionRequest>, I>>(
    base?: I,
  ): GetContextsByExecutionRequest {
    return GetContextsByExecutionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextsByExecutionRequest>, I>>(
    object: I,
  ): GetContextsByExecutionRequest {
    const message = createBaseGetContextsByExecutionRequest();
    message.executionId = object.executionId ?? 0;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetContextsByExecutionResponse(): GetContextsByExecutionResponse {
  return { contexts: [] };
}

export const GetContextsByExecutionResponse = {
  encode(
    message: GetContextsByExecutionResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.contexts) {
      Context.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetContextsByExecutionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextsByExecutionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contexts.push(Context.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextsByExecutionResponse {
    return {
      contexts: globalThis.Array.isArray(object?.contexts)
        ? object.contexts.map((e: any) => Context.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetContextsByExecutionResponse): unknown {
    const obj: any = {};
    if (message.contexts?.length) {
      obj.contexts = message.contexts.map((e) => Context.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextsByExecutionResponse>, I>>(
    base?: I,
  ): GetContextsByExecutionResponse {
    return GetContextsByExecutionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextsByExecutionResponse>, I>>(
    object: I,
  ): GetContextsByExecutionResponse {
    const message = createBaseGetContextsByExecutionResponse();
    message.contexts = object.contexts?.map((e) => Context.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetParentContextsByContextRequest(): GetParentContextsByContextRequest {
  return { contextId: 0, transactionOptions: undefined };
}

export const GetParentContextsByContextRequest = {
  encode(
    message: GetParentContextsByContextRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.contextId !== undefined && message.contextId !== 0) {
      writer.uint32(8).int64(message.contextId);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetParentContextsByContextRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParentContextsByContextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.contextId = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetParentContextsByContextRequest {
    return {
      contextId: isSet(object.contextId) ? globalThis.Number(object.contextId) : 0,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetParentContextsByContextRequest): unknown {
    const obj: any = {};
    if (message.contextId !== undefined && message.contextId !== 0) {
      obj.contextId = Math.round(message.contextId);
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetParentContextsByContextRequest>, I>>(
    base?: I,
  ): GetParentContextsByContextRequest {
    return GetParentContextsByContextRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetParentContextsByContextRequest>, I>>(
    object: I,
  ): GetParentContextsByContextRequest {
    const message = createBaseGetParentContextsByContextRequest();
    message.contextId = object.contextId ?? 0;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetParentContextsByContextResponse(): GetParentContextsByContextResponse {
  return { contexts: [] };
}

export const GetParentContextsByContextResponse = {
  encode(
    message: GetParentContextsByContextResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.contexts) {
      Context.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetParentContextsByContextResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParentContextsByContextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contexts.push(Context.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetParentContextsByContextResponse {
    return {
      contexts: globalThis.Array.isArray(object?.contexts)
        ? object.contexts.map((e: any) => Context.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetParentContextsByContextResponse): unknown {
    const obj: any = {};
    if (message.contexts?.length) {
      obj.contexts = message.contexts.map((e) => Context.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetParentContextsByContextResponse>, I>>(
    base?: I,
  ): GetParentContextsByContextResponse {
    return GetParentContextsByContextResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetParentContextsByContextResponse>, I>>(
    object: I,
  ): GetParentContextsByContextResponse {
    const message = createBaseGetParentContextsByContextResponse();
    message.contexts = object.contexts?.map((e) => Context.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetChildrenContextsByContextRequest(): GetChildrenContextsByContextRequest {
  return { contextId: 0, transactionOptions: undefined };
}

export const GetChildrenContextsByContextRequest = {
  encode(
    message: GetChildrenContextsByContextRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.contextId !== undefined && message.contextId !== 0) {
      writer.uint32(8).int64(message.contextId);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetChildrenContextsByContextRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChildrenContextsByContextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.contextId = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChildrenContextsByContextRequest {
    return {
      contextId: isSet(object.contextId) ? globalThis.Number(object.contextId) : 0,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetChildrenContextsByContextRequest): unknown {
    const obj: any = {};
    if (message.contextId !== undefined && message.contextId !== 0) {
      obj.contextId = Math.round(message.contextId);
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChildrenContextsByContextRequest>, I>>(
    base?: I,
  ): GetChildrenContextsByContextRequest {
    return GetChildrenContextsByContextRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChildrenContextsByContextRequest>, I>>(
    object: I,
  ): GetChildrenContextsByContextRequest {
    const message = createBaseGetChildrenContextsByContextRequest();
    message.contextId = object.contextId ?? 0;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetChildrenContextsByContextResponse(): GetChildrenContextsByContextResponse {
  return { contexts: [] };
}

export const GetChildrenContextsByContextResponse = {
  encode(
    message: GetChildrenContextsByContextResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.contexts) {
      Context.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetChildrenContextsByContextResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChildrenContextsByContextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contexts.push(Context.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChildrenContextsByContextResponse {
    return {
      contexts: globalThis.Array.isArray(object?.contexts)
        ? object.contexts.map((e: any) => Context.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetChildrenContextsByContextResponse): unknown {
    const obj: any = {};
    if (message.contexts?.length) {
      obj.contexts = message.contexts.map((e) => Context.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChildrenContextsByContextResponse>, I>>(
    base?: I,
  ): GetChildrenContextsByContextResponse {
    return GetChildrenContextsByContextResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChildrenContextsByContextResponse>, I>>(
    object: I,
  ): GetChildrenContextsByContextResponse {
    const message = createBaseGetChildrenContextsByContextResponse();
    message.contexts = object.contexts?.map((e) => Context.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetParentContextsByContextsRequest(): GetParentContextsByContextsRequest {
  return { contextIds: [], transactionOptions: undefined };
}

export const GetParentContextsByContextsRequest = {
  encode(
    message: GetParentContextsByContextsRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.contextIds) {
      writer.int64(v);
    }
    writer.ldelim();
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetParentContextsByContextsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParentContextsByContextsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.contextIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.contextIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetParentContextsByContextsRequest {
    return {
      contextIds: globalThis.Array.isArray(object?.contextIds)
        ? object.contextIds.map((e: any) => globalThis.Number(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetParentContextsByContextsRequest): unknown {
    const obj: any = {};
    if (message.contextIds?.length) {
      obj.contextIds = message.contextIds.map((e) => Math.round(e));
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetParentContextsByContextsRequest>, I>>(
    base?: I,
  ): GetParentContextsByContextsRequest {
    return GetParentContextsByContextsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetParentContextsByContextsRequest>, I>>(
    object: I,
  ): GetParentContextsByContextsRequest {
    const message = createBaseGetParentContextsByContextsRequest();
    message.contextIds = object.contextIds?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetParentContextsByContextsResponse(): GetParentContextsByContextsResponse {
  return { contexts: {} };
}

export const GetParentContextsByContextsResponse = {
  encode(
    message: GetParentContextsByContextsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    Object.entries(message.contexts).forEach(([key, value]) => {
      GetParentContextsByContextsResponse_ContextsEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetParentContextsByContextsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParentContextsByContextsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = GetParentContextsByContextsResponse_ContextsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry2.value !== undefined) {
            message.contexts[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetParentContextsByContextsResponse {
    return {
      contexts: isObject(object.contexts)
        ? Object.entries(object.contexts).reduce<{
            [key: number]: GetParentContextsByContextsResponse_ParentContextsPerChild;
          }>((acc, [key, value]) => {
            acc[globalThis.Number(key)] =
              GetParentContextsByContextsResponse_ParentContextsPerChild.fromJSON(value);
            return acc;
          }, {})
        : {},
    };
  },

  toJSON(message: GetParentContextsByContextsResponse): unknown {
    const obj: any = {};
    if (message.contexts) {
      const entries = Object.entries(message.contexts);
      if (entries.length > 0) {
        obj.contexts = {};
        entries.forEach(([k, v]) => {
          obj.contexts[k] = GetParentContextsByContextsResponse_ParentContextsPerChild.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetParentContextsByContextsResponse>, I>>(
    base?: I,
  ): GetParentContextsByContextsResponse {
    return GetParentContextsByContextsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetParentContextsByContextsResponse>, I>>(
    object: I,
  ): GetParentContextsByContextsResponse {
    const message = createBaseGetParentContextsByContextsResponse();
    message.contexts = Object.entries(object.contexts ?? {}).reduce<{
      [key: number]: GetParentContextsByContextsResponse_ParentContextsPerChild;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] =
          GetParentContextsByContextsResponse_ParentContextsPerChild.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetParentContextsByContextsResponse_ParentContextsPerChild(): GetParentContextsByContextsResponse_ParentContextsPerChild {
  return { parentContexts: [] };
}

export const GetParentContextsByContextsResponse_ParentContextsPerChild = {
  encode(
    message: GetParentContextsByContextsResponse_ParentContextsPerChild,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.parentContexts) {
      Context.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): GetParentContextsByContextsResponse_ParentContextsPerChild {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParentContextsByContextsResponse_ParentContextsPerChild();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parentContexts.push(Context.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetParentContextsByContextsResponse_ParentContextsPerChild {
    return {
      parentContexts: globalThis.Array.isArray(object?.parentContexts)
        ? object.parentContexts.map((e: any) => Context.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetParentContextsByContextsResponse_ParentContextsPerChild): unknown {
    const obj: any = {};
    if (message.parentContexts?.length) {
      obj.parentContexts = message.parentContexts.map((e) => Context.toJSON(e));
    }
    return obj;
  },

  create<
    I extends Exact<DeepPartial<GetParentContextsByContextsResponse_ParentContextsPerChild>, I>,
  >(base?: I): GetParentContextsByContextsResponse_ParentContextsPerChild {
    return GetParentContextsByContextsResponse_ParentContextsPerChild.fromPartial(
      base ?? ({} as any),
    );
  },
  fromPartial<
    I extends Exact<DeepPartial<GetParentContextsByContextsResponse_ParentContextsPerChild>, I>,
  >(object: I): GetParentContextsByContextsResponse_ParentContextsPerChild {
    const message = createBaseGetParentContextsByContextsResponse_ParentContextsPerChild();
    message.parentContexts = object.parentContexts?.map((e) => Context.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetParentContextsByContextsResponse_ContextsEntry(): GetParentContextsByContextsResponse_ContextsEntry {
  return { key: 0, value: undefined };
}

export const GetParentContextsByContextsResponse_ContextsEntry = {
  encode(
    message: GetParentContextsByContextsResponse_ContextsEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== 0) {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      GetParentContextsByContextsResponse_ParentContextsPerChild.encode(
        message.value,
        writer.uint32(18).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): GetParentContextsByContextsResponse_ContextsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParentContextsByContextsResponse_ContextsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = GetParentContextsByContextsResponse_ParentContextsPerChild.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetParentContextsByContextsResponse_ContextsEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value)
        ? GetParentContextsByContextsResponse_ParentContextsPerChild.fromJSON(object.value)
        : undefined,
    };
  },

  toJSON(message: GetParentContextsByContextsResponse_ContextsEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = GetParentContextsByContextsResponse_ParentContextsPerChild.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetParentContextsByContextsResponse_ContextsEntry>, I>>(
    base?: I,
  ): GetParentContextsByContextsResponse_ContextsEntry {
    return GetParentContextsByContextsResponse_ContextsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetParentContextsByContextsResponse_ContextsEntry>, I>>(
    object: I,
  ): GetParentContextsByContextsResponse_ContextsEntry {
    const message = createBaseGetParentContextsByContextsResponse_ContextsEntry();
    message.key = object.key ?? 0;
    message.value =
      object.value !== undefined && object.value !== null
        ? GetParentContextsByContextsResponse_ParentContextsPerChild.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseGetChildrenContextsByContextsRequest(): GetChildrenContextsByContextsRequest {
  return { contextIds: [], transactionOptions: undefined };
}

export const GetChildrenContextsByContextsRequest = {
  encode(
    message: GetChildrenContextsByContextsRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.contextIds) {
      writer.int64(v);
    }
    writer.ldelim();
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetChildrenContextsByContextsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChildrenContextsByContextsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.contextIds.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.contextIds.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChildrenContextsByContextsRequest {
    return {
      contextIds: globalThis.Array.isArray(object?.contextIds)
        ? object.contextIds.map((e: any) => globalThis.Number(e))
        : [],
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetChildrenContextsByContextsRequest): unknown {
    const obj: any = {};
    if (message.contextIds?.length) {
      obj.contextIds = message.contextIds.map((e) => Math.round(e));
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChildrenContextsByContextsRequest>, I>>(
    base?: I,
  ): GetChildrenContextsByContextsRequest {
    return GetChildrenContextsByContextsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChildrenContextsByContextsRequest>, I>>(
    object: I,
  ): GetChildrenContextsByContextsRequest {
    const message = createBaseGetChildrenContextsByContextsRequest();
    message.contextIds = object.contextIds?.map((e) => e) || [];
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetChildrenContextsByContextsResponse(): GetChildrenContextsByContextsResponse {
  return { contexts: {} };
}

export const GetChildrenContextsByContextsResponse = {
  encode(
    message: GetChildrenContextsByContextsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    Object.entries(message.contexts).forEach(([key, value]) => {
      GetChildrenContextsByContextsResponse_ContextsEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetChildrenContextsByContextsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChildrenContextsByContextsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = GetChildrenContextsByContextsResponse_ContextsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry2.value !== undefined) {
            message.contexts[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChildrenContextsByContextsResponse {
    return {
      contexts: isObject(object.contexts)
        ? Object.entries(object.contexts).reduce<{
            [key: number]: GetChildrenContextsByContextsResponse_ChildrenContextsPerParent;
          }>((acc, [key, value]) => {
            acc[globalThis.Number(key)] =
              GetChildrenContextsByContextsResponse_ChildrenContextsPerParent.fromJSON(value);
            return acc;
          }, {})
        : {},
    };
  },

  toJSON(message: GetChildrenContextsByContextsResponse): unknown {
    const obj: any = {};
    if (message.contexts) {
      const entries = Object.entries(message.contexts);
      if (entries.length > 0) {
        obj.contexts = {};
        entries.forEach(([k, v]) => {
          obj.contexts[k] =
            GetChildrenContextsByContextsResponse_ChildrenContextsPerParent.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChildrenContextsByContextsResponse>, I>>(
    base?: I,
  ): GetChildrenContextsByContextsResponse {
    return GetChildrenContextsByContextsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChildrenContextsByContextsResponse>, I>>(
    object: I,
  ): GetChildrenContextsByContextsResponse {
    const message = createBaseGetChildrenContextsByContextsResponse();
    message.contexts = Object.entries(object.contexts ?? {}).reduce<{
      [key: number]: GetChildrenContextsByContextsResponse_ChildrenContextsPerParent;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] =
          GetChildrenContextsByContextsResponse_ChildrenContextsPerParent.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetChildrenContextsByContextsResponse_ChildrenContextsPerParent(): GetChildrenContextsByContextsResponse_ChildrenContextsPerParent {
  return { childrenContexts: [] };
}

export const GetChildrenContextsByContextsResponse_ChildrenContextsPerParent = {
  encode(
    message: GetChildrenContextsByContextsResponse_ChildrenContextsPerParent,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.childrenContexts) {
      Context.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): GetChildrenContextsByContextsResponse_ChildrenContextsPerParent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChildrenContextsByContextsResponse_ChildrenContextsPerParent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.childrenContexts.push(Context.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChildrenContextsByContextsResponse_ChildrenContextsPerParent {
    return {
      childrenContexts: globalThis.Array.isArray(object?.childrenContexts)
        ? object.childrenContexts.map((e: any) => Context.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetChildrenContextsByContextsResponse_ChildrenContextsPerParent): unknown {
    const obj: any = {};
    if (message.childrenContexts?.length) {
      obj.childrenContexts = message.childrenContexts.map((e) => Context.toJSON(e));
    }
    return obj;
  },

  create<
    I extends Exact<
      DeepPartial<GetChildrenContextsByContextsResponse_ChildrenContextsPerParent>,
      I
    >,
  >(base?: I): GetChildrenContextsByContextsResponse_ChildrenContextsPerParent {
    return GetChildrenContextsByContextsResponse_ChildrenContextsPerParent.fromPartial(
      base ?? ({} as any),
    );
  },
  fromPartial<
    I extends Exact<
      DeepPartial<GetChildrenContextsByContextsResponse_ChildrenContextsPerParent>,
      I
    >,
  >(object: I): GetChildrenContextsByContextsResponse_ChildrenContextsPerParent {
    const message = createBaseGetChildrenContextsByContextsResponse_ChildrenContextsPerParent();
    message.childrenContexts = object.childrenContexts?.map((e) => Context.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetChildrenContextsByContextsResponse_ContextsEntry(): GetChildrenContextsByContextsResponse_ContextsEntry {
  return { key: 0, value: undefined };
}

export const GetChildrenContextsByContextsResponse_ContextsEntry = {
  encode(
    message: GetChildrenContextsByContextsResponse_ContextsEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== 0) {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      GetChildrenContextsByContextsResponse_ChildrenContextsPerParent.encode(
        message.value,
        writer.uint32(18).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): GetChildrenContextsByContextsResponse_ContextsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChildrenContextsByContextsResponse_ContextsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = GetChildrenContextsByContextsResponse_ChildrenContextsPerParent.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChildrenContextsByContextsResponse_ContextsEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value)
        ? GetChildrenContextsByContextsResponse_ChildrenContextsPerParent.fromJSON(object.value)
        : undefined,
    };
  },

  toJSON(message: GetChildrenContextsByContextsResponse_ContextsEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = GetChildrenContextsByContextsResponse_ChildrenContextsPerParent.toJSON(
        message.value,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChildrenContextsByContextsResponse_ContextsEntry>, I>>(
    base?: I,
  ): GetChildrenContextsByContextsResponse_ContextsEntry {
    return GetChildrenContextsByContextsResponse_ContextsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChildrenContextsByContextsResponse_ContextsEntry>, I>>(
    object: I,
  ): GetChildrenContextsByContextsResponse_ContextsEntry {
    const message = createBaseGetChildrenContextsByContextsResponse_ContextsEntry();
    message.key = object.key ?? 0;
    message.value =
      object.value !== undefined && object.value !== null
        ? GetChildrenContextsByContextsResponse_ChildrenContextsPerParent.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseGetArtifactsByContextRequest(): GetArtifactsByContextRequest {
  return { contextId: 0, options: undefined, transactionOptions: undefined };
}

export const GetArtifactsByContextRequest = {
  encode(
    message: GetArtifactsByContextRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.contextId !== undefined && message.contextId !== 0) {
      writer.uint32(8).int64(message.contextId);
    }
    if (message.options !== undefined) {
      ListOperationOptions.encode(message.options, writer.uint32(18).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactsByContextRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactsByContextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.contextId = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.options = ListOperationOptions.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactsByContextRequest {
    return {
      contextId: isSet(object.contextId) ? globalThis.Number(object.contextId) : 0,
      options: isSet(object.options) ? ListOperationOptions.fromJSON(object.options) : undefined,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetArtifactsByContextRequest): unknown {
    const obj: any = {};
    if (message.contextId !== undefined && message.contextId !== 0) {
      obj.contextId = Math.round(message.contextId);
    }
    if (message.options !== undefined) {
      obj.options = ListOperationOptions.toJSON(message.options);
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactsByContextRequest>, I>>(
    base?: I,
  ): GetArtifactsByContextRequest {
    return GetArtifactsByContextRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactsByContextRequest>, I>>(
    object: I,
  ): GetArtifactsByContextRequest {
    const message = createBaseGetArtifactsByContextRequest();
    message.contextId = object.contextId ?? 0;
    message.options =
      object.options !== undefined && object.options !== null
        ? ListOperationOptions.fromPartial(object.options)
        : undefined;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetArtifactsByContextResponse(): GetArtifactsByContextResponse {
  return { artifacts: [], nextPageToken: '' };
}

export const GetArtifactsByContextResponse = {
  encode(
    message: GetArtifactsByContextResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.artifacts) {
      Artifact.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactsByContextResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactsByContextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifacts.push(Artifact.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactsByContextResponse {
    return {
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => Artifact.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : '',
    };
  },

  toJSON(message: GetArtifactsByContextResponse): unknown {
    const obj: any = {};
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => Artifact.toJSON(e));
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtifactsByContextResponse>, I>>(
    base?: I,
  ): GetArtifactsByContextResponse {
    return GetArtifactsByContextResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtifactsByContextResponse>, I>>(
    object: I,
  ): GetArtifactsByContextResponse {
    const message = createBaseGetArtifactsByContextResponse();
    message.artifacts = object.artifacts?.map((e) => Artifact.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? '';
    return message;
  },
};

function createBaseGetExecutionsByContextRequest(): GetExecutionsByContextRequest {
  return { contextId: 0, options: undefined, transactionOptions: undefined };
}

export const GetExecutionsByContextRequest = {
  encode(
    message: GetExecutionsByContextRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.contextId !== undefined && message.contextId !== 0) {
      writer.uint32(8).int64(message.contextId);
    }
    if (message.options !== undefined) {
      ListOperationOptions.encode(message.options, writer.uint32(18).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionsByContextRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionsByContextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.contextId = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.options = ListOperationOptions.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionsByContextRequest {
    return {
      contextId: isSet(object.contextId) ? globalThis.Number(object.contextId) : 0,
      options: isSet(object.options) ? ListOperationOptions.fromJSON(object.options) : undefined,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetExecutionsByContextRequest): unknown {
    const obj: any = {};
    if (message.contextId !== undefined && message.contextId !== 0) {
      obj.contextId = Math.round(message.contextId);
    }
    if (message.options !== undefined) {
      obj.options = ListOperationOptions.toJSON(message.options);
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionsByContextRequest>, I>>(
    base?: I,
  ): GetExecutionsByContextRequest {
    return GetExecutionsByContextRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionsByContextRequest>, I>>(
    object: I,
  ): GetExecutionsByContextRequest {
    const message = createBaseGetExecutionsByContextRequest();
    message.contextId = object.contextId ?? 0;
    message.options =
      object.options !== undefined && object.options !== null
        ? ListOperationOptions.fromPartial(object.options)
        : undefined;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetExecutionsByContextResponse(): GetExecutionsByContextResponse {
  return { executions: [], nextPageToken: '', transactionOptions: undefined };
}

export const GetExecutionsByContextResponse = {
  encode(
    message: GetExecutionsByContextResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.executions) {
      Execution.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExecutionsByContextResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExecutionsByContextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.executions.push(Execution.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExecutionsByContextResponse {
    return {
      executions: globalThis.Array.isArray(object?.executions)
        ? object.executions.map((e: any) => Execution.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : '',
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetExecutionsByContextResponse): unknown {
    const obj: any = {};
    if (message.executions?.length) {
      obj.executions = message.executions.map((e) => Execution.toJSON(e));
    }
    if (message.nextPageToken !== undefined && message.nextPageToken !== '') {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExecutionsByContextResponse>, I>>(
    base?: I,
  ): GetExecutionsByContextResponse {
    return GetExecutionsByContextResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExecutionsByContextResponse>, I>>(
    object: I,
  ): GetExecutionsByContextResponse {
    const message = createBaseGetExecutionsByContextResponse();
    message.executions = object.executions?.map((e) => Execution.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? '';
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetLineageGraphRequest(): GetLineageGraphRequest {
  return { options: undefined, transactionOptions: undefined };
}

export const GetLineageGraphRequest = {
  encode(message: GetLineageGraphRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.options !== undefined) {
      LineageGraphQueryOptions.encode(message.options, writer.uint32(10).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetLineageGraphRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLineageGraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.options = LineageGraphQueryOptions.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLineageGraphRequest {
    return {
      options: isSet(object.options)
        ? LineageGraphQueryOptions.fromJSON(object.options)
        : undefined,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetLineageGraphRequest): unknown {
    const obj: any = {};
    if (message.options !== undefined) {
      obj.options = LineageGraphQueryOptions.toJSON(message.options);
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLineageGraphRequest>, I>>(
    base?: I,
  ): GetLineageGraphRequest {
    return GetLineageGraphRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLineageGraphRequest>, I>>(
    object: I,
  ): GetLineageGraphRequest {
    const message = createBaseGetLineageGraphRequest();
    message.options =
      object.options !== undefined && object.options !== null
        ? LineageGraphQueryOptions.fromPartial(object.options)
        : undefined;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetLineageGraphResponse(): GetLineageGraphResponse {
  return { subgraph: undefined };
}

export const GetLineageGraphResponse = {
  encode(message: GetLineageGraphResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subgraph !== undefined) {
      LineageGraph.encode(message.subgraph, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetLineageGraphResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLineageGraphResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subgraph = LineageGraph.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLineageGraphResponse {
    return {
      subgraph: isSet(object.subgraph) ? LineageGraph.fromJSON(object.subgraph) : undefined,
    };
  },

  toJSON(message: GetLineageGraphResponse): unknown {
    const obj: any = {};
    if (message.subgraph !== undefined) {
      obj.subgraph = LineageGraph.toJSON(message.subgraph);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLineageGraphResponse>, I>>(
    base?: I,
  ): GetLineageGraphResponse {
    return GetLineageGraphResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLineageGraphResponse>, I>>(
    object: I,
  ): GetLineageGraphResponse {
    const message = createBaseGetLineageGraphResponse();
    message.subgraph =
      object.subgraph !== undefined && object.subgraph !== null
        ? LineageGraph.fromPartial(object.subgraph)
        : undefined;
    return message;
  },
};

function createBaseGetLineageSubgraphRequest(): GetLineageSubgraphRequest {
  return {
    lineageSubgraphQueryOptions: undefined,
    readMask: undefined,
    transactionOptions: undefined,
  };
}

export const GetLineageSubgraphRequest = {
  encode(message: GetLineageSubgraphRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lineageSubgraphQueryOptions !== undefined) {
      LineageSubgraphQueryOptions.encode(
        message.lineageSubgraphQueryOptions,
        writer.uint32(10).fork(),
      ).ldelim();
    }
    if (message.readMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.readMask), writer.uint32(26).fork()).ldelim();
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetLineageSubgraphRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLineageSubgraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lineageSubgraphQueryOptions = LineageSubgraphQueryOptions.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.readMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLineageSubgraphRequest {
    return {
      lineageSubgraphQueryOptions: isSet(object.lineageSubgraphQueryOptions)
        ? LineageSubgraphQueryOptions.fromJSON(object.lineageSubgraphQueryOptions)
        : undefined,
      readMask: isSet(object.readMask)
        ? FieldMask.unwrap(FieldMask.fromJSON(object.readMask))
        : undefined,
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: GetLineageSubgraphRequest): unknown {
    const obj: any = {};
    if (message.lineageSubgraphQueryOptions !== undefined) {
      obj.lineageSubgraphQueryOptions = LineageSubgraphQueryOptions.toJSON(
        message.lineageSubgraphQueryOptions,
      );
    }
    if (message.readMask !== undefined) {
      obj.readMask = FieldMask.toJSON(FieldMask.wrap(message.readMask));
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLineageSubgraphRequest>, I>>(
    base?: I,
  ): GetLineageSubgraphRequest {
    return GetLineageSubgraphRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLineageSubgraphRequest>, I>>(
    object: I,
  ): GetLineageSubgraphRequest {
    const message = createBaseGetLineageSubgraphRequest();
    message.lineageSubgraphQueryOptions =
      object.lineageSubgraphQueryOptions !== undefined &&
      object.lineageSubgraphQueryOptions !== null
        ? LineageSubgraphQueryOptions.fromPartial(object.lineageSubgraphQueryOptions)
        : undefined;
    message.readMask = object.readMask ?? undefined;
    message.transactionOptions =
      object.transactionOptions !== undefined && object.transactionOptions !== null
        ? TransactionOptions.fromPartial(object.transactionOptions)
        : undefined;
    return message;
  },
};

function createBaseGetLineageSubgraphResponse(): GetLineageSubgraphResponse {
  return { lineageSubgraph: undefined };
}

export const GetLineageSubgraphResponse = {
  encode(
    message: GetLineageSubgraphResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.lineageSubgraph !== undefined) {
      LineageGraph.encode(message.lineageSubgraph, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetLineageSubgraphResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLineageSubgraphResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lineageSubgraph = LineageGraph.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLineageSubgraphResponse {
    return {
      lineageSubgraph: isSet(object.lineageSubgraph)
        ? LineageGraph.fromJSON(object.lineageSubgraph)
        : undefined,
    };
  },

  toJSON(message: GetLineageSubgraphResponse): unknown {
    const obj: any = {};
    if (message.lineageSubgraph !== undefined) {
      obj.lineageSubgraph = LineageGraph.toJSON(message.lineageSubgraph);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLineageSubgraphResponse>, I>>(
    base?: I,
  ): GetLineageSubgraphResponse {
    return GetLineageSubgraphResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLineageSubgraphResponse>, I>>(
    object: I,
  ): GetLineageSubgraphResponse {
    const message = createBaseGetLineageSubgraphResponse();
    message.lineageSubgraph =
      object.lineageSubgraph !== undefined && object.lineageSubgraph !== null
        ? LineageGraph.fromPartial(object.lineageSubgraph)
        : undefined;
    return message;
  },
};

/** LINT.IfChange */
export interface MetadataStoreService {
  /**
   * Inserts or updates an ArtifactType.
   *
   * A type has a set of strong typed properties describing the schema of any
   * stored instance associated with that type. A type is identified by a name
   * and an optional version.
   *
   * Type Creation:
   * If no type exists in the database with the given identifier
   * (name, version), it creates a new type and returns the type_id.
   *
   * Type Evolution:
   * If the request type with the same (name, version) already exists
   * (let's call it stored_type), the method enforces the stored_type can be
   * updated only when the request type is backward compatible for the already
   * stored instances.
   *
   * Backwards compatibility is violated iff:
   *
   *   a) there is a property where the request type and stored_type have
   *      different value type (e.g., int vs. string)
   *   b) `can_add_fields = false` and the request type has a new property that
   *      is not stored.
   *   c) `can_omit_fields = false` and stored_type has an existing property
   *      that is not provided in the request type.
   *
   * If non-backward type change is required in the application, e.g.,
   * deprecate properties, re-purpose property name, change value types,
   * a new type can be created with a different (name, version) identifier.
   * Note the type version is optional, and a version value with empty string
   * is treated as unset.
   *
   * Args:
   *   artifact_type: the type to be inserted or updated.
   *   can_add_fields:
   *     when set to true, new properties can be added;
   *     when set to false, returns ALREADY_EXISTS if the request type has
   *     properties that are not in stored_type.
   *   can_omit_fields:
   *     when set to true, stored properties can be omitted in the request type;
   *     when set to false, returns ALREADY_EXISTS if the stored_type has
   *     properties not in the request type.
   *
   * Returns:
   *   The type_id of the stored type.
   *
   * Raises:
   *   ALREADY_EXISTS error in the case listed above.
   *   INVALID_ARGUMENT error, if the given type has no name, or any
   *     property value type is unknown.
   */
  PutArtifactType(request: PutArtifactTypeRequest): Promise<PutArtifactTypeResponse>;
  /**
   * Inserts or updates an ExecutionType. Please refer to PutArtifactType for
   * type upsert API description.
   */
  PutExecutionType(request: PutExecutionTypeRequest): Promise<PutExecutionTypeResponse>;
  /**
   * Inserts or updates an ContextType. Please refer to PutArtifactType for
   * type upsert API description.
   */
  PutContextType(request: PutContextTypeRequest): Promise<PutContextTypeResponse>;
  /** Bulk inserts types atomically. */
  PutTypes(request: PutTypesRequest): Promise<PutTypesResponse>;
  /**
   * Inserts or updates artifacts in the database.
   *
   * If an artifact_id is specified for an artifact, it is an update.
   * If an artifact_id is unspecified, it will insert a new artifact.
   * For new artifacts, type must be specified.
   * For old artifacts, type must be unchanged or unspecified.
   *
   * It is not guaranteed that the created or updated artifacts will share the
   * same `create_time_since_epoch` or `last_update_time_since_epoch`
   * timestamps.
   *
   * Args:
   *   artifacts: A list of artifacts to insert or update.
   *
   * Returns:
   *   A list of artifact ids index-aligned with the input.
   */
  PutArtifacts(request: PutArtifactsRequest): Promise<PutArtifactsResponse>;
  /**
   * Inserts or updates executions in the database.
   *
   * If an execution_id is specified for an execution, it is an update.
   * If an execution_id is unspecified, it will insert a new execution.
   * For new executions, type must be specified.
   * For old executions, type must be unchanged or unspecified.
   *
   * It is not guaranteed that the created or updated executions will share the
   * same `create_time_since_epoch` or `last_update_time_since_epoch`
   * timestamps.
   *
   * Args:
   *   executions: A list of executions to insert or update.
   *
   * Returns:
   *   A list of execution ids index-aligned with the input.
   */
  PutExecutions(request: PutExecutionsRequest): Promise<PutExecutionsResponse>;
  /**
   * Inserts events in the database.
   *
   * The execution_id and artifact_id must already exist.
   * Once created, events cannot be modified.
   * AlreadyExists error will be raised if duplicated events are found.
   *
   * It is not guaranteed that the created or updated events will share the
   * same `milliseconds_since_epoch` timestamps.
   *
   * Args:
   *   events: A list of events to insert or update.
   */
  PutEvents(request: PutEventsRequest): Promise<PutEventsResponse>;
  /**
   * Inserts or updates an Execution and its input and output artifacts and
   * related contexts atomically. The `artifact_event_pairs` include the state
   * changes of the Artifacts used or generated by the Execution, as well as the
   * input/output Event. The `contexts` describe the associations of the
   * execution and the attributions of the artifacts.
   *
   * If an execution_id is specified, it is an update on the corresponding
   * execution, otherwise it does an insertion.
   * For insertion, type must be specified. Same rule applies to artifacts
   * and contexts in the request. Corresponding errors may raised. For example:
   * AlreadyExists error will be raised if duplicated executions, artifacts
   * or events are found.
   *
   * It is not guaranteed that the created or updated executions, artifacts,
   * contexts and events will share the same `create_time_since_epoch`,
   * `last_update_time_since_epoch`, or `milliseconds_since_epoch` timestamps.
   *
   * Args:
   *   execution: An execution to insert or update.
   *   artifact_event_pairs: Artifacts to insert or update and events to insert.
   *   contexts: The contexts that the execution and the artifacts belong to.
   *
   * Returns:
   *   An execution id and a list of artifacts and contexts ids index-aligned
   *   with the input.
   */
  PutExecution(request: PutExecutionRequest): Promise<PutExecutionResponse>;
  /**
   * Inserts or updates a lineage subgraph (i.e. a collection of event edges
   * and its executions, artifacts, and related contexts) atomically. The
   * `event_edges` include an Event and the indices of the corresponding
   * execution and artifact from the input list of executions and artifacts. The
   * `contexts` describe the associations of the Execution and the attributions
   * of the Artifact.
   *
   * If an execution_id is specified, it is an update on the corresponding
   * Execution, otherwise it does an insertion. For insertion, type must be
   * specified. These rules apply to Artifacts and Contexts as well.
   * Corresponding errors may be raised. For example: AlreadyExists error will
   * be raised if duplicated executions, artifacts, or events are found.
   *
   * It is not guaranteed that the created or updated executions, artifacts,
   * contexts and events will share the same `create_time_since_epoch`,
   * `last_update_time_since_epoch`, or `milliseconds_since_epoch` timestamps.
   *
   * Args:
   *   executions: A list of executions to insert or update.
   *   artifacts: A list of artifacts to insert or update.
   *   contexts: A list of contexts to insert and/or create associations and
   *       attributions with.
   *   event_edges: A list of events to insert with the indices of the
   *       corresponding execution and artifact from the input lists of
   *       executions and artifacts.
   *
   * Returns:
   *   Lists of execution, artifact, and context ids index-aligned with the
   *   inputs.
   */
  PutLineageSubgraph(request: PutLineageSubgraphRequest): Promise<PutLineageSubgraphResponse>;
  /**
   * Inserts or updates contexts in database and returns a list of context ids.
   *
   * If an context_id is specified for a context, it is an update.
   * If an context_id is unspecified, it will insert a new context.
   * For new contexts, type must be specified.
   * For old contexts, type must be unchanged or unspecified.
   *
   * It is not guaranteed that the created or updated contexts will share the
   * same `create_time_since_epoch` or `last_update_time_since_epoch`
   * timestamps.
   *
   * Args:
   *   contexts: A list of contexts to insert or update.
   *
   * Returns:
   *   A list of context ids index-aligned with the input.
   */
  PutContexts(request: PutContextsRequest): Promise<PutContextsResponse>;
  /**
   * Inserts attribution and association relationships in the database.
   * The context_id, artifact_id, and execution_id must already exist.
   * If the relationship exists, this call does nothing. Once added, the
   * relationships cannot be modified.
   *
   * Args:
   *   attributions: A list of attributions to insert.
   *   associations: A list of associations to insert.
   */
  PutAttributionsAndAssociations(
    request: PutAttributionsAndAssociationsRequest,
  ): Promise<PutAttributionsAndAssociationsResponse>;
  /**
   * Inserts parental context relationships in the database.
   * The ParentContext relationship has direction. The call fails if cycles are
   * detected.
   *
   * Args:
   *   parent_contexts: A list of parent contexts to insert.
   */
  PutParentContexts(request: PutParentContextsRequest): Promise<PutParentContextsResponse>;
  /**
   * Gets an artifact type. Returns a NOT_FOUND error if the type does not
   * exist.
   */
  GetArtifactType(request: GetArtifactTypeRequest): Promise<GetArtifactTypeResponse>;
  /**
   * Gets a list of artifact types by ID.
   * If no artifact types with an ID exists, the artifact type is skipped.
   */
  GetArtifactTypesByID(request: GetArtifactTypesByIDRequest): Promise<GetArtifactTypesByIDResponse>;
  /** Gets a list of all artifact types. */
  GetArtifactTypes(request: GetArtifactTypesRequest): Promise<GetArtifactTypesResponse>;
  /** Gets an execution type, or None if it does not exist. */
  GetExecutionType(request: GetExecutionTypeRequest): Promise<GetExecutionTypeResponse>;
  /**
   * Gets a list of execution types by ID.
   * If no execution types with an ID exists, the execution type is skipped.
   */
  GetExecutionTypesByID(
    request: GetExecutionTypesByIDRequest,
  ): Promise<GetExecutionTypesByIDResponse>;
  /** Gets a list of all execution types. */
  GetExecutionTypes(request: GetExecutionTypesRequest): Promise<GetExecutionTypesResponse>;
  /** Gets a context type. Returns a NOT_FOUND error if the type does not exist. */
  GetContextType(request: GetContextTypeRequest): Promise<GetContextTypeResponse>;
  /**
   * Gets a list of context types by ID.
   * If no context types with an ID exists, the context type is skipped.
   */
  GetContextTypesByID(request: GetContextTypesByIDRequest): Promise<GetContextTypesByIDResponse>;
  /** Gets a list of all context types. */
  GetContextTypes(request: GetContextTypesRequest): Promise<GetContextTypesResponse>;
  /** Gets all the artifacts. */
  GetArtifacts(request: GetArtifactsRequest): Promise<GetArtifactsResponse>;
  /** Gets all the executions. */
  GetExecutions(request: GetExecutionsRequest): Promise<GetExecutionsResponse>;
  /** Gets all the contexts. */
  GetContexts(request: GetContextsRequest): Promise<GetContextsResponse>;
  /**
   * Gets all artifacts with matching ids.
   *
   * The result is not index-aligned: if an id is not found, it is not returned.
   *
   * Args:
   *   artifact_ids: A list of artifact ids to retrieve.
   *
   * Returns:
   *   Artifacts with matching ids.
   */
  GetArtifactsByID(request: GetArtifactsByIDRequest): Promise<GetArtifactsByIDResponse>;
  /**
   * Gets all executions with matching ids.
   *
   * The result is not index-aligned: if an id is not found, it is not returned.
   *
   * Args:
   *   execution_ids: A list of execution ids to retrieve.
   */
  GetExecutionsByID(request: GetExecutionsByIDRequest): Promise<GetExecutionsByIDResponse>;
  /**
   * Gets all contexts with matching ids.
   *
   * The result is not index-aligned: if an id is not found, it is not returned.
   *
   * Args:
   *   context_ids: A list of context ids to retrieve.
   */
  GetContextsByID(request: GetContextsByIDRequest): Promise<GetContextsByIDResponse>;
  /** Gets all the artifacts of a given type. */
  GetArtifactsByType(request: GetArtifactsByTypeRequest): Promise<GetArtifactsByTypeResponse>;
  /** Gets all the executions of a given type. */
  GetExecutionsByType(request: GetExecutionsByTypeRequest): Promise<GetExecutionsByTypeResponse>;
  /** Gets all the contexts of a given type. */
  GetContextsByType(request: GetContextsByTypeRequest): Promise<GetContextsByTypeResponse>;
  /** Gets the artifact of the given type and artifact name. */
  GetArtifactByTypeAndName(
    request: GetArtifactByTypeAndNameRequest,
  ): Promise<GetArtifactByTypeAndNameResponse>;
  /** Gets the execution of the given type and execution name. */
  GetExecutionByTypeAndName(
    request: GetExecutionByTypeAndNameRequest,
  ): Promise<GetExecutionByTypeAndNameResponse>;
  /** Gets the context of the given type and context name. */
  GetContextByTypeAndName(
    request: GetContextByTypeAndNameRequest,
  ): Promise<GetContextByTypeAndNameResponse>;
  /** Gets all the artifacts with matching uris. */
  GetArtifactsByURI(request: GetArtifactsByURIRequest): Promise<GetArtifactsByURIResponse>;
  /** Gets all events with matching execution ids. */
  GetEventsByExecutionIDs(
    request: GetEventsByExecutionIDsRequest,
  ): Promise<GetEventsByExecutionIDsResponse>;
  /** Gets all events with matching artifact ids. */
  GetEventsByArtifactIDs(
    request: GetEventsByArtifactIDsRequest,
  ): Promise<GetEventsByArtifactIDsResponse>;
  /** Gets all the artifacts with matching external ids. */
  GetArtifactsByExternalIds(
    request: GetArtifactsByExternalIdsRequest,
  ): Promise<GetArtifactsByExternalIdsResponse>;
  /** Gets all the artifacts with matching external ids. */
  GetExecutionsByExternalIds(
    request: GetExecutionsByExternalIdsRequest,
  ): Promise<GetExecutionsByExternalIdsResponse>;
  /** Gets all the artifacts with matching external ids. */
  GetContextsByExternalIds(
    request: GetContextsByExternalIdsRequest,
  ): Promise<GetContextsByExternalIdsResponse>;
  /** Gets all the artifacts with matching external ids. */
  GetArtifactTypesByExternalIds(
    request: GetArtifactTypesByExternalIdsRequest,
  ): Promise<GetArtifactTypesByExternalIdsResponse>;
  /** Gets all the artifacts with matching external ids. */
  GetExecutionTypesByExternalIds(
    request: GetExecutionTypesByExternalIdsRequest,
  ): Promise<GetExecutionTypesByExternalIdsResponse>;
  /** Gets all the artifacts with matching external ids. */
  GetContextTypesByExternalIds(
    request: GetContextTypesByExternalIdsRequest,
  ): Promise<GetContextTypesByExternalIdsResponse>;
  /** Gets all context that an artifact is attributed to. */
  GetContextsByArtifact(
    request: GetContextsByArtifactRequest,
  ): Promise<GetContextsByArtifactResponse>;
  /** Gets all context that an execution is associated with. */
  GetContextsByExecution(
    request: GetContextsByExecutionRequest,
  ): Promise<GetContextsByExecutionResponse>;
  /** Gets all parent contexts that a context is related. */
  GetParentContextsByContext(
    request: GetParentContextsByContextRequest,
  ): Promise<GetParentContextsByContextResponse>;
  /** Gets all children contexts that a context is related. */
  GetChildrenContextsByContext(
    request: GetChildrenContextsByContextRequest,
  ): Promise<GetChildrenContextsByContextResponse>;
  /** Batch getting all the parent contexts that a list of contexts are related. */
  GetParentContextsByContexts(
    request: GetParentContextsByContextsRequest,
  ): Promise<GetParentContextsByContextsResponse>;
  /**
   * Batch getting all the children contexts that a list of contexts are
   * related.
   */
  GetChildrenContextsByContexts(
    request: GetChildrenContextsByContextsRequest,
  ): Promise<GetChildrenContextsByContextsResponse>;
  /** Gets all direct artifacts that a context attributes to. */
  GetArtifactsByContext(
    request: GetArtifactsByContextRequest,
  ): Promise<GetArtifactsByContextResponse>;
  /** Gets all direct executions that a context associates with. */
  GetExecutionsByContext(
    request: GetExecutionsByContextRequest,
  ): Promise<GetExecutionsByContextResponse>;
  /**
   * TODO(b/283852485): Deprecate GetLineageGraph API after migration to
   * GetLineageSubgraph API.
   * The transaction performs a constrained transitive closure and returns a
   * lineage subgraph satisfying the conditions and constraints specified in
   * the GetLineageGraphRequest.
   */
  GetLineageGraph(request: GetLineageGraphRequest): Promise<GetLineageGraphResponse>;
  /**
   * Gets a lineage subgraph by performing graph traversal from a list of
   * interested nodes.
   * A lineage subgraph without node details (e.g., external_id, properties)
   * will be returned.
   */
  GetLineageSubgraph(request: GetLineageSubgraphRequest): Promise<GetLineageSubgraphResponse>;
}

export const MetadataStoreServiceServiceName = 'ml_metadata.MetadataStoreService';
export class MetadataStoreServiceClientImpl implements MetadataStoreService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MetadataStoreServiceServiceName;
    this.rpc = rpc;
    this.PutArtifactType = this.PutArtifactType.bind(this);
    this.PutExecutionType = this.PutExecutionType.bind(this);
    this.PutContextType = this.PutContextType.bind(this);
    this.PutTypes = this.PutTypes.bind(this);
    this.PutArtifacts = this.PutArtifacts.bind(this);
    this.PutExecutions = this.PutExecutions.bind(this);
    this.PutEvents = this.PutEvents.bind(this);
    this.PutExecution = this.PutExecution.bind(this);
    this.PutLineageSubgraph = this.PutLineageSubgraph.bind(this);
    this.PutContexts = this.PutContexts.bind(this);
    this.PutAttributionsAndAssociations = this.PutAttributionsAndAssociations.bind(this);
    this.PutParentContexts = this.PutParentContexts.bind(this);
    this.GetArtifactType = this.GetArtifactType.bind(this);
    this.GetArtifactTypesByID = this.GetArtifactTypesByID.bind(this);
    this.GetArtifactTypes = this.GetArtifactTypes.bind(this);
    this.GetExecutionType = this.GetExecutionType.bind(this);
    this.GetExecutionTypesByID = this.GetExecutionTypesByID.bind(this);
    this.GetExecutionTypes = this.GetExecutionTypes.bind(this);
    this.GetContextType = this.GetContextType.bind(this);
    this.GetContextTypesByID = this.GetContextTypesByID.bind(this);
    this.GetContextTypes = this.GetContextTypes.bind(this);
    this.GetArtifacts = this.GetArtifacts.bind(this);
    this.GetExecutions = this.GetExecutions.bind(this);
    this.GetContexts = this.GetContexts.bind(this);
    this.GetArtifactsByID = this.GetArtifactsByID.bind(this);
    this.GetExecutionsByID = this.GetExecutionsByID.bind(this);
    this.GetContextsByID = this.GetContextsByID.bind(this);
    this.GetArtifactsByType = this.GetArtifactsByType.bind(this);
    this.GetExecutionsByType = this.GetExecutionsByType.bind(this);
    this.GetContextsByType = this.GetContextsByType.bind(this);
    this.GetArtifactByTypeAndName = this.GetArtifactByTypeAndName.bind(this);
    this.GetExecutionByTypeAndName = this.GetExecutionByTypeAndName.bind(this);
    this.GetContextByTypeAndName = this.GetContextByTypeAndName.bind(this);
    this.GetArtifactsByURI = this.GetArtifactsByURI.bind(this);
    this.GetEventsByExecutionIDs = this.GetEventsByExecutionIDs.bind(this);
    this.GetEventsByArtifactIDs = this.GetEventsByArtifactIDs.bind(this);
    this.GetArtifactsByExternalIds = this.GetArtifactsByExternalIds.bind(this);
    this.GetExecutionsByExternalIds = this.GetExecutionsByExternalIds.bind(this);
    this.GetContextsByExternalIds = this.GetContextsByExternalIds.bind(this);
    this.GetArtifactTypesByExternalIds = this.GetArtifactTypesByExternalIds.bind(this);
    this.GetExecutionTypesByExternalIds = this.GetExecutionTypesByExternalIds.bind(this);
    this.GetContextTypesByExternalIds = this.GetContextTypesByExternalIds.bind(this);
    this.GetContextsByArtifact = this.GetContextsByArtifact.bind(this);
    this.GetContextsByExecution = this.GetContextsByExecution.bind(this);
    this.GetParentContextsByContext = this.GetParentContextsByContext.bind(this);
    this.GetChildrenContextsByContext = this.GetChildrenContextsByContext.bind(this);
    this.GetParentContextsByContexts = this.GetParentContextsByContexts.bind(this);
    this.GetChildrenContextsByContexts = this.GetChildrenContextsByContexts.bind(this);
    this.GetArtifactsByContext = this.GetArtifactsByContext.bind(this);
    this.GetExecutionsByContext = this.GetExecutionsByContext.bind(this);
    this.GetLineageGraph = this.GetLineageGraph.bind(this);
    this.GetLineageSubgraph = this.GetLineageSubgraph.bind(this);
  }
  PutArtifactType(request: PutArtifactTypeRequest): Promise<PutArtifactTypeResponse> {
    const data = PutArtifactTypeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'PutArtifactType', data);
    return promise.then((data) => PutArtifactTypeResponse.decode(_m0.Reader.create(data)));
  }

  PutExecutionType(request: PutExecutionTypeRequest): Promise<PutExecutionTypeResponse> {
    const data = PutExecutionTypeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'PutExecutionType', data);
    return promise.then((data) => PutExecutionTypeResponse.decode(_m0.Reader.create(data)));
  }

  PutContextType(request: PutContextTypeRequest): Promise<PutContextTypeResponse> {
    const data = PutContextTypeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'PutContextType', data);
    return promise.then((data) => PutContextTypeResponse.decode(_m0.Reader.create(data)));
  }

  PutTypes(request: PutTypesRequest): Promise<PutTypesResponse> {
    const data = PutTypesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'PutTypes', data);
    return promise.then((data) => PutTypesResponse.decode(_m0.Reader.create(data)));
  }

  PutArtifacts(request: PutArtifactsRequest): Promise<PutArtifactsResponse> {
    const data = PutArtifactsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'PutArtifacts', data);
    return promise.then((data) => PutArtifactsResponse.decode(_m0.Reader.create(data)));
  }

  PutExecutions(request: PutExecutionsRequest): Promise<PutExecutionsResponse> {
    const data = PutExecutionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'PutExecutions', data);
    return promise.then((data) => PutExecutionsResponse.decode(_m0.Reader.create(data)));
  }

  PutEvents(request: PutEventsRequest): Promise<PutEventsResponse> {
    const data = PutEventsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'PutEvents', data);
    return promise.then((data) => PutEventsResponse.decode(_m0.Reader.create(data)));
  }

  PutExecution(request: PutExecutionRequest): Promise<PutExecutionResponse> {
    const data = PutExecutionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'PutExecution', data);
    return promise.then((data) => PutExecutionResponse.decode(_m0.Reader.create(data)));
  }

  PutLineageSubgraph(request: PutLineageSubgraphRequest): Promise<PutLineageSubgraphResponse> {
    const data = PutLineageSubgraphRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'PutLineageSubgraph', data);
    return promise.then((data) => PutLineageSubgraphResponse.decode(_m0.Reader.create(data)));
  }

  PutContexts(request: PutContextsRequest): Promise<PutContextsResponse> {
    const data = PutContextsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'PutContexts', data);
    return promise.then((data) => PutContextsResponse.decode(_m0.Reader.create(data)));
  }

  PutAttributionsAndAssociations(
    request: PutAttributionsAndAssociationsRequest,
  ): Promise<PutAttributionsAndAssociationsResponse> {
    const data = PutAttributionsAndAssociationsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'PutAttributionsAndAssociations', data);
    return promise.then((data) =>
      PutAttributionsAndAssociationsResponse.decode(_m0.Reader.create(data)),
    );
  }

  PutParentContexts(request: PutParentContextsRequest): Promise<PutParentContextsResponse> {
    const data = PutParentContextsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'PutParentContexts', data);
    return promise.then((data) => PutParentContextsResponse.decode(_m0.Reader.create(data)));
  }

  GetArtifactType(request: GetArtifactTypeRequest): Promise<GetArtifactTypeResponse> {
    const data = GetArtifactTypeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetArtifactType', data);
    return promise.then((data) => GetArtifactTypeResponse.decode(_m0.Reader.create(data)));
  }

  GetArtifactTypesByID(
    request: GetArtifactTypesByIDRequest,
  ): Promise<GetArtifactTypesByIDResponse> {
    const data = GetArtifactTypesByIDRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetArtifactTypesByID', data);
    return promise.then((data) => GetArtifactTypesByIDResponse.decode(_m0.Reader.create(data)));
  }

  GetArtifactTypes(request: GetArtifactTypesRequest): Promise<GetArtifactTypesResponse> {
    const data = GetArtifactTypesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetArtifactTypes', data);
    return promise.then((data) => GetArtifactTypesResponse.decode(_m0.Reader.create(data)));
  }

  GetExecutionType(request: GetExecutionTypeRequest): Promise<GetExecutionTypeResponse> {
    const data = GetExecutionTypeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetExecutionType', data);
    return promise.then((data) => GetExecutionTypeResponse.decode(_m0.Reader.create(data)));
  }

  GetExecutionTypesByID(
    request: GetExecutionTypesByIDRequest,
  ): Promise<GetExecutionTypesByIDResponse> {
    const data = GetExecutionTypesByIDRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetExecutionTypesByID', data);
    return promise.then((data) => GetExecutionTypesByIDResponse.decode(_m0.Reader.create(data)));
  }

  GetExecutionTypes(request: GetExecutionTypesRequest): Promise<GetExecutionTypesResponse> {
    const data = GetExecutionTypesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetExecutionTypes', data);
    return promise.then((data) => GetExecutionTypesResponse.decode(_m0.Reader.create(data)));
  }

  GetContextType(request: GetContextTypeRequest): Promise<GetContextTypeResponse> {
    const data = GetContextTypeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetContextType', data);
    return promise.then((data) => GetContextTypeResponse.decode(_m0.Reader.create(data)));
  }

  GetContextTypesByID(request: GetContextTypesByIDRequest): Promise<GetContextTypesByIDResponse> {
    const data = GetContextTypesByIDRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetContextTypesByID', data);
    return promise.then((data) => GetContextTypesByIDResponse.decode(_m0.Reader.create(data)));
  }

  GetContextTypes(request: GetContextTypesRequest): Promise<GetContextTypesResponse> {
    const data = GetContextTypesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetContextTypes', data);
    return promise.then((data) => GetContextTypesResponse.decode(_m0.Reader.create(data)));
  }

  GetArtifacts(request: GetArtifactsRequest): Promise<GetArtifactsResponse> {
    const data = GetArtifactsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetArtifacts', data);
    return promise.then((data) => GetArtifactsResponse.decode(_m0.Reader.create(data)));
  }

  GetExecutions(request: GetExecutionsRequest): Promise<GetExecutionsResponse> {
    const data = GetExecutionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetExecutions', data);
    return promise.then((data) => GetExecutionsResponse.decode(_m0.Reader.create(data)));
  }

  GetContexts(request: GetContextsRequest): Promise<GetContextsResponse> {
    const data = GetContextsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetContexts', data);
    return promise.then((data) => GetContextsResponse.decode(_m0.Reader.create(data)));
  }

  GetArtifactsByID(request: GetArtifactsByIDRequest): Promise<GetArtifactsByIDResponse> {
    const data = GetArtifactsByIDRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetArtifactsByID', data);
    return promise.then((data) => GetArtifactsByIDResponse.decode(_m0.Reader.create(data)));
  }

  GetExecutionsByID(request: GetExecutionsByIDRequest): Promise<GetExecutionsByIDResponse> {
    const data = GetExecutionsByIDRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetExecutionsByID', data);
    return promise.then((data) => GetExecutionsByIDResponse.decode(_m0.Reader.create(data)));
  }

  GetContextsByID(request: GetContextsByIDRequest): Promise<GetContextsByIDResponse> {
    const data = GetContextsByIDRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetContextsByID', data);
    return promise.then((data) => GetContextsByIDResponse.decode(_m0.Reader.create(data)));
  }

  GetArtifactsByType(request: GetArtifactsByTypeRequest): Promise<GetArtifactsByTypeResponse> {
    const data = GetArtifactsByTypeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetArtifactsByType', data);
    return promise.then((data) => GetArtifactsByTypeResponse.decode(_m0.Reader.create(data)));
  }

  GetExecutionsByType(request: GetExecutionsByTypeRequest): Promise<GetExecutionsByTypeResponse> {
    const data = GetExecutionsByTypeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetExecutionsByType', data);
    return promise.then((data) => GetExecutionsByTypeResponse.decode(_m0.Reader.create(data)));
  }

  GetContextsByType(request: GetContextsByTypeRequest): Promise<GetContextsByTypeResponse> {
    const data = GetContextsByTypeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetContextsByType', data);
    return promise.then((data) => GetContextsByTypeResponse.decode(_m0.Reader.create(data)));
  }

  GetArtifactByTypeAndName(
    request: GetArtifactByTypeAndNameRequest,
  ): Promise<GetArtifactByTypeAndNameResponse> {
    const data = GetArtifactByTypeAndNameRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetArtifactByTypeAndName', data);
    return promise.then((data) => GetArtifactByTypeAndNameResponse.decode(_m0.Reader.create(data)));
  }

  GetExecutionByTypeAndName(
    request: GetExecutionByTypeAndNameRequest,
  ): Promise<GetExecutionByTypeAndNameResponse> {
    const data = GetExecutionByTypeAndNameRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetExecutionByTypeAndName', data);
    return promise.then((data) =>
      GetExecutionByTypeAndNameResponse.decode(_m0.Reader.create(data)),
    );
  }

  GetContextByTypeAndName(
    request: GetContextByTypeAndNameRequest,
  ): Promise<GetContextByTypeAndNameResponse> {
    const data = GetContextByTypeAndNameRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetContextByTypeAndName', data);
    return promise.then((data) => GetContextByTypeAndNameResponse.decode(_m0.Reader.create(data)));
  }

  GetArtifactsByURI(request: GetArtifactsByURIRequest): Promise<GetArtifactsByURIResponse> {
    const data = GetArtifactsByURIRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetArtifactsByURI', data);
    return promise.then((data) => GetArtifactsByURIResponse.decode(_m0.Reader.create(data)));
  }

  GetEventsByExecutionIDs(
    request: GetEventsByExecutionIDsRequest,
  ): Promise<GetEventsByExecutionIDsResponse> {
    const data = GetEventsByExecutionIDsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetEventsByExecutionIDs', data);
    return promise.then((data) => GetEventsByExecutionIDsResponse.decode(_m0.Reader.create(data)));
  }

  GetEventsByArtifactIDs(
    request: GetEventsByArtifactIDsRequest,
  ): Promise<GetEventsByArtifactIDsResponse> {
    const data = GetEventsByArtifactIDsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetEventsByArtifactIDs', data);
    return promise.then((data) => GetEventsByArtifactIDsResponse.decode(_m0.Reader.create(data)));
  }

  GetArtifactsByExternalIds(
    request: GetArtifactsByExternalIdsRequest,
  ): Promise<GetArtifactsByExternalIdsResponse> {
    const data = GetArtifactsByExternalIdsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetArtifactsByExternalIds', data);
    return promise.then((data) =>
      GetArtifactsByExternalIdsResponse.decode(_m0.Reader.create(data)),
    );
  }

  GetExecutionsByExternalIds(
    request: GetExecutionsByExternalIdsRequest,
  ): Promise<GetExecutionsByExternalIdsResponse> {
    const data = GetExecutionsByExternalIdsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetExecutionsByExternalIds', data);
    return promise.then((data) =>
      GetExecutionsByExternalIdsResponse.decode(_m0.Reader.create(data)),
    );
  }

  GetContextsByExternalIds(
    request: GetContextsByExternalIdsRequest,
  ): Promise<GetContextsByExternalIdsResponse> {
    const data = GetContextsByExternalIdsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetContextsByExternalIds', data);
    return promise.then((data) => GetContextsByExternalIdsResponse.decode(_m0.Reader.create(data)));
  }

  GetArtifactTypesByExternalIds(
    request: GetArtifactTypesByExternalIdsRequest,
  ): Promise<GetArtifactTypesByExternalIdsResponse> {
    const data = GetArtifactTypesByExternalIdsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetArtifactTypesByExternalIds', data);
    return promise.then((data) =>
      GetArtifactTypesByExternalIdsResponse.decode(_m0.Reader.create(data)),
    );
  }

  GetExecutionTypesByExternalIds(
    request: GetExecutionTypesByExternalIdsRequest,
  ): Promise<GetExecutionTypesByExternalIdsResponse> {
    const data = GetExecutionTypesByExternalIdsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetExecutionTypesByExternalIds', data);
    return promise.then((data) =>
      GetExecutionTypesByExternalIdsResponse.decode(_m0.Reader.create(data)),
    );
  }

  GetContextTypesByExternalIds(
    request: GetContextTypesByExternalIdsRequest,
  ): Promise<GetContextTypesByExternalIdsResponse> {
    const data = GetContextTypesByExternalIdsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetContextTypesByExternalIds', data);
    return promise.then((data) =>
      GetContextTypesByExternalIdsResponse.decode(_m0.Reader.create(data)),
    );
  }

  GetContextsByArtifact(
    request: GetContextsByArtifactRequest,
  ): Promise<GetContextsByArtifactResponse> {
    const data = GetContextsByArtifactRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetContextsByArtifact', data);
    return promise.then((data) => GetContextsByArtifactResponse.decode(_m0.Reader.create(data)));
  }

  GetContextsByExecution(
    request: GetContextsByExecutionRequest,
  ): Promise<GetContextsByExecutionResponse> {
    const data = GetContextsByExecutionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetContextsByExecution', data);
    return promise.then((data) => GetContextsByExecutionResponse.decode(_m0.Reader.create(data)));
  }

  GetParentContextsByContext(
    request: GetParentContextsByContextRequest,
  ): Promise<GetParentContextsByContextResponse> {
    const data = GetParentContextsByContextRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetParentContextsByContext', data);
    return promise.then((data) =>
      GetParentContextsByContextResponse.decode(_m0.Reader.create(data)),
    );
  }

  GetChildrenContextsByContext(
    request: GetChildrenContextsByContextRequest,
  ): Promise<GetChildrenContextsByContextResponse> {
    const data = GetChildrenContextsByContextRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetChildrenContextsByContext', data);
    return promise.then((data) =>
      GetChildrenContextsByContextResponse.decode(_m0.Reader.create(data)),
    );
  }

  GetParentContextsByContexts(
    request: GetParentContextsByContextsRequest,
  ): Promise<GetParentContextsByContextsResponse> {
    const data = GetParentContextsByContextsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetParentContextsByContexts', data);
    return promise.then((data) =>
      GetParentContextsByContextsResponse.decode(_m0.Reader.create(data)),
    );
  }

  GetChildrenContextsByContexts(
    request: GetChildrenContextsByContextsRequest,
  ): Promise<GetChildrenContextsByContextsResponse> {
    const data = GetChildrenContextsByContextsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetChildrenContextsByContexts', data);
    return promise.then((data) =>
      GetChildrenContextsByContextsResponse.decode(_m0.Reader.create(data)),
    );
  }

  GetArtifactsByContext(
    request: GetArtifactsByContextRequest,
  ): Promise<GetArtifactsByContextResponse> {
    const data = GetArtifactsByContextRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetArtifactsByContext', data);
    return promise.then((data) => GetArtifactsByContextResponse.decode(_m0.Reader.create(data)));
  }

  GetExecutionsByContext(
    request: GetExecutionsByContextRequest,
  ): Promise<GetExecutionsByContextResponse> {
    const data = GetExecutionsByContextRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetExecutionsByContext', data);
    return promise.then((data) => GetExecutionsByContextResponse.decode(_m0.Reader.create(data)));
  }

  GetLineageGraph(request: GetLineageGraphRequest): Promise<GetLineageGraphResponse> {
    const data = GetLineageGraphRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetLineageGraph', data);
    return promise.then((data) => GetLineageGraphResponse.decode(_m0.Reader.create(data)));
  }

  GetLineageSubgraph(request: GetLineageSubgraphRequest): Promise<GetLineageSubgraphResponse> {
    const data = GetLineageSubgraphRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetLineageSubgraph', data);
    return promise.then((data) => GetLineageSubgraphResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER');
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === 'object' && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
